import {
  ApolloCache,
  ApolloClient,
  ApolloError,
  ApolloLink,
  Cache,
  HttpLink,
  InMemoryCache,
  MissingFieldError,
  NetworkStatus,
  Observable,
  ObservableQuery,
  __assign,
  __rest,
  applyNextFetchPolicy,
  canUseSymbol,
  checkFetcher,
  concat,
  createHttpLink,
  createSignalIfSupported,
  defaultDataIdFromObject,
  defaultPrinter,
  disableExperimentalFragmentVariables,
  disableFragmentWarnings,
  empty,
  enableExperimentalFragmentVariables,
  equal,
  execute,
  fallbackHttpConfig,
  from,
  fromError,
  fromPromise,
  gql,
  invariant,
  isApolloError,
  isReference,
  makeReference,
  makeVar,
  mergeOptions,
  parseAndCheckHttpResponse,
  resetCaches,
  rewriteURIForGET,
  selectHttpOptionsAndBody,
  selectHttpOptionsAndBodyInternal,
  selectURI,
  serializeFetchParameter,
  setVerbosity,
  split,
  throwServerError,
  toPromise
} from "./chunk-IRQTPPZ7.js";
import "./chunk-SEHXG2RB.js";
import {
  require_react
} from "./chunk-CIKXJ334.js";
import {
  __toESM
} from "./chunk-J43GMYXM.js";

// node_modules/@apollo/client/react/context/ApolloConsumer.js
var React2 = __toESM(require_react(), 1);

// node_modules/@apollo/client/react/context/ApolloContext.js
var React = __toESM(require_react(), 1);
var contextKey = canUseSymbol ? Symbol.for("__APOLLO_CONTEXT__") : "__APOLLO_CONTEXT__";
function getApolloContext() {
  var context = React.createContext[contextKey];
  if (!context) {
    Object.defineProperty(React.createContext, contextKey, {
      value: context = React.createContext({}),
      enumerable: false,
      writable: false,
      configurable: true
    });
    context.displayName = "ApolloContext";
  }
  return context;
}

// node_modules/@apollo/client/react/context/ApolloConsumer.js
var ApolloConsumer = function(props) {
  var ApolloContext = getApolloContext();
  return React2.createElement(ApolloContext.Consumer, null, function(context) {
    __DEV__ ? invariant(context && context.client, 'Could not find "client" in the context of ApolloConsumer. Wrap the root component in an <ApolloProvider>.') : invariant(context && context.client, 25);
    return props.children(context.client);
  });
};

// node_modules/@apollo/client/react/context/ApolloProvider.js
var React3 = __toESM(require_react(), 1);
var ApolloProvider = function(_a) {
  var client = _a.client, children = _a.children;
  var ApolloContext = getApolloContext();
  return React3.createElement(ApolloContext.Consumer, null, function(context) {
    if (context === void 0) {
      context = {};
    }
    if (client && context.client !== client) {
      context = Object.assign({}, context, { client });
    }
    __DEV__ ? invariant(context.client, 'ApolloProvider was not passed a client instance. Make sure you pass in your client via the "client" prop.') : invariant(context.client, 26);
    return React3.createElement(ApolloContext.Provider, { value: context }, children);
  });
};

// node_modules/@apollo/client/react/hooks/useApolloClient.js
var import_react = __toESM(require_react(), 1);
function useApolloClient(override) {
  var context = (0, import_react.useContext)(getApolloContext());
  var client = override || context.client;
  __DEV__ ? invariant(!!client, 'Could not find "client" in the context or passed in as an option. Wrap the root component in an <ApolloProvider>, or pass an ApolloClient instance in via options.') : invariant(!!client, 29);
  return client;
}

// node_modules/@apollo/client/react/hooks/useLazyQuery.js
var import_react3 = __toESM(require_react(), 1);

// node_modules/@apollo/client/react/hooks/useQuery.js
var import_react2 = __toESM(require_react(), 1);

// node_modules/@apollo/client/react/parser/index.js
var DocumentType;
(function(DocumentType2) {
  DocumentType2[DocumentType2["Query"] = 0] = "Query";
  DocumentType2[DocumentType2["Mutation"] = 1] = "Mutation";
  DocumentType2[DocumentType2["Subscription"] = 2] = "Subscription";
})(DocumentType || (DocumentType = {}));
var cache = /* @__PURE__ */ new Map();
function operationName(type) {
  var name;
  switch (type) {
    case DocumentType.Query:
      name = "Query";
      break;
    case DocumentType.Mutation:
      name = "Mutation";
      break;
    case DocumentType.Subscription:
      name = "Subscription";
      break;
  }
  return name;
}
function parser(document) {
  var cached = cache.get(document);
  if (cached)
    return cached;
  var variables, type, name;
  __DEV__ ? invariant(!!document && !!document.kind, "Argument of ".concat(document, " passed to parser was not a valid GraphQL ") + "DocumentNode. You may need to use 'graphql-tag' or another method to convert your operation into a document") : invariant(!!document && !!document.kind, 30);
  var fragments = document.definitions.filter(function(x) {
    return x.kind === "FragmentDefinition";
  });
  var queries = document.definitions.filter(function(x) {
    return x.kind === "OperationDefinition" && x.operation === "query";
  });
  var mutations = document.definitions.filter(function(x) {
    return x.kind === "OperationDefinition" && x.operation === "mutation";
  });
  var subscriptions = document.definitions.filter(function(x) {
    return x.kind === "OperationDefinition" && x.operation === "subscription";
  });
  __DEV__ ? invariant(!fragments.length || (queries.length || mutations.length || subscriptions.length), "Passing only a fragment to 'graphql' is not yet supported. You must include a query, subscription or mutation as well") : invariant(!fragments.length || (queries.length || mutations.length || subscriptions.length), 31);
  __DEV__ ? invariant(queries.length + mutations.length + subscriptions.length <= 1, "react-apollo only supports a query, subscription, or a mutation per HOC. " + "".concat(document, " had ").concat(queries.length, " queries, ").concat(subscriptions.length, " ") + "subscriptions and ".concat(mutations.length, " mutations. ") + "You can use 'compose' to join multiple operation types to a component") : invariant(queries.length + mutations.length + subscriptions.length <= 1, 32);
  type = queries.length ? DocumentType.Query : DocumentType.Mutation;
  if (!queries.length && !mutations.length)
    type = DocumentType.Subscription;
  var definitions = queries.length ? queries : mutations.length ? mutations : subscriptions;
  __DEV__ ? invariant(definitions.length === 1, "react-apollo only supports one definition per HOC. ".concat(document, " had ") + "".concat(definitions.length, " definitions. ") + "You can use 'compose' to join multiple operation types to a component") : invariant(definitions.length === 1, 33);
  var definition = definitions[0];
  variables = definition.variableDefinitions || [];
  if (definition.name && definition.name.kind === "Name") {
    name = definition.name.value;
  } else {
    name = "data";
  }
  var payload = { name, type, variables };
  cache.set(document, payload);
  return payload;
}
function verifyDocumentType(document, type) {
  var operation = parser(document);
  var requiredOperationName = operationName(type);
  var usedOperationName = operationName(operation.type);
  __DEV__ ? invariant(operation.type === type, "Running a ".concat(requiredOperationName, " requires a graphql ") + "".concat(requiredOperationName, ", but a ").concat(usedOperationName, " was used instead.")) : invariant(operation.type === type, 34);
}

// node_modules/@apollo/client/react/hooks/useQuery.js
function useQuery(query, options) {
  var _a;
  var context = (0, import_react2.useContext)(getApolloContext());
  var client = useApolloClient(options === null || options === void 0 ? void 0 : options.client);
  var defaultWatchQueryOptions = client.defaultOptions.watchQuery;
  verifyDocumentType(query, DocumentType.Query);
  var _b = (0, import_react2.useState)(function() {
    var watchQueryOptions = createWatchQueryOptions(query, options, defaultWatchQueryOptions);
    var obsQuery2 = null;
    if (context.renderPromises) {
      obsQuery2 = context.renderPromises.getSSRObservable(watchQueryOptions);
    }
    if (!obsQuery2) {
      obsQuery2 = client.watchQuery(watchQueryOptions);
      if (context.renderPromises) {
        context.renderPromises.registerSSRObservable(obsQuery2, watchQueryOptions);
      }
    }
    if (context.renderPromises && (options === null || options === void 0 ? void 0 : options.ssr) !== false && !(options === null || options === void 0 ? void 0 : options.skip) && obsQuery2.getCurrentResult().loading) {
      context.renderPromises.addQueryPromise({
        getOptions: function() {
          return createWatchQueryOptions(query, options, defaultWatchQueryOptions);
        },
        fetchData: function() {
          return new Promise(function(resolve) {
            var sub = obsQuery2.subscribe({
              next: function(result2) {
                if (!result2.loading) {
                  resolve();
                  sub.unsubscribe();
                }
              },
              error: function() {
                resolve();
                sub.unsubscribe();
              },
              complete: function() {
                resolve();
              }
            });
          });
        }
      }, function() {
        return null;
      });
    }
    return obsQuery2;
  }), obsQuery = _b[0], setObsQuery = _b[1];
  var _c = (0, import_react2.useState)(function() {
    var _a2, _b2;
    var result2 = obsQuery.getCurrentResult();
    if (!result2.loading && options) {
      if (result2.error) {
        (_a2 = options.onError) === null || _a2 === void 0 ? void 0 : _a2.call(options, result2.error);
      } else if (result2.data) {
        (_b2 = options.onCompleted) === null || _b2 === void 0 ? void 0 : _b2.call(options, result2.data);
      }
    }
    return result2;
  }), result = _c[0], setResult = _c[1];
  var ref = (0, import_react2.useRef)({
    client,
    query,
    options,
    result,
    previousData: void 0,
    watchQueryOptions: createWatchQueryOptions(query, options, defaultWatchQueryOptions)
  });
  (0, import_react2.useEffect)(function() {
    var _a2, _b2;
    var watchQueryOptions = createWatchQueryOptions(query, options, defaultWatchQueryOptions);
    var nextResult;
    if (ref.current.client !== client || !equal(ref.current.query, query)) {
      var obsQuery_1 = client.watchQuery(watchQueryOptions);
      setObsQuery(obsQuery_1);
      nextResult = obsQuery_1.getCurrentResult();
    } else if (!equal(ref.current.watchQueryOptions, watchQueryOptions)) {
      obsQuery.setOptions(watchQueryOptions).catch(function() {
      });
      nextResult = obsQuery.getCurrentResult();
      ref.current.watchQueryOptions = watchQueryOptions;
    }
    if (nextResult) {
      var previousResult = ref.current.result;
      if (previousResult.data) {
        ref.current.previousData = previousResult.data;
      }
      setResult(ref.current.result = nextResult);
      if (!nextResult.loading && options) {
        if (nextResult.error) {
          (_a2 = options.onError) === null || _a2 === void 0 ? void 0 : _a2.call(options, nextResult.error);
        } else if (nextResult.data) {
          (_b2 = options.onCompleted) === null || _b2 === void 0 ? void 0 : _b2.call(options, nextResult.data);
        }
      }
    }
    Object.assign(ref.current, { client, query });
  }, [obsQuery, client, query, options]);
  (0, import_react2.useEffect)(function() {
    if (context.renderPromises) {
      return;
    }
    var subscription = obsQuery.subscribe(onNext, onError);
    function onNext() {
      var _a2, _b2;
      var previousResult = ref.current.result;
      var result2 = obsQuery.getCurrentResult();
      if (previousResult && previousResult.loading === result2.loading && previousResult.networkStatus === result2.networkStatus && equal(previousResult.data, result2.data)) {
        return;
      }
      if (previousResult.data) {
        ref.current.previousData = previousResult.data;
      }
      setResult(ref.current.result = result2);
      if (!result2.loading) {
        (_b2 = (_a2 = ref.current.options) === null || _a2 === void 0 ? void 0 : _a2.onCompleted) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, result2.data);
      }
    }
    function onError(error) {
      var _a2, _b2;
      var last = obsQuery["last"];
      subscription.unsubscribe();
      try {
        obsQuery.resetLastResults();
        subscription = obsQuery.subscribe(onNext, onError);
      } finally {
        obsQuery["last"] = last;
      }
      if (!error.hasOwnProperty("graphQLErrors")) {
        throw error;
      }
      var previousResult = ref.current.result;
      if (previousResult && previousResult.loading || !equal(error, previousResult.error)) {
        setResult(ref.current.result = {
          data: previousResult.data,
          error,
          loading: false,
          networkStatus: NetworkStatus.error
        });
        (_b2 = (_a2 = ref.current.options) === null || _a2 === void 0 ? void 0 : _a2.onError) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, error);
      }
    }
    return function() {
      return subscription.unsubscribe();
    };
  }, [obsQuery, context.renderPromises, client.disableNetworkFetches]);
  var partial;
  _a = result, partial = _a.partial, result = __rest(_a, ["partial"]);
  {
    if (partial && (options === null || options === void 0 ? void 0 : options.partialRefetch) && !result.loading && (!result.data || Object.keys(result.data).length === 0) && obsQuery.options.fetchPolicy !== "cache-only") {
      result = __assign(__assign({}, result), { loading: true, networkStatus: NetworkStatus.refetch });
      obsQuery.refetch();
    }
    if (context.renderPromises && (options === null || options === void 0 ? void 0 : options.ssr) !== false && !(options === null || options === void 0 ? void 0 : options.skip) && result.loading) {
      obsQuery.setOptions(createWatchQueryOptions(query, options, defaultWatchQueryOptions)).catch(function() {
      });
    }
    Object.assign(ref.current, { options });
  }
  if ((context.renderPromises || client.disableNetworkFetches) && (options === null || options === void 0 ? void 0 : options.ssr) === false) {
    result = ref.current.result = {
      loading: true,
      data: void 0,
      error: void 0,
      networkStatus: NetworkStatus.loading
    };
  } else if ((options === null || options === void 0 ? void 0 : options.skip) || (options === null || options === void 0 ? void 0 : options.fetchPolicy) === "standby") {
    result = {
      loading: false,
      data: void 0,
      error: void 0,
      networkStatus: NetworkStatus.ready
    };
  }
  if (result.errors && result.errors.length) {
    result = __assign(__assign({}, result), { error: result.error || new ApolloError({ graphQLErrors: result.errors }) });
  }
  var obsQueryFields = (0, import_react2.useMemo)(function() {
    return {
      refetch: obsQuery.refetch.bind(obsQuery),
      fetchMore: obsQuery.fetchMore.bind(obsQuery),
      updateQuery: obsQuery.updateQuery.bind(obsQuery),
      startPolling: obsQuery.startPolling.bind(obsQuery),
      stopPolling: obsQuery.stopPolling.bind(obsQuery),
      subscribeToMore: obsQuery.subscribeToMore.bind(obsQuery)
    };
  }, [obsQuery]);
  return __assign(__assign(__assign({}, obsQueryFields), { variables: createWatchQueryOptions(query, options, defaultWatchQueryOptions).variables, client, called: true, previousData: ref.current.previousData }), result);
}
function createWatchQueryOptions(query, options, defaultOptions) {
  var _a;
  if (options === void 0) {
    options = {};
  }
  var skip = options.skip, ssr = options.ssr, onCompleted = options.onCompleted, onError = options.onError, displayName = options.displayName, otherOptions = __rest(options, ["skip", "ssr", "onCompleted", "onError", "displayName"]);
  var watchQueryOptions = __assign({ query }, otherOptions);
  if (defaultOptions) {
    watchQueryOptions = mergeOptions(defaultOptions, watchQueryOptions);
  }
  if (skip) {
    watchQueryOptions.fetchPolicy = "standby";
  } else if (((_a = watchQueryOptions.context) === null || _a === void 0 ? void 0 : _a.renderPromises) && (watchQueryOptions.fetchPolicy === "network-only" || watchQueryOptions.fetchPolicy === "cache-and-network")) {
    watchQueryOptions.fetchPolicy = "cache-first";
  } else if (!watchQueryOptions.fetchPolicy) {
    watchQueryOptions.fetchPolicy = "cache-first";
  }
  if (!watchQueryOptions.variables) {
    watchQueryOptions.variables = {};
  }
  return watchQueryOptions;
}

// node_modules/@apollo/client/react/hooks/useLazyQuery.js
var EAGER_METHODS = [
  "refetch",
  "fetchMore",
  "updateQuery",
  "startPolling",
  "subscribeToMore"
];
function useLazyQuery(query, options) {
  var _a = (0, import_react3.useState)({
    called: false
  }), execution = _a[0], setExecution = _a[1];
  var result = useQuery(query, __assign(__assign(__assign({}, options), execution.options), { fetchPolicy: execution.called ? options === null || options === void 0 ? void 0 : options.fetchPolicy : "standby", skip: void 0 }));
  if (!execution.called) {
    result = __assign(__assign({}, result), { loading: false, data: void 0, error: void 0, called: false });
  }
  var eagerMethods = (0, import_react3.useMemo)(function() {
    var eagerMethods2 = {};
    var _loop_1 = function(key2) {
      var method = result[key2];
      eagerMethods2[key2] = function() {
        var args = [];
        for (var _i2 = 0; _i2 < arguments.length; _i2++) {
          args[_i2] = arguments[_i2];
        }
        setExecution(function(execution2) {
          return __assign(__assign({}, execution2), { called: true });
        });
        return method.apply(void 0, args);
      };
    };
    for (var _i = 0, EAGER_METHODS_1 = EAGER_METHODS; _i < EAGER_METHODS_1.length; _i++) {
      var key = EAGER_METHODS_1[_i];
      _loop_1(key);
    }
    return eagerMethods2;
  }, []);
  result.error = result.error || void 0;
  Object.assign(result, eagerMethods);
  var execute2 = (0, import_react3.useCallback)(function(executeOptions) {
    setExecution({ called: true, options: executeOptions });
    return result.refetch(executeOptions === null || executeOptions === void 0 ? void 0 : executeOptions.variables).then(function(result1) {
      var result2 = __assign(__assign({}, result), { data: result1.data, error: result1.error, called: true, loading: false });
      Object.assign(result2, eagerMethods);
      return result2;
    });
  }, []);
  return [execute2, result];
}

// node_modules/@apollo/client/react/hooks/useMutation.js
var import_react4 = __toESM(require_react(), 1);
function useMutation(mutation, options) {
  var client = useApolloClient(options === null || options === void 0 ? void 0 : options.client);
  verifyDocumentType(mutation, DocumentType.Mutation);
  var _a = (0, import_react4.useState)({
    called: false,
    loading: false,
    client
  }), result = _a[0], setResult = _a[1];
  var ref = (0, import_react4.useRef)({
    result,
    mutationId: 0,
    isMounted: true,
    client,
    mutation,
    options
  });
  {
    Object.assign(ref.current, { client, options, mutation });
  }
  var execute2 = (0, import_react4.useCallback)(function(executeOptions) {
    if (executeOptions === void 0) {
      executeOptions = {};
    }
    var _a2 = ref.current, client2 = _a2.client, options2 = _a2.options, mutation2 = _a2.mutation;
    var baseOptions = __assign(__assign({}, options2), { mutation: mutation2 });
    if (!ref.current.result.loading && !baseOptions.ignoreResults) {
      setResult(ref.current.result = {
        loading: true,
        error: void 0,
        data: void 0,
        called: true,
        client: client2
      });
    }
    var mutationId = ++ref.current.mutationId;
    var clientOptions = mergeOptions(baseOptions, executeOptions);
    return client2.mutate(clientOptions).then(function(response) {
      var _a3, _b;
      var data = response.data, errors = response.errors;
      var error = errors && errors.length > 0 ? new ApolloError({ graphQLErrors: errors }) : void 0;
      if (mutationId === ref.current.mutationId && !clientOptions.ignoreResults) {
        var result_1 = {
          called: true,
          loading: false,
          data,
          error,
          client: client2
        };
        if (ref.current.isMounted && !equal(ref.current.result, result_1)) {
          setResult(ref.current.result = result_1);
        }
      }
      (_a3 = baseOptions.onCompleted) === null || _a3 === void 0 ? void 0 : _a3.call(baseOptions, response.data);
      (_b = executeOptions.onCompleted) === null || _b === void 0 ? void 0 : _b.call(executeOptions, response.data);
      return response;
    }).catch(function(error) {
      var _a3, _b;
      if (mutationId === ref.current.mutationId && ref.current.isMounted) {
        var result_2 = {
          loading: false,
          error,
          data: void 0,
          called: true,
          client: client2
        };
        if (!equal(ref.current.result, result_2)) {
          setResult(ref.current.result = result_2);
        }
      }
      if (baseOptions.onError || clientOptions.onError) {
        (_a3 = baseOptions.onError) === null || _a3 === void 0 ? void 0 : _a3.call(baseOptions, error);
        (_b = executeOptions.onError) === null || _b === void 0 ? void 0 : _b.call(executeOptions, error);
        return { data: void 0, errors: error };
      }
      throw error;
    });
  }, []);
  var reset = (0, import_react4.useCallback)(function() {
    setResult({ called: false, loading: false, client });
  }, []);
  (0, import_react4.useEffect)(function() {
    return function() {
      ref.current.isMounted = false;
    };
  }, []);
  return [execute2, __assign({ reset }, result)];
}

// node_modules/@apollo/client/react/hooks/useSubscription.js
var import_react5 = __toESM(require_react(), 1);
function useSubscription(subscription, options) {
  var client = useApolloClient(options === null || options === void 0 ? void 0 : options.client);
  verifyDocumentType(subscription, DocumentType.Subscription);
  var _a = (0, import_react5.useState)({
    loading: !(options === null || options === void 0 ? void 0 : options.skip),
    error: void 0,
    data: void 0,
    variables: options === null || options === void 0 ? void 0 : options.variables
  }), result = _a[0], setResult = _a[1];
  var _b = (0, import_react5.useState)(function() {
    if (options === null || options === void 0 ? void 0 : options.skip) {
      return null;
    }
    return client.subscribe({
      query: subscription,
      variables: options === null || options === void 0 ? void 0 : options.variables,
      fetchPolicy: options === null || options === void 0 ? void 0 : options.fetchPolicy,
      context: options === null || options === void 0 ? void 0 : options.context
    });
  }), observable = _b[0], setObservable = _b[1];
  var ref = (0, import_react5.useRef)({ client, subscription, options });
  (0, import_react5.useEffect)(function() {
    var _a2, _b2, _c, _d;
    var shouldResubscribe = options === null || options === void 0 ? void 0 : options.shouldResubscribe;
    if (typeof shouldResubscribe === "function") {
      shouldResubscribe = !!shouldResubscribe(options);
    }
    if ((options === null || options === void 0 ? void 0 : options.skip) && !(options === null || options === void 0 ? void 0 : options.skip) !== !((_a2 = ref.current.options) === null || _a2 === void 0 ? void 0 : _a2.skip)) {
      setResult({
        loading: false,
        data: void 0,
        error: void 0,
        variables: options === null || options === void 0 ? void 0 : options.variables
      });
      setObservable(null);
    } else if (shouldResubscribe !== false && (client !== ref.current.client || subscription !== ref.current.subscription || (options === null || options === void 0 ? void 0 : options.fetchPolicy) !== ((_b2 = ref.current.options) === null || _b2 === void 0 ? void 0 : _b2.fetchPolicy) || !(options === null || options === void 0 ? void 0 : options.skip) !== !((_c = ref.current.options) === null || _c === void 0 ? void 0 : _c.skip) || !equal(options === null || options === void 0 ? void 0 : options.variables, (_d = ref.current.options) === null || _d === void 0 ? void 0 : _d.variables))) {
      setResult({
        loading: true,
        data: void 0,
        error: void 0,
        variables: options === null || options === void 0 ? void 0 : options.variables
      });
      setObservable(client.subscribe({
        query: subscription,
        variables: options === null || options === void 0 ? void 0 : options.variables,
        fetchPolicy: options === null || options === void 0 ? void 0 : options.fetchPolicy,
        context: options === null || options === void 0 ? void 0 : options.context
      }));
    }
    Object.assign(ref.current, { client, subscription, options });
  }, [client, subscription, options]);
  (0, import_react5.useEffect)(function() {
    if (!observable) {
      return;
    }
    var subscription2 = observable.subscribe({
      next: function(fetchResult) {
        var _a2, _b2;
        var result2 = {
          loading: false,
          data: fetchResult.data,
          error: void 0,
          variables: options === null || options === void 0 ? void 0 : options.variables
        };
        setResult(result2);
        (_b2 = (_a2 = ref.current.options) === null || _a2 === void 0 ? void 0 : _a2.onSubscriptionData) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, {
          client,
          subscriptionData: result2
        });
      },
      error: function(error) {
        setResult({
          loading: false,
          data: void 0,
          error,
          variables: options === null || options === void 0 ? void 0 : options.variables
        });
      },
      complete: function() {
        var _a2, _b2;
        (_b2 = (_a2 = ref.current.options) === null || _a2 === void 0 ? void 0 : _a2.onSubscriptionComplete) === null || _b2 === void 0 ? void 0 : _b2.call(_a2);
      }
    });
    return function() {
      subscription2.unsubscribe();
    };
  }, [observable]);
  return result;
}

// node_modules/@apollo/client/react/hooks/useReactiveVar.js
var import_react6 = __toESM(require_react(), 1);
function useReactiveVar(rv) {
  var value = rv();
  var setValue = (0, import_react6.useState)(value)[1];
  (0, import_react6.useEffect)(function() {
    var probablySameValue = rv();
    if (value !== probablySameValue) {
      setValue(probablySameValue);
    } else {
      return rv.onNextChange(setValue);
    }
  }, [value]);
  return value;
}
export {
  ApolloCache,
  ApolloClient,
  ApolloConsumer,
  ApolloError,
  ApolloLink,
  ApolloProvider,
  Cache,
  DocumentType,
  HttpLink,
  InMemoryCache,
  MissingFieldError,
  NetworkStatus,
  Observable,
  ObservableQuery,
  applyNextFetchPolicy,
  checkFetcher,
  concat,
  createHttpLink,
  createSignalIfSupported,
  defaultDataIdFromObject,
  defaultPrinter,
  disableExperimentalFragmentVariables,
  disableFragmentWarnings,
  empty,
  enableExperimentalFragmentVariables,
  execute,
  fallbackHttpConfig,
  from,
  fromError,
  fromPromise,
  getApolloContext,
  gql,
  isApolloError,
  isReference,
  makeReference,
  makeVar,
  mergeOptions,
  operationName,
  parseAndCheckHttpResponse,
  parser,
  getApolloContext as resetApolloContext,
  resetCaches,
  rewriteURIForGET,
  selectHttpOptionsAndBody,
  selectHttpOptionsAndBodyInternal,
  selectURI,
  serializeFetchParameter,
  setVerbosity as setLogVerbosity,
  split,
  throwServerError,
  toPromise,
  useApolloClient,
  useLazyQuery,
  useMutation,
  useQuery,
  useReactiveVar,
  useSubscription
};
//# sourceMappingURL=@apollo_client.js.map
