{
  "version": 3,
  "sources": ["../../@apollo/src/react/context/ApolloConsumer.tsx", "../../@apollo/src/react/context/ApolloContext.ts", "../../@apollo/src/react/context/ApolloProvider.tsx", "../../@apollo/src/react/hooks/useApolloClient.ts", "../../@apollo/src/react/hooks/useLazyQuery.ts", "../../@apollo/src/react/hooks/useQuery.ts", "../../@apollo/src/react/parser/index.ts", "../../@apollo/src/react/hooks/useMutation.ts", "../../@apollo/src/react/hooks/useSubscription.ts", "../../@apollo/src/react/hooks/useReactiveVar.ts"],
  "sourcesContent": ["import { invariant } from '../../utilities/globals';\n\nimport * as React from 'react';\n\nimport { ApolloClient } from '../../core';\nimport { getApolloContext } from './ApolloContext';\n\nexport interface ApolloConsumerProps {\n  children: (client: ApolloClient<object>) => React.ReactChild | null;\n}\n\nexport const ApolloConsumer: React.FC<ApolloConsumerProps> = props => {\n  const ApolloContext = getApolloContext();\n  return (\n    <ApolloContext.Consumer>\n      {(context: any) => {\n        invariant(\n          context && context.client,\n          'Could not find \"client\" in the context of ApolloConsumer. ' +\n            'Wrap the root component in an <ApolloProvider>.'\n        );\n        return props.children(context.client);\n      }}\n    </ApolloContext.Consumer>\n  );\n};\n", "import * as React from 'react';\nimport { ApolloClient } from '../../core';\nimport { canUseSymbol } from '../../utilities';\nimport type { RenderPromises } from '../ssr';\n\nexport interface ApolloContextValue {\n  client?: ApolloClient<object>;\n  renderPromises?: RenderPromises;\n}\n\n// To make sure Apollo Client doesn't create more than one React context\n// (which can lead to problems like having an Apollo Client instance added\n// in one context, then attempting to retrieve it from another different\n// context), a single Apollo context is created and tracked in global state.\nconst contextKey = canUseSymbol\n  ? Symbol.for('__APOLLO_CONTEXT__')\n  : '__APOLLO_CONTEXT__';\n\nexport function getApolloContext(): React.Context<ApolloContextValue> {\n  let context = (React.createContext as any)[contextKey] as React.Context<ApolloContextValue>;\n  if (!context) {\n    Object.defineProperty(React.createContext, contextKey, {\n      value: context = React.createContext<ApolloContextValue>({}),\n      enumerable: false,\n      writable: false,\n      configurable: true,\n    });\n    context.displayName = 'ApolloContext';\n  }\n  return context;\n}\n\nexport { getApolloContext as resetApolloContext }\n", "import { invariant } from '../../utilities/globals';\n\nimport * as React from 'react';\n\nimport { ApolloClient } from '../../core';\nimport { getApolloContext } from './ApolloContext';\n\nexport interface ApolloProviderProps<TCache> {\n  client: ApolloClient<TCache>;\n  children: React.ReactNode | React.ReactNode[] | null;\n}\n\nexport const ApolloProvider: React.FC<ApolloProviderProps<any>> = ({\n  client,\n  children\n}) => {\n  const ApolloContext = getApolloContext();\n  return (\n    <ApolloContext.Consumer>\n      {(context: any = {}) => {\n        if (client && context.client !== client) {\n          context = Object.assign({}, context, { client });\n        }\n\n        invariant(\n          context.client,\n          'ApolloProvider was not passed a client instance. Make ' +\n            'sure you pass in your client via the \"client\" prop.'\n        );\n\n        return (\n          <ApolloContext.Provider value={context}>\n            {children}\n          </ApolloContext.Provider>\n        );\n      }}\n    </ApolloContext.Consumer>\n  );\n};\n", "import { invariant } from '../../utilities/globals';\nimport { useContext } from 'react';\nimport { ApolloClient } from '../../core';\nimport { getApolloContext } from '../context';\n\nexport function useApolloClient(\n  override?: ApolloClient<object>,\n): ApolloClient<object> {\n  const context = useContext(getApolloContext());\n  const client = override || context.client;\n  invariant(\n    !!client,\n    'Could not find \"client\" in the context or passed in as an option. ' +\n    'Wrap the root component in an <ApolloProvider>, or pass an ApolloClient ' +\n    'instance in via options.',\n  );\n\n  return client;\n}\n", "import { DocumentNode } from 'graphql';\nimport { TypedDocumentNode } from '@graphql-typed-document-node/core';\nimport { useCallback, useMemo, useState } from 'react';\n\nimport {\n  LazyQueryHookOptions,\n  QueryLazyOptions,\n  QueryTuple,\n} from '../types/types';\nimport { useQuery } from './useQuery';\nimport { OperationVariables } from '../../core';\n\n// The following methods, when called will execute the query, regardless of\n// whether the useLazyQuery execute function was called before.\nconst EAGER_METHODS = [\n  'refetch',\n  'fetchMore',\n  'updateQuery',\n  'startPolling',\n  'subscribeToMore',\n] as const;\n\nexport function useLazyQuery<TData = any, TVariables = OperationVariables>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: LazyQueryHookOptions<TData, TVariables>\n): QueryTuple<TData, TVariables> {\n  const [execution, setExecution] = useState<{\n    called: boolean,\n    options?: QueryLazyOptions<TVariables>,\n  }>({\n    called: false,\n  });\n\n  let result = useQuery<TData, TVariables>(query, {\n    ...options,\n    ...execution.options,\n    // We don\u2019t set skip to execution.called, because some useQuery SSR code\n    // checks skip for some reason.\n    fetchPolicy: execution.called ? options?.fetchPolicy : 'standby',\n    skip: undefined,\n  });\n\n  if (!execution.called) {\n    result = {\n      ...result,\n      loading: false,\n      data: void 0 as unknown as TData,\n      error: void 0,\n      called: false,\n    };\n  }\n\n  // We use useMemo here to make sure the eager methods have a stable identity.\n  const eagerMethods = useMemo(() => {\n    const eagerMethods: Record<string, any> = {};\n    for (const key of EAGER_METHODS) {\n      const method = result[key];\n      eagerMethods[key] = (...args: any) => {\n        setExecution((execution) => ({ ...execution, called: true }));\n        return (method as any)(...args);\n      };\n    }\n\n    return eagerMethods;\n  }, []);\n\n  result.error = result.error || void 0;\n  Object.assign(result, eagerMethods);\n\n  const execute = useCallback<\n    QueryTuple<TData, TVariables>[0]\n  >((executeOptions?: QueryLazyOptions<TVariables>) => {\n    setExecution({ called: true, options: executeOptions });\n    return result.refetch(executeOptions?.variables).then((result1) => {\n      const result2 = {\n        ...result,\n        data: result1.data,\n        error: result1.error,\n        called: true,\n        loading: false,\n      };\n\n      Object.assign(result2, eagerMethods);\n      return result2;\n    });\n  }, []);\n\n  return [execute, result];\n}\n", "import { useContext, useEffect, useMemo, useRef, useState } from 'react';\nimport { equal } from '@wry/equality';\nimport { OperationVariables, mergeOptions } from '../../core';\nimport { getApolloContext } from '../context';\nimport { ApolloError } from '../../errors';\nimport {\n  ApolloQueryResult,\n  NetworkStatus,\n  ObservableQuery,\n  DocumentNode,\n  TypedDocumentNode,\n  WatchQueryOptions,\n} from '../../core';\nimport {\n  QueryHookOptions,\n  QueryResult,\n} from '../types/types';\n\nimport { DocumentType, verifyDocumentType } from '../parser';\nimport { useApolloClient } from './useApolloClient';\n\nexport function useQuery<\n  TData = any,\n  TVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: QueryHookOptions<TData, TVariables>,\n): QueryResult<TData, TVariables> {\n  const context = useContext(getApolloContext());\n  const client = useApolloClient(options?.client);\n  const defaultWatchQueryOptions = client.defaultOptions.watchQuery;\n  verifyDocumentType(query, DocumentType.Query);\n  const [obsQuery, setObsQuery] = useState(() => {\n    const watchQueryOptions = createWatchQueryOptions(query, options, defaultWatchQueryOptions);\n    // See if there is an existing observable that was used to fetch the same\n    // data and if so, use it instead since it will contain the proper queryId\n    // to fetch the result set. This is used during SSR.\n    let obsQuery: ObservableQuery<TData, TVariables> | null = null;\n    if (context.renderPromises) {\n      obsQuery = context.renderPromises.getSSRObservable(watchQueryOptions);\n    }\n\n    if (!obsQuery) {\n      // Is it safe (StrictMode/memory-wise) to call client.watchQuery here?\n      obsQuery = client.watchQuery(watchQueryOptions);\n      if (context.renderPromises) {\n        context.renderPromises.registerSSRObservable(\n          obsQuery,\n          watchQueryOptions,\n        );\n      }\n    }\n\n    if (\n      context.renderPromises &&\n      options?.ssr !== false &&\n      !options?.skip &&\n      obsQuery.getCurrentResult().loading\n    ) {\n      // TODO: This is a legacy API which could probably be cleaned up\n      context.renderPromises.addQueryPromise(\n        {\n          // The only options which seem to actually be used by the\n          // RenderPromises class are query and variables.\n          getOptions: () => createWatchQueryOptions(query, options, defaultWatchQueryOptions),\n          fetchData: () => new Promise<void>((resolve) => {\n            const sub = obsQuery!.subscribe({\n              next(result) {\n                if (!result.loading) {\n                  resolve()\n                  sub.unsubscribe();\n                }\n              },\n              error() {\n                resolve();\n                sub.unsubscribe();\n              },\n              complete() {\n                resolve();\n              },\n            });\n          }),\n        },\n        // This callback never seemed to do anything\n        () => null,\n      );\n    }\n\n    return obsQuery;\n  });\n\n  let [result, setResult] = useState(() => {\n    const result = obsQuery.getCurrentResult();\n    if (!result.loading && options) {\n      if (result.error) {\n        options.onError?.(result.error);\n      } else if (result.data) {\n        options.onCompleted?.(result.data);\n      }\n    }\n\n    return result;\n  });\n\n  const ref = useRef({\n    client,\n    query,\n    options,\n    result,\n    previousData: void 0 as TData | undefined,\n    watchQueryOptions: createWatchQueryOptions(query, options, defaultWatchQueryOptions),\n  });\n\n  // An effect to recreate the obsQuery whenever the client or query changes.\n  // This effect is also responsible for checking and updating the obsQuery\n  // options whenever they change.\n  useEffect(() => {\n    const watchQueryOptions = createWatchQueryOptions(query, options, defaultWatchQueryOptions);\n    let nextResult: ApolloQueryResult<TData> | undefined;\n    if (ref.current.client !== client || !equal(ref.current.query, query)) {\n      const obsQuery = client.watchQuery(watchQueryOptions);\n      setObsQuery(obsQuery);\n      nextResult = obsQuery.getCurrentResult();\n    } else if (!equal(ref.current.watchQueryOptions, watchQueryOptions)) {\n      obsQuery.setOptions(watchQueryOptions).catch(() => {});\n      nextResult = obsQuery.getCurrentResult();\n      ref.current.watchQueryOptions = watchQueryOptions;\n    }\n\n    if (nextResult) {\n      const previousResult = ref.current.result;\n      if (previousResult.data) {\n        ref.current.previousData = previousResult.data;\n      }\n\n      setResult(ref.current.result = nextResult);\n      if (!nextResult.loading && options) {\n        if (nextResult.error) {\n          options.onError?.(nextResult.error);\n        } else if (nextResult.data) {\n          options.onCompleted?.(nextResult.data);\n        }\n      }\n    }\n\n    Object.assign(ref.current, { client, query });\n  }, [obsQuery, client, query, options]);\n\n  // An effect to subscribe to the current observable query\n  useEffect(() => {\n    if (context.renderPromises) {\n      return;\n    }\n\n    let subscription = obsQuery.subscribe(onNext, onError);\n    // We use `getCurrentResult()` instead of the callback argument because\n    // the values differ slightly. Specifically, loading results will have\n    // an empty object for data instead of `undefined` for some reason.\n    function onNext() {\n      const previousResult = ref.current.result;\n      const result = obsQuery.getCurrentResult();\n      // Make sure we're not attempting to re-render similar results\n      if (\n        previousResult &&\n        previousResult.loading === result.loading &&\n        previousResult.networkStatus === result.networkStatus &&\n        equal(previousResult.data, result.data)\n      ) {\n        return;\n      }\n\n      if (previousResult.data) {\n        ref.current.previousData = previousResult.data;\n      }\n\n      setResult(ref.current.result = result);\n      if (!result.loading) {\n        ref.current.options?.onCompleted?.(result.data);\n      }\n    }\n\n    function onError(error: Error) {\n      const last = obsQuery[\"last\"];\n      subscription.unsubscribe();\n      // Unfortunately, if `lastError` is set in the current\n      // `observableQuery` when the subscription is re-created,\n      // the subscription will immediately receive the error, which will\n      // cause it to terminate again. To avoid this, we first clear\n      // the last error/result from the `observableQuery` before re-starting\n      // the subscription, and restore it afterwards (so the subscription\n      // has a chance to stay open).\n      try {\n        obsQuery.resetLastResults();\n        subscription = obsQuery.subscribe(onNext, onError);\n      } finally {\n        obsQuery[\"last\"] = last;\n      }\n\n      if (!error.hasOwnProperty('graphQLErrors')) {\n        // The error is not a GraphQL error\n        throw error;\n      }\n\n      const previousResult = ref.current.result;\n      if (\n        (previousResult && previousResult.loading) ||\n        !equal(error, previousResult.error)\n      ) {\n        setResult(ref.current.result = {\n          data: previousResult.data,\n          error: error as ApolloError,\n          loading: false,\n          networkStatus: NetworkStatus.error,\n        });\n        ref.current.options?.onError?.(error as ApolloError);\n      }\n    }\n\n    return () => subscription.unsubscribe();\n  }, [obsQuery, context.renderPromises, client.disableNetworkFetches]);\n\n  let partial: boolean | undefined;\n  ({ partial, ...result } = result);\n\n  {\n    // BAD BOY CODE BLOCK WHERE WE PUT SIDE-EFFECTS IN THE RENDER FUNCTION\n    //\n    // TODO: This code should be removed when the partialRefetch option is\n    // removed. I was unable to get this hook to behave reasonably in certain\n    // edge cases when this block was put in an effect.\n    if (\n      partial &&\n      options?.partialRefetch &&\n      !result.loading &&\n      (!result.data || Object.keys(result.data).length === 0) &&\n      obsQuery.options.fetchPolicy !== 'cache-only'\n    ) {\n      result = {\n        ...result,\n        loading: true,\n        networkStatus: NetworkStatus.refetch,\n      };\n\n      obsQuery.refetch();\n    }\n\n    // TODO: This is a hack to make sure useLazyQuery executions update the\n    // obsevable query options for ssr.\n    if (\n      context.renderPromises &&\n      options?.ssr !== false &&\n      !options?.skip &&\n      result.loading\n    ) {\n      obsQuery.setOptions(createWatchQueryOptions(query, options, defaultWatchQueryOptions)).catch(() => {});\n    }\n\n    // We assign options during rendering as a guard to make sure that\n    // callbacks like onCompleted and onError are not stale.\n    Object.assign(ref.current, { options });\n  }\n\n  if (\n    (context.renderPromises || client.disableNetworkFetches) &&\n    options?.ssr === false\n  ) {\n    // If SSR has been explicitly disabled, and this function has been called\n    // on the server side, return the default loading state.\n    result = ref.current.result = {\n      loading: true,\n      data: void 0 as unknown as TData,\n      error: void 0,\n      networkStatus: NetworkStatus.loading,\n    };\n  } else if (options?.skip || options?.fetchPolicy === 'standby') {\n    // When skipping a query (ie. we're not querying for data but still want to\n    // render children), make sure the `data` is cleared out and `loading` is\n    // set to `false` (since we aren't loading anything).\n    //\n    // NOTE: We no longer think this is the correct behavior. Skipping should\n    // not automatically set `data` to `undefined`, but instead leave the\n    // previous data in place. In other words, skipping should not mandate that\n    // previously received data is all of a sudden removed. Unfortunately,\n    // changing this is breaking, so we'll have to wait until Apollo Client 4.0\n    // to address this.\n    result = {\n      loading: false,\n      data: void 0 as unknown as TData,\n      error: void 0,\n      networkStatus: NetworkStatus.ready,\n    };\n  }\n\n  if (result.errors && result.errors.length) {\n    // Until a set naming convention for networkError and graphQLErrors is\n    // decided upon, we map errors (graphQLErrors) to the error options.\n    // TODO: Is it possible for both result.error and result.errors to be\n    // defined here?\n    result = {\n      ...result,\n      error: result.error || new ApolloError({ graphQLErrors: result.errors }),\n    };\n  }\n\n  const obsQueryFields = useMemo(() => ({\n    refetch: obsQuery.refetch.bind(obsQuery),\n    fetchMore: obsQuery.fetchMore.bind(obsQuery),\n    updateQuery: obsQuery.updateQuery.bind(obsQuery),\n    startPolling: obsQuery.startPolling.bind(obsQuery),\n    stopPolling: obsQuery.stopPolling.bind(obsQuery),\n    subscribeToMore: obsQuery.subscribeToMore.bind(obsQuery),\n  }), [obsQuery]);\n\n  return {\n    ...obsQueryFields,\n    variables: createWatchQueryOptions(query, options, defaultWatchQueryOptions).variables,\n    client,\n    called: true,\n    previousData: ref.current.previousData,\n    ...result,\n  };\n}\n\n/**\n * A function to massage options before passing them the ObservableQuery.\n */\nfunction createWatchQueryOptions<TData, TVariables>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: QueryHookOptions<TData, TVariables> = {},\n  defaultOptions?: Partial<WatchQueryOptions<any, any>>\n): WatchQueryOptions<TVariables, TData> {\n  // TODO: For some reason, we pass context, which is the React Apollo Context,\n  // into observable queries, and test for that.\n  // removing hook specific options\n  const {\n    skip,\n    ssr,\n    onCompleted,\n    onError,\n    displayName,\n    ...otherOptions\n  } = options;\n\n  let watchQueryOptions = { query, ...otherOptions };\n  if (defaultOptions) {\n    watchQueryOptions = mergeOptions(defaultOptions, watchQueryOptions);\n  }\n\n  if (skip) {\n    watchQueryOptions.fetchPolicy = 'standby';\n  } else if (\n    watchQueryOptions.context?.renderPromises &&\n    (\n      watchQueryOptions.fetchPolicy === 'network-only' ||\n      watchQueryOptions.fetchPolicy === 'cache-and-network'\n    )\n  ) {\n    // this behavior was added to react-apollo without explanation in this PR\n    // https://github.com/apollographql/react-apollo/pull/1579\n    watchQueryOptions.fetchPolicy = 'cache-first';\n  } else if (!watchQueryOptions.fetchPolicy) {\n    // cache-first is the default policy, but we explicitly assign it here so\n    // the cache policies computed based on options can be cleared\n    watchQueryOptions.fetchPolicy = 'cache-first';\n  }\n\n  if (!watchQueryOptions.variables) {\n    watchQueryOptions.variables = {} as TVariables;\n  }\n\n  return watchQueryOptions;\n}\n", "import { invariant } from '../../utilities/globals';\n\nimport {\n  DocumentNode,\n  DefinitionNode,\n  VariableDefinitionNode,\n  OperationDefinitionNode\n} from 'graphql';\n\nexport enum DocumentType {\n  Query,\n  Mutation,\n  Subscription\n}\n\nexport interface IDocumentDefinition {\n  type: DocumentType;\n  name: string;\n  variables: ReadonlyArray<VariableDefinitionNode>;\n}\n\nconst cache = new Map();\n\nexport function operationName(type: DocumentType) {\n  let name;\n  switch (type) {\n    case DocumentType.Query:\n      name = 'Query';\n      break;\n    case DocumentType.Mutation:\n      name = 'Mutation';\n      break;\n    case DocumentType.Subscription:\n      name = 'Subscription';\n      break;\n  }\n  return name;\n}\n\n// This parser is mostly used to safety check incoming documents.\nexport function parser(document: DocumentNode): IDocumentDefinition {\n  const cached = cache.get(document);\n  if (cached) return cached;\n\n  let variables, type, name;\n\n  invariant(\n    !!document && !!document.kind,\n    `Argument of ${document} passed to parser was not a valid GraphQL ` +\n      `DocumentNode. You may need to use 'graphql-tag' or another method ` +\n      `to convert your operation into a document`\n  );\n\n  const fragments = document.definitions.filter(\n    (x: DefinitionNode) => x.kind === 'FragmentDefinition'\n  );\n\n  const queries = document.definitions.filter(\n    (x: DefinitionNode) =>\n      x.kind === 'OperationDefinition' && x.operation === 'query'\n  );\n\n  const mutations = document.definitions.filter(\n    (x: DefinitionNode) =>\n      x.kind === 'OperationDefinition' && x.operation === 'mutation'\n  );\n\n  const subscriptions = document.definitions.filter(\n    (x: DefinitionNode) =>\n      x.kind === 'OperationDefinition' && x.operation === 'subscription'\n  );\n\n  invariant(\n    !fragments.length ||\n      (queries.length || mutations.length || subscriptions.length),\n    `Passing only a fragment to 'graphql' is not yet supported. ` +\n      `You must include a query, subscription or mutation as well`\n  );\n\n  invariant(\n    queries.length + mutations.length + subscriptions.length <= 1,\n    `react-apollo only supports a query, subscription, or a mutation per HOC. ` +\n      `${document} had ${queries.length} queries, ${subscriptions.length} ` +\n      `subscriptions and ${mutations.length} mutations. ` +\n      `You can use 'compose' to join multiple operation types to a component`\n  );\n\n  type = queries.length ? DocumentType.Query : DocumentType.Mutation;\n  if (!queries.length && !mutations.length) type = DocumentType.Subscription;\n\n  const definitions = queries.length\n    ? queries\n    : mutations.length\n    ? mutations\n    : subscriptions;\n\n  invariant(\n    definitions.length === 1,\n    `react-apollo only supports one definition per HOC. ${document} had ` +\n      `${definitions.length} definitions. ` +\n      `You can use 'compose' to join multiple operation types to a component`\n  );\n\n  const definition = definitions[0] as OperationDefinitionNode;\n  variables = definition.variableDefinitions || [];\n\n  if (definition.name && definition.name.kind === 'Name') {\n    name = definition.name.value;\n  } else {\n    name = 'data'; // fallback to using data if no name\n  }\n\n  const payload = { name, type, variables };\n  cache.set(document, payload);\n  return payload;\n}\n\nexport function verifyDocumentType(document: DocumentNode, type: DocumentType) {\n  const operation = parser(document);\n  const requiredOperationName = operationName(type);\n  const usedOperationName = operationName(operation.type);\n  invariant(\n    operation.type === type,\n    `Running a ${requiredOperationName} requires a graphql ` +\n      `${requiredOperationName}, but a ${usedOperationName} was used instead.`\n  );\n}\n\n", "import { useCallback, useEffect, useRef, useState } from 'react';\nimport { DocumentNode } from 'graphql';\nimport { TypedDocumentNode } from '@graphql-typed-document-node/core';\nimport {\n  MutationFunctionOptions,\n  MutationHookOptions,\n  MutationResult,\n  MutationTuple,\n} from '../types/types';\n\nimport {\n  ApolloCache,\n  DefaultContext,\n  mergeOptions,\n  OperationVariables,\n} from '../../core';\nimport { equal } from '@wry/equality';\nimport { DocumentType, verifyDocumentType } from '../parser';\nimport { ApolloError } from '../../errors';\nimport { useApolloClient } from './useApolloClient';\n\nexport function useMutation<\n  TData = any,\n  TVariables = OperationVariables,\n  TContext = DefaultContext,\n  TCache extends ApolloCache<any> = ApolloCache<any>,\n>(\n  mutation: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: MutationHookOptions<TData, TVariables, TContext>,\n): MutationTuple<TData, TVariables, TContext, TCache> {\n  const client = useApolloClient(options?.client);\n  verifyDocumentType(mutation, DocumentType.Mutation);\n  const [result, setResult] = useState<Omit<MutationResult, 'reset'>>({\n    called: false,\n    loading: false,\n    client,\n  });\n\n  const ref = useRef({\n    result,\n    mutationId: 0,\n    isMounted: true,\n    client,\n    mutation,\n    options,\n  });\n\n  // TODO: Trying to assign these in a useEffect or useLayoutEffect breaks\n  // higher-order components.\n  {\n    Object.assign(ref.current, { client, options, mutation });\n  }\n\n  const execute = useCallback((\n    executeOptions: MutationFunctionOptions<\n      TData,\n      TVariables,\n      TContext,\n      TCache\n    > = {}\n  ) => {\n    const {client, options, mutation} = ref.current;\n    const baseOptions = { ...options, mutation };\n    if (!ref.current.result.loading && !baseOptions.ignoreResults) {\n      setResult(ref.current.result = {\n        loading: true,\n        error: void 0,\n        data: void 0,\n        called: true,\n        client,\n      });\n    }\n\n    const mutationId = ++ref.current.mutationId;\n    const clientOptions = mergeOptions(\n      baseOptions,\n      executeOptions as any,\n    );\n\n    return client.mutate(clientOptions).then((response) => {\n      const { data, errors } = response;\n      const error =\n        errors && errors.length > 0\n          ? new ApolloError({ graphQLErrors: errors })\n          : void 0;\n\n      if (\n        mutationId === ref.current.mutationId &&\n        !clientOptions.ignoreResults\n      ) {\n        const result = {\n          called: true,\n          loading: false,\n          data,\n          error,\n          client,\n        };\n\n        if (ref.current.isMounted && !equal(ref.current.result, result)) {\n          setResult(ref.current.result = result);\n        }\n      }\n\n      baseOptions.onCompleted?.(response.data!);\n      executeOptions.onCompleted?.(response.data!);\n      return response;\n    }).catch((error) => {\n      if (\n        mutationId === ref.current.mutationId &&\n        ref.current.isMounted\n      ) {\n        const result = {\n          loading: false,\n          error,\n          data: void 0,\n          called: true,\n          client,\n        };\n\n        if (!equal(ref.current.result, result)) {\n          setResult(ref.current.result = result);\n        }\n      }\n\n      if (baseOptions.onError || clientOptions.onError) {\n        baseOptions.onError?.(error);\n        executeOptions.onError?.(error);\n        // TODO(brian): why are we returning this here???\n        return { data: void 0, errors: error };\n      }\n\n      throw error;\n    });\n  }, []);\n\n  const reset = useCallback(() => {\n    setResult({ called: false, loading: false, client });\n  }, []);\n\n  useEffect(() => () => {\n    ref.current.isMounted = false;\n  }, []);\n\n  return [execute, { reset, ...result }];\n}\n", "import '../../utilities/globals';\nimport { useState, useRef, useEffect } from 'react';\nimport { DocumentNode } from 'graphql';\nimport { TypedDocumentNode } from '@graphql-typed-document-node/core';\nimport { equal } from '@wry/equality';\n\nimport { DocumentType, verifyDocumentType } from '../parser';\nimport {\n  SubscriptionHookOptions,\n  SubscriptionResult\n} from '../types/types';\nimport { OperationVariables } from '../../core';\nimport { useApolloClient } from './useApolloClient';\n\nexport function useSubscription<TData = any, TVariables = OperationVariables>(\n  subscription: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: SubscriptionHookOptions<TData, TVariables>,\n) {\n  const client = useApolloClient(options?.client);\n  verifyDocumentType(subscription, DocumentType.Subscription);\n  const [result, setResult] = useState<SubscriptionResult<TData>>({\n    loading: !options?.skip,\n    error: void 0,\n    data: void 0,\n    variables: options?.variables,\n  });\n\n  const [observable, setObservable] = useState(() => {\n    if (options?.skip) {\n      return null;\n    }\n\n    return client.subscribe({\n      query: subscription,\n      variables: options?.variables,\n      fetchPolicy: options?.fetchPolicy,\n      context: options?.context,\n    });\n  });\n\n  const ref = useRef({ client, subscription, options });\n  useEffect(() => {\n    let shouldResubscribe = options?.shouldResubscribe;\n    if (typeof shouldResubscribe === 'function') {\n      shouldResubscribe = !!shouldResubscribe(options!);\n    }\n\n    if (options?.skip && !options?.skip !== !ref.current.options?.skip) {\n      setResult({\n        loading: false,\n        data: void 0,\n        error: void 0,\n        variables: options?.variables,\n      });\n      setObservable(null);\n    } else if (\n      shouldResubscribe !== false && (\n        client !== ref.current.client ||\n        subscription !== ref.current.subscription ||\n        options?.fetchPolicy !== ref.current.options?.fetchPolicy ||\n        !options?.skip !== !ref.current.options?.skip ||\n        !equal(options?.variables, ref.current.options?.variables)\n      )\n    ) {\n      setResult({\n        loading: true,\n        data: void 0,\n        error: void 0,\n        variables: options?.variables,\n      });\n      setObservable(client.subscribe({\n        query: subscription,\n        variables: options?.variables,\n        fetchPolicy: options?.fetchPolicy,\n        context: options?.context,\n      }));\n    }\n\n    Object.assign(ref.current, { client, subscription, options });\n  }, [client, subscription, options]);\n\n  useEffect(() => {\n    if (!observable) {\n      return;\n    }\n\n    const subscription = observable.subscribe({\n      next(fetchResult) {\n        const result = {\n          loading: false,\n          // TODO: fetchResult.data can be null but SubscriptionResult.data\n          // expects TData | undefined only\n          data: fetchResult.data!,\n          error: void 0,\n          variables: options?.variables,\n        };\n        setResult(result);\n\n        ref.current.options?.onSubscriptionData?.({\n          client,\n          subscriptionData: result\n        });\n      },\n      error(error) {\n        setResult({\n          loading: false,\n          data: void 0,\n          error,\n          variables: options?.variables,\n        });\n      },\n      complete() {\n        ref.current.options?.onSubscriptionComplete?.();\n      },\n    });\n\n    return () => {\n      subscription.unsubscribe();\n    };\n  }, [observable]);\n\n  return result;\n}\n", "import { useEffect, useState } from 'react';\nimport { ReactiveVar } from '../../core';\n\nexport function useReactiveVar<T>(rv: ReactiveVar<T>): T {\n  const value = rv();\n\n  // We don't actually care what useState thinks the value of the variable\n  // is, so we take only the update function from the returned array.\n  const setValue = useState(value)[1];\n\n  // We subscribe to variable updates on initial mount and when the value has\n  // changed. This avoids a subtle bug in React.StrictMode where multiple\n  // listeners are added, leading to inconsistent updates.\n  useEffect(() => {\n    const probablySameValue = rv();\n    if (value !== probablySameValue) {\n      // If the value of rv has already changed, we don't need to listen for the\n      // next change, because we can report this change immediately.\n      setValue(probablySameValue);\n    } else {\n      return rv.onNextChange(setValue);\n    }\n  }, [value]);\n\n  return value;\n}\n"],
  "mappings": "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",
  "names": ["React", "React", "import_react", "import_react", "DocumentType", "obsQuery", "result", "_a", "_b", "eagerMethods", "key", "_i", "execution", "execute", "import_react", "execute", "_a", "client", "options", "mutation", "import_react", "_a", "_b", "subscription", "result", "import_react"]
}
