{
  "version": 3,
  "sources": ["../../../../../node_modules/@radix-ui/react-id/dist/packages/react/id/src/id.tsx", "../../../../../node_modules/@radix-ui/react-use-direction/dist/packages/react/use-direction/src/useDirection.tsx", "../../../../../node_modules/@radix-ui/react-primitive/dist/packages/react/primitive/src/Primitive.tsx", "../../../../../node_modules/@radix-ui/react-collection/dist/packages/react/collection/src/Collection.tsx", "../../../../../node_modules/@radix-ui/react-roving-focus/dist/packages/react/roving-focus/src/RovingFocusGroup.tsx", "../../../../../node_modules/@radix-ui/react-menu/node_modules/@radix-ui/react-portal/dist/packages/react/portal/src/Portal.tsx", "../../../../../node_modules/@radix-ui/react-arrow/dist/packages/react/arrow/src/Arrow.tsx", "../../../../../node_modules/@radix-ui/react-use-size/dist/packages/react/use-size/src/useSize.tsx", "../../../../../node_modules/@radix-ui/rect/dist/packages/core/rect/src/observeElementRect.ts", "../../../../../node_modules/@radix-ui/react-use-rect/dist/packages/react/use-rect/src/useRect.tsx", "../../../../../node_modules/@radix-ui/popper/dist/packages/core/popper/src/popper.ts", "../../../../../node_modules/@radix-ui/react-popper/dist/packages/react/popper/src/Popper.tsx", "../../../../../node_modules/@radix-ui/react-menu/node_modules/@radix-ui/react-focus-scope/dist/packages/react/focus-scope/src/FocusScope.tsx", "../../../../../node_modules/@radix-ui/react-menu/node_modules/@radix-ui/react-dismissable-layer/dist/packages/react/dismissable-layer/src/DismissableLayer.tsx", "../../../../../node_modules/@radix-ui/react-menu/dist/packages/react/menu/src/Menu.tsx", "../../../../../node_modules/@radix-ui/react-dropdown-menu/dist/packages/react/dropdown-menu/src/DropdownMenu.tsx"],
  "sourcesContent": ["import * as React from 'react';\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\n\n// We `toString()` to prevent bundlers from trying to `import { useId } from 'react';`\nconst useReactId = (React as any)['useId'.toString()] || (() => undefined);\nlet count = 0;\n\nfunction useId(deterministicId?: string): string {\n  const [id, setId] = React.useState<string | undefined>(useReactId());\n  // React versions older than 18 will have client-side ids only.\n  useLayoutEffect(() => {\n    if (!deterministicId) setId((reactId) => reactId ?? String(count++));\n  }, [deterministicId]);\n  return deterministicId || (id ? `radix-${id}` : '');\n}\n\n// DEPRECATED\nfunction IdProvider({ children }: { children: React.ReactNode }) {\n  React.useEffect(() => {\n    console.warn(ID_PROVIDER_DEPRECATED);\n  }, []);\n  return <>{children}</>;\n}\n\nconst ID_PROVIDER_DEPRECATED = `Warning: The \\`IdProvider\\` has been deprecated. For details, see https://radix-ui.com/docs/primitives/utilities/id-provider`;\n\nexport { IdProvider, useId };\n", "import * as React from 'react';\n\ntype Direction = 'ltr' | 'rtl';\n\nexport function useDirection(element: HTMLElement | null, directionProp?: Direction) {\n  const [direction, setDirection] = React.useState<Direction>('ltr');\n  const [computedStyle, setComputedStyle] = React.useState<CSSStyleDeclaration>();\n  const rAFRef = React.useRef<number>(0);\n\n  React.useEffect(() => {\n    // We check inherited direction of the parent instead of the `element` itself.\n    // This is because we internally set the computed `dir` on the element so wouldn't be\n    // able to react to changes to the inherited direction. The `dir` attribute we set should\n    // always sync with the direction prop OR its inherited direction.\n    if (directionProp === undefined && element?.parentElement) {\n      const computedStyle = getComputedStyle(element.parentElement);\n      setComputedStyle(computedStyle);\n    }\n  }, [element, directionProp]);\n\n  React.useEffect(() => {\n    function getDirection() {\n      rAFRef.current = requestAnimationFrame(() => {\n        const dir = computedStyle?.direction as Direction | '' | undefined;\n        if (dir) setDirection(dir);\n        getDirection();\n      });\n    }\n\n    if (directionProp === undefined) getDirection();\n    return () => cancelAnimationFrame(rAFRef.current);\n  }, [computedStyle, directionProp, setDirection]);\n\n  return directionProp || direction;\n}\n", "import * as React from 'react';\nimport { Slot } from '@radix-ui/react-slot';\n\nconst NODES = [\n  'a',\n  'button',\n  'div',\n  'h2',\n  'h3',\n  'img',\n  'li',\n  'nav',\n  'p',\n  'span',\n  'svg',\n  'ul',\n] as const;\n\n// Temporary while we await merge of this fix:\n// https://github.com/DefinitelyTyped/DefinitelyTyped/pull/55396\n// prettier-ignore\ntype PropsWithoutRef<P> = P extends any ? ('ref' extends keyof P ? Pick<P, Exclude<keyof P, 'ref'>> : P) : P;\ntype ComponentPropsWithoutRef<T extends React.ElementType> = PropsWithoutRef<\n  React.ComponentProps<T>\n>;\n\ntype Primitives = { [E in typeof NODES[number]]: PrimitiveForwardRefComponent<E> };\ntype PrimitivePropsWithRef<E extends React.ElementType> = React.ComponentPropsWithRef<E> & {\n  asChild?: boolean;\n};\n\ninterface PrimitiveForwardRefComponent<E extends React.ElementType>\n  extends React.ForwardRefExoticComponent<PrimitivePropsWithRef<E>> {}\n\n/* -------------------------------------------------------------------------------------------------\n * Primitive\n * -----------------------------------------------------------------------------------------------*/\n\nconst Primitive = NODES.reduce(\n  (primitive, node) => ({\n    ...primitive,\n    [node]: React.forwardRef((props: PrimitivePropsWithRef<typeof node>, forwardedRef: any) => {\n      const { asChild, ...primitiveProps } = props;\n      const Comp: any = asChild ? Slot : node;\n\n      React.useEffect(() => {\n        (window as any)[Symbol.for('radix-ui')] = true;\n      }, []);\n\n      // DEPRECATED\n      if ((props as any).as) console.error(AS_ERROR);\n      return <Comp {...primitiveProps} ref={forwardedRef} />;\n    }),\n  }),\n  {} as Primitives\n);\n\n/* -----------------------------------------------------------------------------------------------*/\n\nconst AS_ERROR = `Warning: The \\`as\\` prop has been removed in favour of \\`asChild\\`. For details, see https://radix-ui.com/docs/primitives/overview/styling#changing-the-rendered-element`;\n\nconst Root = Primitive;\n\nexport {\n  Primitive,\n  //\n  Root,\n};\nexport type { ComponentPropsWithoutRef, PrimitivePropsWithRef };\n", "import React from 'react';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { Slot } from '@radix-ui/react-slot';\n\nimport type * as Radix from '@radix-ui/react-primitive';\n\ntype SlotProps = Radix.ComponentPropsWithoutRef<typeof Slot>;\ntype CollectionElement = HTMLElement;\ninterface CollectionProps extends SlotProps {\n  scope: any;\n}\n\n// We have resorted to returning slots directly rather than exposing primitives that can then\n// be slotted like `<CollectionItem as={Slot}>\u2026</CollectionItem>`.\n// This is because we encountered issues with generic types that cannot be statically analysed\n// due to creating them dynamically via createCollection.\n\nfunction createCollection<ItemElement extends HTMLElement, ItemData = {}>(name: string) {\n  /* -----------------------------------------------------------------------------------------------\n   * CollectionProvider\n   * ---------------------------------------------------------------------------------------------*/\n\n  const PROVIDER_NAME = name + 'CollectionProvider';\n  const [createCollectionContext, createCollectionScope] = createContextScope(PROVIDER_NAME);\n\n  type ContextValue = {\n    collectionRef: React.RefObject<CollectionElement>;\n    itemMap: Map<React.RefObject<ItemElement>, { ref: React.RefObject<ItemElement> } & ItemData>;\n  };\n\n  const [CollectionProviderImpl, useCollectionContext] = createCollectionContext<ContextValue>(\n    PROVIDER_NAME,\n    { collectionRef: { current: null }, itemMap: new Map() }\n  );\n\n  const CollectionProvider: React.FC<{ scope: any }> = (props) => {\n    const { scope, children } = props;\n    const ref = React.useRef<CollectionElement>(null);\n    const itemMap = React.useRef<ContextValue['itemMap']>(new Map()).current;\n    return (\n      <CollectionProviderImpl scope={scope} itemMap={itemMap} collectionRef={ref}>\n        {children}\n      </CollectionProviderImpl>\n    );\n  };\n\n  CollectionProvider.displayName = PROVIDER_NAME;\n\n  /* -----------------------------------------------------------------------------------------------\n   * CollectionSlot\n   * ---------------------------------------------------------------------------------------------*/\n\n  const COLLECTION_SLOT_NAME = name + 'CollectionSlot';\n\n  const CollectionSlot = React.forwardRef<CollectionElement, CollectionProps>(\n    (props, forwardedRef) => {\n      const { scope, children } = props;\n      const context = useCollectionContext(COLLECTION_SLOT_NAME, scope);\n      const composedRefs = useComposedRefs(forwardedRef, context.collectionRef);\n      return <Slot ref={composedRefs}>{children}</Slot>;\n    }\n  );\n\n  CollectionSlot.displayName = COLLECTION_SLOT_NAME;\n\n  /* -----------------------------------------------------------------------------------------------\n   * CollectionItem\n   * ---------------------------------------------------------------------------------------------*/\n\n  const ITEM_SLOT_NAME = name + 'CollectionItemSlot';\n  const ITEM_DATA_ATTR = 'data-radix-collection-item';\n\n  type CollectionItemSlotProps = ItemData & {\n    children: React.ReactNode;\n    scope: any;\n  };\n\n  const CollectionItemSlot = React.forwardRef<ItemElement, CollectionItemSlotProps>(\n    (props, forwardedRef) => {\n      const { scope, children, ...itemData } = props;\n      const ref = React.useRef<ItemElement>(null);\n      const composedRefs = useComposedRefs(forwardedRef, ref);\n      const context = useCollectionContext(ITEM_SLOT_NAME, scope);\n\n      React.useEffect(() => {\n        context.itemMap.set(ref, { ref, ...(itemData as unknown as ItemData) });\n        return () => void context.itemMap.delete(ref);\n      });\n\n      return (\n        <Slot {...{ [ITEM_DATA_ATTR]: '' }} ref={composedRefs}>\n          {children}\n        </Slot>\n      );\n    }\n  );\n\n  CollectionItemSlot.displayName = ITEM_SLOT_NAME;\n\n  /* -----------------------------------------------------------------------------------------------\n   * useCollection\n   * ---------------------------------------------------------------------------------------------*/\n\n  function useCollection(scope: any) {\n    const context = useCollectionContext(name + 'CollectionConsumer', scope);\n\n    const getItems = React.useCallback(() => {\n      const collectionNode = context.collectionRef.current;\n      if (!collectionNode) return [];\n      const orderedNodes = Array.from(collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`));\n      const items = Array.from(context.itemMap.values());\n      const orderedItems = items.sort(\n        (a, b) => orderedNodes.indexOf(a.ref.current!) - orderedNodes.indexOf(b.ref.current!)\n      );\n      return orderedItems;\n    }, [context.collectionRef, context.itemMap]);\n\n    return getItems;\n  }\n\n  return [\n    { Provider: CollectionProvider, Slot: CollectionSlot, ItemSlot: CollectionItemSlot },\n    useCollection,\n    createCollectionScope,\n  ] as const;\n}\n\nexport { createCollection };\nexport type { CollectionProps };\n", "import * as React from 'react';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { createCollection } from '@radix-ui/react-collection';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { useId } from '@radix-ui/react-id';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\n\nimport type * as Radix from '@radix-ui/react-primitive';\nimport type { Scope } from '@radix-ui/react-context';\n\nconst ENTRY_FOCUS = 'rovingFocusGroup.onEntryFocus';\nconst EVENT_OPTIONS = { bubbles: false, cancelable: true };\n\n/* -------------------------------------------------------------------------------------------------\n * RovingFocusGroup\n * -----------------------------------------------------------------------------------------------*/\n\nconst GROUP_NAME = 'RovingFocusGroup';\n\ntype ItemData = { id: string; focusable: boolean; active: boolean };\nconst [Collection, useCollection, createCollectionScope] = createCollection<\n  HTMLSpanElement,\n  ItemData\n>(GROUP_NAME);\n\ntype ScopedProps<P> = P & { __scopeRovingFocusGroup?: Scope };\nconst [createRovingFocusGroupContext, createRovingFocusGroupScope] = createContextScope(\n  GROUP_NAME,\n  [createCollectionScope]\n);\n\ntype Orientation = React.AriaAttributes['aria-orientation'];\ntype Direction = 'ltr' | 'rtl';\n\ninterface RovingFocusGroupOptions {\n  /**\n   * The orientation of the group.\n   * Mainly so arrow navigation is done accordingly (left & right vs. up & down)\n   */\n  orientation?: Orientation;\n  /**\n   * The direction of navigation between items.\n   * @defaultValue ltr\n   */\n  dir?: Direction;\n  /**\n   * Whether keyboard navigation should loop around\n   * @defaultValue false\n   */\n  loop?: boolean;\n}\n\ntype RovingContextValue = RovingFocusGroupOptions & {\n  currentTabStopId: string | null;\n  onItemFocus(tabStopId: string): void;\n  onItemShiftTab(): void;\n};\n\nconst [RovingFocusProvider, useRovingFocusContext] =\n  createRovingFocusGroupContext<RovingContextValue>(GROUP_NAME);\n\ntype RovingFocusGroupElement = RovingFocusGroupImplElement;\ninterface RovingFocusGroupProps extends RovingFocusGroupImplProps {}\n\nconst RovingFocusGroup = React.forwardRef<RovingFocusGroupElement, RovingFocusGroupProps>(\n  (props: ScopedProps<RovingFocusGroupProps>, forwardedRef) => {\n    return (\n      <Collection.Provider scope={props.__scopeRovingFocusGroup}>\n        <Collection.Slot scope={props.__scopeRovingFocusGroup}>\n          <RovingFocusGroupImpl {...props} ref={forwardedRef} />\n        </Collection.Slot>\n      </Collection.Provider>\n    );\n  }\n);\n\nRovingFocusGroup.displayName = GROUP_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\ntype RovingFocusGroupImplElement = React.ElementRef<typeof Primitive.div>;\ntype PrimitiveDivProps = Radix.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface RovingFocusGroupImplProps\n  extends Omit<PrimitiveDivProps, 'dir'>,\n    RovingFocusGroupOptions {\n  currentTabStopId?: string | null;\n  defaultCurrentTabStopId?: string;\n  onCurrentTabStopIdChange?: (tabStopId: string | null) => void;\n  onEntryFocus?: (event: Event) => void;\n}\n\nconst RovingFocusGroupImpl = React.forwardRef<\n  RovingFocusGroupImplElement,\n  RovingFocusGroupImplProps\n>((props: ScopedProps<RovingFocusGroupImplProps>, forwardedRef) => {\n  const {\n    __scopeRovingFocusGroup,\n    orientation,\n    dir = 'ltr',\n    loop = false,\n    currentTabStopId: currentTabStopIdProp,\n    defaultCurrentTabStopId,\n    onCurrentTabStopIdChange,\n    onEntryFocus,\n    ...groupProps\n  } = props;\n  const ref = React.useRef<RovingFocusGroupImplElement>(null);\n  const composedRefs = useComposedRefs(forwardedRef, ref);\n  const [currentTabStopId = null, setCurrentTabStopId] = useControllableState({\n    prop: currentTabStopIdProp,\n    defaultProp: defaultCurrentTabStopId,\n    onChange: onCurrentTabStopIdChange,\n  });\n  const [isTabbingBackOut, setIsTabbingBackOut] = React.useState(false);\n  const handleEntryFocus = useCallbackRef(onEntryFocus);\n  const getItems = useCollection(__scopeRovingFocusGroup);\n  const isClickFocusRef = React.useRef(false);\n\n  React.useEffect(() => {\n    const node = ref.current;\n    if (node) {\n      node.addEventListener(ENTRY_FOCUS, handleEntryFocus);\n      return () => node.removeEventListener(ENTRY_FOCUS, handleEntryFocus);\n    }\n  }, [handleEntryFocus]);\n\n  return (\n    <RovingFocusProvider\n      scope={__scopeRovingFocusGroup}\n      orientation={orientation}\n      dir={dir}\n      loop={loop}\n      currentTabStopId={currentTabStopId}\n      onItemFocus={React.useCallback(\n        (tabStopId) => setCurrentTabStopId(tabStopId),\n        [setCurrentTabStopId]\n      )}\n      onItemShiftTab={React.useCallback(() => setIsTabbingBackOut(true), [])}\n    >\n      <Primitive.div\n        tabIndex={isTabbingBackOut ? -1 : 0}\n        data-orientation={orientation}\n        {...groupProps}\n        ref={composedRefs}\n        style={{ outline: 'none', ...props.style }}\n        onMouseDown={composeEventHandlers(props.onMouseDown, () => {\n          isClickFocusRef.current = true;\n        })}\n        onFocus={composeEventHandlers(props.onFocus, (event) => {\n          // We normally wouldn't need this check, because we already check\n          // that the focus is on the current target and not bubbling to it.\n          // We do this because Safari doesn't focus buttons when clicked, and\n          // instead, the wrapper will get focused and not through a bubbling event.\n          const isKeyboardFocus = !isClickFocusRef.current;\n\n          if (event.target === event.currentTarget && isKeyboardFocus && !isTabbingBackOut) {\n            const entryFocusEvent = new Event(ENTRY_FOCUS, EVENT_OPTIONS);\n            event.currentTarget.dispatchEvent(entryFocusEvent);\n\n            if (!entryFocusEvent.defaultPrevented) {\n              const items = getItems().filter((item) => item.focusable);\n              const activeItem = items.find((item) => item.active);\n              const currentItem = items.find((item) => item.id === currentTabStopId);\n              const candidateItems = [activeItem, currentItem, ...items].filter(\n                Boolean\n              ) as typeof items;\n              const candidateNodes = candidateItems.map((item) => item.ref.current!);\n              focusFirst(candidateNodes);\n            }\n          }\n\n          isClickFocusRef.current = false;\n        })}\n        onBlur={composeEventHandlers(props.onBlur, () => setIsTabbingBackOut(false))}\n      />\n    </RovingFocusProvider>\n  );\n});\n\n/* -------------------------------------------------------------------------------------------------\n * RovingFocusGroupItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst ITEM_NAME = 'RovingFocusGroupItem';\n\ntype RovingFocusItemElement = React.ElementRef<typeof Primitive.span>;\ntype PrimitiveSpanProps = Radix.ComponentPropsWithoutRef<typeof Primitive.span>;\ninterface RovingFocusItemProps extends PrimitiveSpanProps {\n  focusable?: boolean;\n  active?: boolean;\n}\n\nconst RovingFocusGroupItem = React.forwardRef<RovingFocusItemElement, RovingFocusItemProps>(\n  (props: ScopedProps<RovingFocusItemProps>, forwardedRef) => {\n    const { __scopeRovingFocusGroup, focusable = true, active = false, ...itemProps } = props;\n    const id = useId();\n    const context = useRovingFocusContext(ITEM_NAME, __scopeRovingFocusGroup);\n    const isCurrentTabStop = context.currentTabStopId === id;\n    const getItems = useCollection(__scopeRovingFocusGroup);\n\n    return (\n      <Collection.ItemSlot\n        scope={__scopeRovingFocusGroup}\n        id={id}\n        focusable={focusable}\n        active={active}\n      >\n        <Primitive.span\n          tabIndex={isCurrentTabStop ? 0 : -1}\n          data-orientation={context.orientation}\n          {...itemProps}\n          ref={forwardedRef}\n          onMouseDown={composeEventHandlers(props.onMouseDown, (event) => {\n            // We prevent focusing non-focusable items on `mousedown`.\n            // Even though the item has tabIndex={-1}, that only means take it out of the tab order.\n            if (!focusable) event.preventDefault();\n            // Safari doesn't focus a button when clicked so we run our logic on mousedown also\n            else context.onItemFocus(id);\n          })}\n          onFocus={composeEventHandlers(props.onFocus, () => context.onItemFocus(id))}\n          onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n            if (event.key === 'Tab' && event.shiftKey) {\n              context.onItemShiftTab();\n              return;\n            }\n\n            if (event.target !== event.currentTarget) return;\n\n            const focusIntent = getFocusIntent(event, context.orientation, context.dir);\n\n            if (focusIntent !== undefined) {\n              event.preventDefault();\n              const items = getItems().filter((item) => item.focusable);\n              let candidateNodes = items.map((item) => item.ref.current!);\n\n              if (focusIntent === 'last') candidateNodes.reverse();\n              else if (focusIntent === 'prev' || focusIntent === 'next') {\n                if (focusIntent === 'prev') candidateNodes.reverse();\n                const currentIndex = candidateNodes.indexOf(event.currentTarget);\n                candidateNodes = context.loop\n                  ? wrapArray(candidateNodes, currentIndex + 1)\n                  : candidateNodes.slice(currentIndex + 1);\n              }\n\n              /**\n               * Imperative focus during keydown is risky so we prevent React's batching updates\n               * to avoid potential bugs. See: https://github.com/facebook/react/issues/20332\n               */\n              setTimeout(() => focusFirst(candidateNodes));\n            }\n          })}\n        />\n      </Collection.ItemSlot>\n    );\n  }\n);\n\nRovingFocusGroupItem.displayName = ITEM_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\n// prettier-ignore\nconst MAP_KEY_TO_FOCUS_INTENT: Record<string, FocusIntent> = {\n  ArrowLeft: 'prev', ArrowUp: 'prev',\n  ArrowRight: 'next', ArrowDown: 'next',\n  PageUp: 'first', Home: 'first',\n  PageDown: 'last', End: 'last',\n};\n\nfunction getDirectionAwareKey(key: string, dir?: Direction) {\n  if (dir !== 'rtl') return key;\n  return key === 'ArrowLeft' ? 'ArrowRight' : key === 'ArrowRight' ? 'ArrowLeft' : key;\n}\n\ntype FocusIntent = 'first' | 'last' | 'prev' | 'next';\n\nfunction getFocusIntent(event: React.KeyboardEvent, orientation?: Orientation, dir?: Direction) {\n  const key = getDirectionAwareKey(event.key, dir);\n  if (orientation === 'vertical' && ['ArrowLeft', 'ArrowRight'].includes(key)) return undefined;\n  if (orientation === 'horizontal' && ['ArrowUp', 'ArrowDown'].includes(key)) return undefined;\n  return MAP_KEY_TO_FOCUS_INTENT[key];\n}\n\nfunction focusFirst(candidates: HTMLElement[]) {\n  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;\n  for (const candidate of candidates) {\n    // if focus is already where we want to go, we don't want to keep going through the candidates\n    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;\n    candidate.focus();\n    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;\n  }\n}\n\n/**\n * Wraps an array around itself at a given start index\n * Example: `wrapArray(['a', 'b', 'c', 'd'], 2) === ['c', 'd', 'a', 'b']`\n */\nfunction wrapArray<T>(array: T[], startIndex: number) {\n  return array.map((_, index) => array[(startIndex + index) % array.length]);\n}\n\nconst Root = RovingFocusGroup;\nconst Item = RovingFocusGroupItem;\n\nexport {\n  createRovingFocusGroupScope,\n  //\n  RovingFocusGroup,\n  RovingFocusGroupItem,\n  //\n  Root,\n  Item,\n};\nexport type { RovingFocusGroupProps, RovingFocusItemProps };\n", "import * as React from 'react';\nimport ReactDOM from 'react-dom';\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\nimport { Primitive } from '@radix-ui/react-primitive';\n\nimport type * as Radix from '@radix-ui/react-primitive';\n\nconst MAX_Z_INDEX = 2147483647;\n\n/* -------------------------------------------------------------------------------------------------\n * Portal\n * -----------------------------------------------------------------------------------------------*/\n\nconst PORTAL_NAME = 'Portal';\n\ntype PortalElement = React.ElementRef<typeof Primitive.div>;\ntype PrimitiveDivProps = Radix.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface PortalProps extends PrimitiveDivProps {\n  containerRef?: React.RefObject<HTMLElement>;\n}\n\nconst Portal = React.forwardRef<PortalElement, PortalProps>((props, forwardedRef) => {\n  const { containerRef, style, ...portalProps } = props;\n  const hostElement = containerRef?.current ?? globalThis?.document?.body;\n  const [, forceUpdate] = React.useState({});\n\n  /**\n   * containerRef.current won't be set on first render, so we force a re-render.\n   * Because we do this in `useLayoutEffect`, we still avoid a flash.\n   */\n  useLayoutEffect(() => {\n    forceUpdate({});\n  }, []);\n\n  if (hostElement) {\n    return ReactDOM.createPortal(\n      <Primitive.div\n        data-radix-portal=\"\"\n        {...portalProps}\n        ref={forwardedRef}\n        style={\n          /**\n           * If the Portal is injected in `body`, we assume we want whatever is portalled\n           * to appear on top of everything. Ideally this would be handled by making sure the\n           * app root creates a new stacking context, however this is quite hard to automate.\n           * For this reason, we have opted for setting the max z-index on the portal itself.\n           */\n          hostElement === document.body\n            ? {\n                position: 'absolute',\n                top: 0,\n                left: 0,\n                zIndex: MAX_Z_INDEX,\n                ...style,\n              }\n            : undefined\n        }\n      />,\n      hostElement\n    );\n  }\n\n  // bail out of ssr\n  return null;\n});\n\nPortal.displayName = PORTAL_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * UnstablePortal\n * -----------------------------------------------------------------------------------------------*/\n\nconst UNSTABLE_PORTAL_NAME = 'Portal';\n\ntype UnstablePortalElement = React.ElementRef<typeof Primitive.div>;\ninterface UnstablePortalProps extends PrimitiveDivProps {\n  container?: HTMLElement | null;\n}\n\nconst UnstablePortal = React.forwardRef<UnstablePortalElement, UnstablePortalProps>(\n  (props, forwardedRef) => {\n    const { container = globalThis?.document?.body, ...portalProps } = props;\n    return container\n      ? ReactDOM.createPortal(<Primitive.div {...portalProps} ref={forwardedRef} />, container)\n      : null;\n  }\n);\n\nUnstablePortal.displayName = UNSTABLE_PORTAL_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\nconst Root = Portal;\n\nexport {\n  Portal,\n  UnstablePortal,\n  //\n  Root,\n};\nexport type { PortalProps, UnstablePortalProps };\n", "import * as React from 'react';\nimport { Primitive } from '@radix-ui/react-primitive';\n\nimport type * as Radix from '@radix-ui/react-primitive';\n\n/* -------------------------------------------------------------------------------------------------\n * Arrow\n * -----------------------------------------------------------------------------------------------*/\n\nconst NAME = 'Arrow';\n\ntype ArrowElement = React.ElementRef<typeof Primitive.svg>;\ntype PrimitiveSvgProps = Radix.ComponentPropsWithoutRef<typeof Primitive.svg>;\ninterface ArrowProps extends PrimitiveSvgProps {}\n\nconst Arrow = React.forwardRef<ArrowElement, ArrowProps>((props, forwardedRef) => {\n  const { children, width = 10, height = 5, ...arrowProps } = props;\n  return (\n    <Primitive.svg\n      {...arrowProps}\n      ref={forwardedRef}\n      width={width}\n      height={height}\n      viewBox=\"0 0 30 10\"\n      preserveAspectRatio=\"none\"\n    >\n      {/* We use their children if they're slotting to replace the whole svg */}\n      {props.asChild ? children : <polygon points=\"0,0 30,0 15,10\" />}\n    </Primitive.svg>\n  );\n});\n\nArrow.displayName = NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\nconst Root = Arrow;\n\nexport {\n  Arrow,\n  //\n  Root,\n};\nexport type { ArrowProps };\n", "/// <reference types=\"resize-observer-browser\" />\n\nimport * as React from 'react';\n\nfunction useSize(element: HTMLElement | SVGElement | null) {\n  const [size, setSize] = React.useState<{ width: number; height: number } | undefined>(undefined);\n\n  React.useEffect(() => {\n    if (element) {\n      const resizeObserver = new ResizeObserver((entries) => {\n        if (!Array.isArray(entries)) {\n          return;\n        }\n\n        // Since we only observe the one element, we don't need to loop over the\n        // array\n        if (!entries.length) {\n          return;\n        }\n\n        const entry = entries[0];\n        let width: number;\n        let height: number;\n\n        if ('borderBoxSize' in entry) {\n          const borderSizeEntry = entry['borderBoxSize'];\n          // iron out differences between browsers\n          const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;\n          width = borderSize['inlineSize'];\n          height = borderSize['blockSize'];\n        } else {\n          // for browsers that don't support `borderBoxSize`\n          // we calculate a rect ourselves to get the correct border box.\n          const rect = element.getBoundingClientRect();\n          width = rect.width;\n          height = rect.height;\n        }\n\n        setSize({ width, height });\n      });\n\n      resizeObserver.observe(element, { box: 'border-box' });\n\n      return () => {\n        setSize(undefined);\n        resizeObserver.unobserve(element);\n      };\n    }\n    return;\n  }, [element]);\n\n  return size;\n}\n\nexport { useSize };\n", "type Measurable = { getBoundingClientRect(): ClientRect };\n\n/**\n * Observes an element's rectangle on screen (getBoundingClientRect)\n * This is useful to track elements on the screen and attach other elements\n * that might be in different layers, etc.\n */\nfunction observeElementRect(\n  /** The element whose rect to observe */\n  elementToObserve: Measurable,\n  /** The callback which will be called when the rect changes */\n  callback: CallbackFn\n) {\n  const observedData = observedElements.get(elementToObserve);\n\n  if (observedData === undefined) {\n    // add the element to the map of observed elements with its first callback\n    // because this is the first time this element is observed\n    observedElements.set(elementToObserve, { rect: {} as ClientRect, callbacks: [callback] });\n\n    if (observedElements.size === 1) {\n      // start the internal loop once at least 1 element is observed\n      rafId = requestAnimationFrame(runLoop);\n    }\n  } else {\n    // only add a callback for this element as it's already observed\n    observedData.callbacks.push(callback);\n    callback(elementToObserve.getBoundingClientRect());\n  }\n\n  return () => {\n    const observedData = observedElements.get(elementToObserve);\n    if (observedData === undefined) return;\n\n    // start by removing the callback\n    const index = observedData.callbacks.indexOf(callback);\n    if (index > -1) {\n      observedData.callbacks.splice(index, 1);\n    }\n\n    if (observedData.callbacks.length === 0) {\n      // stop observing this element because there are no\n      // callbacks registered for it anymore\n      observedElements.delete(elementToObserve);\n\n      if (observedElements.size === 0) {\n        // stop the internal loop once no elements are observed anymore\n        cancelAnimationFrame(rafId);\n      }\n    }\n  };\n}\n\n// ========================================================================\n// module internals\n\ntype CallbackFn = (rect: ClientRect) => void;\n\ntype ObservedData = {\n  rect: ClientRect;\n  callbacks: Array<CallbackFn>;\n};\n\nlet rafId: number;\nconst observedElements: Map<Measurable, ObservedData> = new Map();\n\nfunction runLoop() {\n  const changedRectsData: Array<ObservedData> = [];\n\n  // process all DOM reads first (getBoundingClientRect)\n  observedElements.forEach((data, element) => {\n    const newRect = element.getBoundingClientRect();\n\n    // gather all the data for elements whose rects have changed\n    if (!rectEquals(data.rect, newRect)) {\n      data.rect = newRect;\n      changedRectsData.push(data);\n    }\n  });\n\n  // group DOM writes here after the DOM reads (getBoundingClientRect)\n  // as DOM writes will most likely happen with the callbacks\n  changedRectsData.forEach((data) => {\n    data.callbacks.forEach((callback) => callback(data.rect));\n  });\n\n  rafId = requestAnimationFrame(runLoop);\n}\n// ========================================================================\n\n/**\n * Returns whether 2 rects are equal in values\n */\nfunction rectEquals(rect1: ClientRect, rect2: ClientRect) {\n  return (\n    rect1.width === rect2.width &&\n    rect1.height === rect2.height &&\n    rect1.top === rect2.top &&\n    rect1.right === rect2.right &&\n    rect1.bottom === rect2.bottom &&\n    rect1.left === rect2.left\n  );\n}\n\nexport { observeElementRect };\nexport type { Measurable };\n", "import * as React from 'react';\nimport { observeElementRect } from '@radix-ui/rect';\n\nimport type { Measurable } from '@radix-ui/rect';\n\n/**\n * Use this custom hook to get access to an element's rect (getBoundingClientRect)\n * and observe it along time.\n */\nfunction useRect(measurable: Measurable | null) {\n  const [rect, setRect] = React.useState<ClientRect>();\n  React.useEffect(() => {\n    if (measurable) {\n      const unobserve = observeElementRect(measurable, setRect);\n      return () => {\n        setRect(undefined);\n        unobserve();\n      };\n    }\n    return;\n  }, [measurable]);\n  return rect;\n}\n\nexport { useRect };\n", "import * as CSS from 'csstype';\n\nconst SIDE_OPTIONS = ['top', 'right', 'bottom', 'left'] as const;\nconst ALIGN_OPTIONS = ['start', 'center', 'end'] as const;\n\ntype Axis = 'x' | 'y';\ntype Side = typeof SIDE_OPTIONS[number];\ntype Align = typeof ALIGN_OPTIONS[number];\ntype Point = { x: number; y: number };\ntype Size = { width: number; height: number };\n\ntype GetPlacementDataOptions = {\n  /** The rect of the anchor we are placing around */\n  anchorRect?: ClientRect;\n  /** The size of the popper to place */\n  popperSize?: Size;\n  /** An optional arrow size */\n  arrowSize?: Size;\n  /** An optional arrow offset (along the side, default: 0) */\n  arrowOffset?: number;\n  /** The desired side */\n  side: Side;\n  /** An optional side offset (distance from the side, default: 0)  */\n  sideOffset?: number;\n  /** The desired alignment */\n  align: Align;\n  /** An optional alignment offset (distance along the side, default: 0) */\n  alignOffset?: number;\n  /** An option to turn on/off the collision handling (default: true) */\n  shouldAvoidCollisions?: boolean;\n  /** The rect which represents the boundaries for collision checks */\n  collisionBoundariesRect?: ClientRect;\n  /** The tolerance used for collisions, ie. if we want them to trigger a bit earlier (default: 0) */\n  collisionTolerance?: number;\n};\n\ntype PlacementData = {\n  popperStyles: CSS.Properties;\n  arrowStyles: CSS.Properties;\n  placedSide?: Side;\n  placedAlign?: Align;\n};\n\n/**\n * Given all the information necessary to compute it,\n * this function calculates all the necessary placement data.\n *\n * It will return:\n *\n * - the styles to apply to the popper (including a custom property that is useful to set the transform origin in the right place)\n * - the styles to apply to the arrow\n * - the placed side (because it might have changed because of collisions)\n * - the placed align (because it might have changed because of collisions)\n */\nfunction getPlacementData({\n  anchorRect,\n  popperSize,\n  arrowSize,\n  arrowOffset = 0,\n  side,\n  sideOffset = 0,\n  align,\n  alignOffset = 0,\n  shouldAvoidCollisions = true,\n  collisionBoundariesRect,\n  collisionTolerance = 0,\n}: GetPlacementDataOptions): PlacementData {\n  // if we're not ready to do all the measurements yet,\n  // we return some good default styles\n  if (!anchorRect || !popperSize || !collisionBoundariesRect) {\n    return {\n      popperStyles: UNMEASURED_POPPER_STYLES,\n      arrowStyles: UNMEASURED_ARROW_STYLES,\n    };\n  }\n\n  // pre-compute points for all potential placements\n  const allPlacementPoints = getAllPlacementPoints(\n    popperSize,\n    anchorRect,\n    sideOffset,\n    alignOffset,\n    arrowSize\n  );\n\n  // get point based on side / align\n  const popperPoint = allPlacementPoints[side][align];\n\n  // if we don't need to avoid collisions, we can stop here\n  if (shouldAvoidCollisions === false) {\n    const popperStyles = getPlacementStylesForPoint(popperPoint);\n\n    let arrowStyles = UNMEASURED_ARROW_STYLES;\n    if (arrowSize) {\n      arrowStyles = getPopperArrowStyles({ popperSize, arrowSize, arrowOffset, side, align });\n    }\n\n    const transformOrigin = getTransformOrigin(popperSize, side, align, arrowOffset, arrowSize);\n\n    return {\n      popperStyles: {\n        ...popperStyles,\n        ['--radix-popper-transform-origin' as any]: transformOrigin,\n      },\n      arrowStyles,\n      placedSide: side,\n      placedAlign: align,\n    };\n  }\n\n  // create a new rect as if element had been moved to new placement\n  const popperRect = DOMRect.fromRect({ ...popperSize, ...popperPoint });\n\n  // create a new rect representing the collision boundaries but taking into account any added tolerance\n  const collisionBoundariesRectWithTolerance = getContractedRect(\n    collisionBoundariesRect,\n    collisionTolerance\n  );\n\n  // check for any collisions in new placement\n  const popperCollisions = getCollisions(popperRect, collisionBoundariesRectWithTolerance);\n\n  // do all the same calculations for the opposite side\n  // this is because we need to check for potential collisions if we were to swap side\n  const oppositeSide = getOppositeSide(side);\n  const oppositeSidePopperPoint = allPlacementPoints[oppositeSide][align];\n  const updatedOppositeSidePopperPoint = DOMRect.fromRect({\n    ...popperSize,\n    ...oppositeSidePopperPoint,\n  });\n  const oppositeSidePopperCollisions = getCollisions(\n    updatedOppositeSidePopperPoint,\n    collisionBoundariesRectWithTolerance\n  );\n\n  // adjust side accounting for collisions / opposite side collisions\n  const placedSide = getSideAccountingForCollisions(\n    side,\n    popperCollisions,\n    oppositeSidePopperCollisions\n  );\n\n  // adjust alignnment accounting for collisions\n  const placedAlign = getAlignAccountingForCollisions(\n    popperSize,\n    anchorRect,\n    side,\n    align,\n    popperCollisions\n  );\n\n  const placedPopperPoint = allPlacementPoints[placedSide][placedAlign];\n\n  // compute adjusted popper / arrow styles\n  const popperStyles = getPlacementStylesForPoint(placedPopperPoint);\n\n  let arrowStyles = UNMEASURED_ARROW_STYLES;\n  if (arrowSize) {\n    arrowStyles = getPopperArrowStyles({\n      popperSize,\n      arrowSize,\n      arrowOffset,\n      side: placedSide,\n      align: placedAlign,\n    });\n  }\n\n  const transformOrigin = getTransformOrigin(\n    popperSize,\n    placedSide,\n    placedAlign,\n    arrowOffset,\n    arrowSize\n  );\n\n  return {\n    popperStyles: {\n      ...popperStyles,\n      ['--radix-popper-transform-origin' as any]: transformOrigin,\n    },\n    arrowStyles,\n    placedSide,\n    placedAlign,\n  };\n}\n\ntype AllPlacementPoints = Record<Side, Record<Align, Point>>;\n\nfunction getAllPlacementPoints(\n  popperSize: Size,\n  anchorRect: ClientRect,\n  sideOffset: number = 0,\n  alignOffset: number = 0,\n  arrowSize?: Size\n): AllPlacementPoints {\n  const arrowBaseToTipLength = arrowSize ? arrowSize.height : 0;\n\n  const x = getPopperSlotsForAxis(anchorRect, popperSize, 'x');\n  const y = getPopperSlotsForAxis(anchorRect, popperSize, 'y');\n\n  const topY    = y.before - sideOffset - arrowBaseToTipLength; // prettier-ignore\n  const bottomY = y.after  + sideOffset + arrowBaseToTipLength; // prettier-ignore\n  const leftX   = x.before - sideOffset - arrowBaseToTipLength; // prettier-ignore\n  const rightX  = x.after  + sideOffset + arrowBaseToTipLength; // prettier-ignore\n\n  // prettier-ignore\n  const map: AllPlacementPoints = {\n    top: {\n      start:  { x: x.start + alignOffset, y: topY },\n      center: { x: x.center,              y: topY },\n      end:    { x: x.end - alignOffset,   y: topY },\n    },\n    right: {\n      start:  { x: rightX, y: y.start + alignOffset },\n      center: { x: rightX, y: y.center },\n      end:    { x: rightX, y: y.end - alignOffset },\n    },\n    bottom: {\n      start:  { x: x.start + alignOffset, y: bottomY },\n      center: { x: x.center,              y: bottomY },\n      end:    { x: x.end - alignOffset,   y: bottomY },\n    },\n    left: {\n      start:  { x: leftX, y: y.start + alignOffset },\n      center: { x: leftX, y: y.center },\n      end:    { x: leftX, y: y.end - alignOffset },\n    },\n  };\n\n  return map;\n}\n\nfunction getPopperSlotsForAxis(anchorRect: ClientRect, popperSize: Size, axis: Axis) {\n  const startSide = axis === 'x' ? 'left' : 'top';\n  const anchorStart = anchorRect[startSide];\n\n  const dimension = axis === 'x' ? 'width' : 'height';\n  const anchorDimension = anchorRect[dimension];\n  const popperDimension = popperSize[dimension];\n\n  // prettier-ignore\n  return {\n    before: anchorStart - popperDimension,\n    start:  anchorStart,\n    center: anchorStart + (anchorDimension - popperDimension) / 2,\n    end:    anchorStart + anchorDimension - popperDimension,\n    after:  anchorStart + anchorDimension,\n  };\n}\n\n/**\n * Gets an adjusted side based on collision information\n */\nfunction getSideAccountingForCollisions(\n  /** The side we want to ideally position to */\n  side: Side,\n  /** The collisions for this given side */\n  collisions: Collisions,\n  /** The collisions for the opposite side (if we were to swap side) */\n  oppositeSideCollisions: Collisions\n): Side {\n  const oppositeSide = getOppositeSide(side);\n  // in order to prevent premature jumps\n  // we only swap side if there's enough space to fit on the opposite side\n  return collisions[side] && !oppositeSideCollisions[oppositeSide] ? oppositeSide : side;\n}\n\n/**\n * Gets an adjusted alignment based on collision information\n */\nfunction getAlignAccountingForCollisions(\n  /** The size of the popper to place */\n  popperSize: Size,\n  /** The size of the anchor we are placing around */\n  anchorSize: Size,\n  /** The final side */\n  side: Side,\n  /** The desired align */\n  align: Align,\n  /** The collisions */\n  collisions: Collisions\n): Align {\n  const isHorizontalSide = side === 'top' || side === 'bottom';\n  const startBound = isHorizontalSide ? 'left' : 'top';\n  const endBound = isHorizontalSide ? 'right' : 'bottom';\n  const dimension = isHorizontalSide ? 'width' : 'height';\n  const isAnchorBigger = anchorSize[dimension] > popperSize[dimension];\n\n  if (align === 'start' || align === 'center') {\n    if ((collisions[startBound] && isAnchorBigger) || (collisions[endBound] && !isAnchorBigger)) {\n      return 'end';\n    }\n  }\n\n  if (align === 'end' || align === 'center') {\n    if ((collisions[endBound] && isAnchorBigger) || (collisions[startBound] && !isAnchorBigger)) {\n      return 'start';\n    }\n  }\n\n  return align;\n}\n\nfunction getPlacementStylesForPoint(point: Point): CSS.Properties {\n  const x = Math.round(point.x + window.scrollX);\n  const y = Math.round(point.y + window.scrollY);\n  return {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    minWidth: 'max-content',\n    willChange: 'transform',\n    transform: `translate3d(${x}px, ${y}px, 0)`,\n  };\n}\n\nfunction getTransformOrigin(\n  popperSize: Size,\n  side: Side,\n  align: Align,\n  arrowOffset: number,\n  arrowSize?: Size\n): CSS.Properties['transformOrigin'] {\n  const isHorizontalSide = side === 'top' || side === 'bottom';\n\n  const arrowBaseLength = arrowSize ? arrowSize.width : 0;\n  const arrowBaseToTipLength = arrowSize ? arrowSize.height : 0;\n  const sideOffset = arrowBaseToTipLength;\n  const alignOffset = arrowBaseLength / 2 + arrowOffset;\n\n  let x = '';\n  let y = '';\n\n  if (isHorizontalSide) {\n    x = {\n      start: `${alignOffset}px`,\n      center: 'center',\n      end: `${popperSize.width - alignOffset}px`,\n    }[align];\n\n    y = side === 'top' ? `${popperSize.height + sideOffset}px` : `${-sideOffset}px`;\n  } else {\n    x = side === 'left' ? `${popperSize.width + sideOffset}px` : `${-sideOffset}px`;\n\n    y = {\n      start: `${alignOffset}px`,\n      center: 'center',\n      end: `${popperSize.height - alignOffset}px`,\n    }[align];\n  }\n\n  return `${x} ${y}`;\n}\n\nconst UNMEASURED_POPPER_STYLES: CSS.Properties = {\n  // position: 'fixed' here is important because it will take the popper\n  // out of the flow so it does not disturb the position of the anchor\n  position: 'fixed',\n  top: 0,\n  left: 0,\n  opacity: 0,\n  transform: 'translate3d(0, -200%, 0)',\n};\n\nconst UNMEASURED_ARROW_STYLES: CSS.Properties = {\n  // given the arrow is nested inside the popper,\n  // make sure that it is out of the flow and doesn't hinder then popper's measurement\n  position: 'absolute',\n  opacity: 0,\n};\n\ntype GetArrowStylesOptions = {\n  /** The size of the popper to place */\n  popperSize: Size;\n  /** The size of the arrow itself */\n  arrowSize: Size;\n  /** An offset for the arrow along the align axis */\n  arrowOffset: number;\n  /** The side where the arrow points to */\n  side: Side;\n  /** The alignment of the arrow along the side */\n  align: Align;\n};\n\n/**\n * Computes the styles necessary to position, rotate and align the arrow correctly.\n * It can adjust itself based on anchor/popper size, side/align and an optional offset.\n */\nfunction getPopperArrowStyles({\n  popperSize,\n  arrowSize,\n  arrowOffset,\n  side,\n  align,\n}: GetArrowStylesOptions): CSS.Properties {\n  const popperCenterX = (popperSize.width - arrowSize.width) / 2;\n  const popperCenterY = (popperSize.height - arrowSize.width) / 2;\n\n  const rotationMap = { top: 0, right: 90, bottom: 180, left: -90 };\n  const rotation = rotationMap[side];\n  const arrowMaxDimension = Math.max(arrowSize.width, arrowSize.height);\n\n  const styles: CSS.Properties = {\n    // we make sure we put the arrow inside a 1:1 ratio container\n    // this is to make the rotation handling simpler\n    // as we do no need to worry about changing the transform-origin\n    width: `${arrowMaxDimension}px`,\n    height: `${arrowMaxDimension}px`,\n\n    // rotate the arrow appropriately\n    transform: `rotate(${rotation}deg)`,\n    willChange: 'transform',\n\n    // position the arrow appropriately\n    position: 'absolute',\n    [side]: '100%',\n\n    // Because the arrow gets rotated (see `transform above`)\n    // and we are putting it inside a 1:1 ratio container\n    // we need to adjust the CSS direction from `ltr` to `rtl`\n    // in some circumstances\n    direction: getArrowCssDirection(side, align),\n  };\n\n  if (side === 'top' || side === 'bottom') {\n    if (align === 'start') {\n      styles.left = `${arrowOffset}px`;\n    }\n    if (align === 'center') {\n      styles.left = `${popperCenterX}px`;\n    }\n    if (align === 'end') {\n      styles.right = `${arrowOffset}px`;\n    }\n  }\n\n  if (side === 'left' || side === 'right') {\n    if (align === 'start') {\n      styles.top = `${arrowOffset}px`;\n    }\n    if (align === 'center') {\n      styles.top = `${popperCenterY}px`;\n    }\n    if (align === 'end') {\n      styles.bottom = `${arrowOffset}px`;\n    }\n  }\n\n  return styles;\n}\n\n/**\n * Adjusts the arrow's CSS direction (`ltr` / `rtl`)\n */\nfunction getArrowCssDirection(side: Side, align: Align): CSS.Property.Direction {\n  if ((side === 'top' || side === 'right') && align === 'end') {\n    return 'rtl';\n  }\n\n  if ((side === 'bottom' || side === 'left') && align !== 'end') {\n    return 'rtl';\n  }\n\n  return 'ltr';\n}\n\n/**\n * Gets the opposite side of a given side (ie. top => bottom, left => right, \u2026)\n */\nfunction getOppositeSide(side: Side): Side {\n  const oppositeSides: Record<Side, Side> = {\n    top: 'bottom',\n    right: 'left',\n    bottom: 'top',\n    left: 'right',\n  };\n  return oppositeSides[side];\n}\n\n/**\n * Creates a new rect (`ClientRect`) based on a given one but contracted by\n * a given amout on each side.\n */\nfunction getContractedRect(rect: ClientRect, amount: number) {\n  return DOMRect.fromRect({\n    width: rect.width - amount * 2,\n    height: rect.height - amount * 2,\n    x: rect.left + amount,\n    y: rect.top + amount,\n  });\n}\n\n/**\n * Gets collisions for each side of a rect (top, right, bottom, left)\n */\nfunction getCollisions(\n  /** The rect to test collisions against */\n  rect: ClientRect,\n  /** The rect which represents the boundaries for collision checks */\n  collisionBoundariesRect: ClientRect\n) {\n  return {\n    top: rect.top < collisionBoundariesRect.top,\n    right: rect.right > collisionBoundariesRect.right,\n    bottom: rect.bottom > collisionBoundariesRect.bottom,\n    left: rect.left < collisionBoundariesRect.left,\n  };\n}\n\ntype Collisions = ReturnType<typeof getCollisions>;\n\nexport { getPlacementData, SIDE_OPTIONS, ALIGN_OPTIONS };\nexport type { Side, Align };\n", "import * as React from 'react';\nimport { getPlacementData } from '@radix-ui/popper';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { useRect } from '@radix-ui/react-use-rect';\nimport { useSize } from '@radix-ui/react-use-size';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport * as ArrowPrimitive from '@radix-ui/react-arrow';\n\nimport type * as Radix from '@radix-ui/react-primitive';\nimport type { Scope } from '@radix-ui/react-context';\nimport type { Side, Align } from '@radix-ui/popper';\nimport type { Measurable } from '@radix-ui/rect';\n\n/* -------------------------------------------------------------------------------------------------\n * Popper\n * -----------------------------------------------------------------------------------------------*/\n\nconst POPPER_NAME = 'Popper';\n\ntype ScopedProps<P> = P & { __scopePopper?: Scope };\nconst [createPopperContext, createPopperScope] = createContextScope(POPPER_NAME);\n\ntype PopperContextValue = {\n  anchor: Measurable | null;\n  onAnchorChange(anchor: Measurable | null): void;\n};\nconst [PopperProvider, usePopperContext] = createPopperContext<PopperContextValue>(POPPER_NAME);\n\ninterface PopperProps {\n  children?: React.ReactNode;\n}\nconst Popper: React.FC<PopperProps> = (props: ScopedProps<PopperProps>) => {\n  const { __scopePopper, children } = props;\n  const [anchor, setAnchor] = React.useState<Measurable | null>(null);\n  return (\n    <PopperProvider scope={__scopePopper} anchor={anchor} onAnchorChange={setAnchor}>\n      {children}\n    </PopperProvider>\n  );\n};\n\nPopper.displayName = POPPER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * PopperAnchor\n * -----------------------------------------------------------------------------------------------*/\n\nconst ANCHOR_NAME = 'PopperAnchor';\n\ntype PopperAnchorElement = React.ElementRef<typeof Primitive.div>;\ntype PrimitiveDivProps = Radix.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface PopperAnchorProps extends PrimitiveDivProps {\n  virtualRef?: React.RefObject<Measurable>;\n}\n\nconst PopperAnchor = React.forwardRef<PopperAnchorElement, PopperAnchorProps>(\n  (props: ScopedProps<PopperAnchorProps>, forwardedRef) => {\n    const { __scopePopper, virtualRef, ...anchorProps } = props;\n    const context = usePopperContext(ANCHOR_NAME, __scopePopper);\n    const ref = React.useRef<PopperAnchorElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, ref);\n\n    React.useEffect(() => {\n      // Consumer can anchor the popper to something that isn't\n      // a DOM node e.g. pointer position, so we override the\n      // `anchorRef` with their virtual ref in this case.\n      context.onAnchorChange(virtualRef?.current || ref.current);\n    });\n\n    return virtualRef ? null : <Primitive.div {...anchorProps} ref={composedRefs} />;\n  }\n);\n\nPopperAnchor.displayName = ANCHOR_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * PopperContent\n * -----------------------------------------------------------------------------------------------*/\n\nconst CONTENT_NAME = 'PopperContent';\n\ntype PopperContentContextValue = {\n  arrowStyles: React.CSSProperties;\n  onArrowChange(arrow: HTMLSpanElement | null): void;\n  onArrowOffsetChange(offset?: number): void;\n};\n\nconst [PopperContentProvider, useContentContext] =\n  createPopperContext<PopperContentContextValue>(CONTENT_NAME);\n\ntype PopperContentElement = React.ElementRef<typeof Primitive.div>;\ninterface PopperContentProps extends PrimitiveDivProps {\n  side?: Side;\n  sideOffset?: number;\n  align?: Align;\n  alignOffset?: number;\n  collisionTolerance?: number;\n  avoidCollisions?: boolean;\n}\n\nconst PopperContent = React.forwardRef<PopperContentElement, PopperContentProps>(\n  (props: ScopedProps<PopperContentProps>, forwardedRef) => {\n    const {\n      __scopePopper,\n      side = 'bottom',\n      sideOffset,\n      align = 'center',\n      alignOffset,\n      collisionTolerance,\n      avoidCollisions = true,\n      ...contentProps\n    } = props;\n\n    const context = usePopperContext(CONTENT_NAME, __scopePopper);\n    const [arrowOffset, setArrowOffset] = React.useState<number>();\n    const anchorRect = useRect(context.anchor);\n    const [content, setContent] = React.useState<HTMLDivElement | null>(null);\n    const contentSize = useSize(content);\n    const [arrow, setArrow] = React.useState<HTMLSpanElement | null>(null);\n    const arrowSize = useSize(arrow);\n\n    const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));\n\n    const windowSize = useWindowSize();\n    const collisionBoundariesRect = windowSize\n      ? DOMRect.fromRect({ ...windowSize, x: 0, y: 0 })\n      : undefined;\n\n    const { popperStyles, arrowStyles, placedSide, placedAlign } = getPlacementData({\n      anchorRect,\n      popperSize: contentSize,\n      arrowSize,\n\n      // config\n      arrowOffset,\n      side,\n      sideOffset,\n      align,\n      alignOffset,\n      shouldAvoidCollisions: avoidCollisions,\n      collisionBoundariesRect,\n      collisionTolerance,\n    });\n    const isPlaced = placedSide !== undefined;\n\n    return (\n      <div style={popperStyles} data-radix-popper-content-wrapper=\"\">\n        <PopperContentProvider\n          scope={__scopePopper}\n          arrowStyles={arrowStyles}\n          onArrowChange={setArrow}\n          onArrowOffsetChange={setArrowOffset}\n        >\n          <Primitive.div\n            data-side={placedSide}\n            data-align={placedAlign}\n            {...contentProps}\n            style={{\n              ...contentProps.style,\n              // if the PopperContent hasn't been placed yet (not all measurements done)\n              // we prevent animations so that users's animation don't kick in too early referring wrong sides\n              animation: !isPlaced ? 'none' : undefined,\n            }}\n            ref={composedRefs}\n          />\n        </PopperContentProvider>\n      </div>\n    );\n  }\n);\n\nPopperContent.displayName = CONTENT_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * PopperArrow\n * -----------------------------------------------------------------------------------------------*/\n\nconst ARROW_NAME = 'PopperArrow';\n\ntype PopperArrowElement = React.ElementRef<typeof ArrowPrimitive.Root>;\ntype ArrowProps = Radix.ComponentPropsWithoutRef<typeof ArrowPrimitive.Root>;\ninterface PopperArrowProps extends ArrowProps {\n  offset?: number;\n}\n\nconst PopperArrow = React.forwardRef<PopperArrowElement, PopperArrowProps>(function PopperArrow(\n  props: ScopedProps<PopperArrowProps>,\n  forwardedRef\n) {\n  const { __scopePopper, offset, ...arrowProps } = props;\n  const context = useContentContext(ARROW_NAME, __scopePopper);\n  const { onArrowOffsetChange } = context;\n\n  // send the Arrow's offset up to Popper\n  React.useEffect(() => onArrowOffsetChange(offset), [onArrowOffsetChange, offset]);\n\n  return (\n    <span style={{ ...context.arrowStyles, pointerEvents: 'none' }}>\n      <span\n        // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)\n        // doesn't report size as we'd expect on SVG elements.\n        // it reports their bounding box which is effectively the largest path inside the SVG.\n        ref={context.onArrowChange}\n        style={{\n          display: 'inline-block',\n          verticalAlign: 'top',\n          pointerEvents: 'auto',\n        }}\n      >\n        <ArrowPrimitive.Root\n          {...arrowProps}\n          ref={forwardedRef}\n          style={{\n            ...arrowProps.style,\n            // ensures the element can be measured correctly (mostly for if SVG)\n            display: 'block',\n          }}\n        />\n      </span>\n    </span>\n  );\n});\n\nPopperArrow.displayName = ARROW_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\nconst WINDOW_RESIZE_DEBOUNCE_WAIT_IN_MS = 100;\n\nfunction useWindowSize() {\n  const [windowSize, setWindowSize] = React.useState<{ width: number; height: number } | undefined>(\n    undefined\n  );\n\n  React.useEffect(() => {\n    let debounceTimerId: number;\n\n    function updateWindowSize() {\n      setWindowSize({ width: window.innerWidth, height: window.innerHeight });\n    }\n\n    function handleResize() {\n      window.clearTimeout(debounceTimerId);\n      debounceTimerId = window.setTimeout(updateWindowSize, WINDOW_RESIZE_DEBOUNCE_WAIT_IN_MS);\n    }\n\n    updateWindowSize();\n    window.addEventListener('resize', handleResize);\n    return () => window.removeEventListener('resize', handleResize);\n  }, []);\n\n  return windowSize;\n}\n\nconst Root = Popper;\nconst Anchor = PopperAnchor;\nconst Content = PopperContent;\nconst Arrow = PopperArrow;\n\nexport {\n  createPopperScope,\n  //\n  Popper,\n  PopperAnchor,\n  PopperContent,\n  PopperArrow,\n  //\n  Root,\n  Anchor,\n  Content,\n  Arrow,\n};\nexport type { PopperProps, PopperAnchorProps, PopperContentProps, PopperArrowProps };\n", "import * as React from 'react';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\n\nimport type * as Radix from '@radix-ui/react-primitive';\n\nconst AUTOFOCUS_ON_MOUNT = 'focusScope.autoFocusOnMount';\nconst AUTOFOCUS_ON_UNMOUNT = 'focusScope.autoFocusOnUnmount';\nconst EVENT_OPTIONS = { bubbles: false, cancelable: true };\n\ntype FocusableTarget = HTMLElement | { focus(): void };\n\n/* -------------------------------------------------------------------------------------------------\n * FocusScope\n * -----------------------------------------------------------------------------------------------*/\n\nconst FOCUS_SCOPE_NAME = 'FocusScope';\n\ntype FocusScopeElement = React.ElementRef<typeof Primitive.div>;\ntype PrimitiveDivProps = Radix.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface FocusScopeProps extends PrimitiveDivProps {\n  /**\n   * When `true`, tabbing from last item will focus first tabbable\n   * and shift+tab from first item will focus last tababble.\n   * @defaultValue false\n   */\n  loop?: boolean;\n\n  /**\n   * When `true`, focus cannot escape the focus scope via keyboard,\n   * pointer, or a programmatic focus.\n   * @defaultValue false\n   */\n  trapped?: boolean;\n\n  /**\n   * Event handler called when auto-focusing on mount.\n   * Can be prevented.\n   */\n  onMountAutoFocus?: (event: Event) => void;\n\n  /**\n   * Event handler called when auto-focusing on unmount.\n   * Can be prevented.\n   */\n  onUnmountAutoFocus?: (event: Event) => void;\n}\n\nconst FocusScope = React.forwardRef<FocusScopeElement, FocusScopeProps>((props, forwardedRef) => {\n  const {\n    loop = false,\n    trapped = false,\n    onMountAutoFocus: onMountAutoFocusProp,\n    onUnmountAutoFocus: onUnmountAutoFocusProp,\n    ...scopeProps\n  } = props;\n  const [container, setContainer] = React.useState<HTMLElement | null>(null);\n  const onMountAutoFocus = useCallbackRef(onMountAutoFocusProp);\n  const onUnmountAutoFocus = useCallbackRef(onUnmountAutoFocusProp);\n  const lastFocusedElementRef = React.useRef<HTMLElement | null>(null);\n  const composedRefs = useComposedRefs(forwardedRef, (node) => setContainer(node));\n\n  const focusScope = React.useRef({\n    paused: false,\n    pause() {\n      this.paused = true;\n    },\n    resume() {\n      this.paused = false;\n    },\n  }).current;\n\n  // Takes care of trapping focus if focus is moved outside programmatically for example\n  React.useEffect(() => {\n    if (trapped) {\n      function handleFocusIn(event: FocusEvent) {\n        if (focusScope.paused || !container) return;\n        const target = event.target as HTMLElement | null;\n        if (container.contains(target)) {\n          lastFocusedElementRef.current = target;\n        } else {\n          focus(lastFocusedElementRef.current, { select: true });\n        }\n      }\n\n      function handleFocusOut(event: FocusEvent) {\n        if (focusScope.paused || !container) return;\n        if (!container.contains(event.relatedTarget as HTMLElement | null)) {\n          focus(lastFocusedElementRef.current, { select: true });\n        }\n      }\n\n      document.addEventListener('focusin', handleFocusIn);\n      document.addEventListener('focusout', handleFocusOut);\n      return () => {\n        document.removeEventListener('focusin', handleFocusIn);\n        document.removeEventListener('focusout', handleFocusOut);\n      };\n    }\n  }, [trapped, container, focusScope.paused]);\n\n  React.useEffect(() => {\n    if (container) {\n      focusScopesStack.add(focusScope);\n      const previouslyFocusedElement = document.activeElement as HTMLElement | null;\n      const hasFocusedCandidate = container.contains(previouslyFocusedElement);\n\n      if (!hasFocusedCandidate) {\n        const mountEvent = new Event(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS);\n        container.addEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);\n        container.dispatchEvent(mountEvent);\n        if (!mountEvent.defaultPrevented) {\n          focusFirst(removeLinks(getTabbableCandidates(container)), { select: true });\n          if (document.activeElement === previouslyFocusedElement) {\n            focus(container);\n          }\n        }\n      }\n\n      return () => {\n        container.removeEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);\n\n        // We hit a react bug (fixed in v17) with focusing in unmount.\n        // We need to delay the focus a little to get around it for now.\n        // See: https://github.com/facebook/react/issues/17894\n        setTimeout(() => {\n          const unmountEvent = new Event(AUTOFOCUS_ON_UNMOUNT, EVENT_OPTIONS);\n          container.addEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);\n          container.dispatchEvent(unmountEvent);\n          if (!unmountEvent.defaultPrevented) {\n            focus(previouslyFocusedElement ?? document.body, { select: true });\n          }\n          // we need to remove the listener after we `dispatchEvent`\n          container.removeEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);\n\n          focusScopesStack.remove(focusScope);\n        }, 0);\n      };\n    }\n  }, [container, onMountAutoFocus, onUnmountAutoFocus, focusScope]);\n\n  // Takes care of looping focus (when tabbing whilst at the edges)\n  const handleKeyDown = React.useCallback(\n    (event: React.KeyboardEvent) => {\n      if (!loop && !trapped) return;\n      if (focusScope.paused) return;\n\n      const isTabKey = event.key === 'Tab' && !event.altKey && !event.ctrlKey && !event.metaKey;\n      const focusedElement = document.activeElement as HTMLElement | null;\n\n      if (isTabKey && focusedElement) {\n        const container = event.currentTarget as HTMLElement;\n        const [first, last] = getTabbableEdges(container);\n        const hasTabbableElementsInside = first && last;\n\n        // we can only wrap focus if we have tabbable edges\n        if (!hasTabbableElementsInside) {\n          if (focusedElement === container) event.preventDefault();\n        } else {\n          if (!event.shiftKey && focusedElement === last) {\n            event.preventDefault();\n            if (loop) focus(first, { select: true });\n          } else if (event.shiftKey && focusedElement === first) {\n            event.preventDefault();\n            if (loop) focus(last, { select: true });\n          }\n        }\n      }\n    },\n    [loop, trapped, focusScope.paused]\n  );\n\n  return (\n    <Primitive.div tabIndex={-1} {...scopeProps} ref={composedRefs} onKeyDown={handleKeyDown} />\n  );\n});\n\nFocusScope.displayName = FOCUS_SCOPE_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * Utils\n * -----------------------------------------------------------------------------------------------*/\n\n/**\n * Attempts focusing the first element in a list of candidates.\n * Stops when focus has actually moved.\n */\nfunction focusFirst(candidates: HTMLElement[], { select = false } = {}) {\n  const previouslyFocusedElement = document.activeElement;\n  for (const candidate of candidates) {\n    focus(candidate, { select });\n    if (document.activeElement !== previouslyFocusedElement) return;\n  }\n}\n\n/**\n * Returns the first and last tabbable elements inside a container.\n */\nfunction getTabbableEdges(container: HTMLElement) {\n  const candidates = getTabbableCandidates(container);\n  const first = findVisible(candidates, container);\n  const last = findVisible(candidates.reverse(), container);\n  return [first, last] as const;\n}\n\n/**\n * Returns a list of potential tabbable candidates.\n *\n * NOTE: This is only a close approximation. For example it doesn't take into account cases like when\n * elements are not visible. This cannot be worked out easily by just reading a property, but rather\n * necessitate runtime knowledge (computed styles, etc). We deal with these cases separately.\n *\n * See: https://developer.mozilla.org/en-US/docs/Web/API/TreeWalker\n * Credit: https://github.com/discord/focus-layers/blob/master/src/util/wrapFocus.tsx#L1\n */\nfunction getTabbableCandidates(container: HTMLElement) {\n  const nodes: HTMLElement[] = [];\n  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: (node: any) => {\n      const isHiddenInput = node.tagName === 'INPUT' && node.type === 'hidden';\n      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;\n      // `.tabIndex` is not the same as the `tabindex` attribute. It works on the\n      // runtime's understanding of tabbability, so this automatically accounts\n      // for any kind of element that could be tabbed to.\n      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    },\n  });\n  while (walker.nextNode()) nodes.push(walker.currentNode as HTMLElement);\n  // we do not take into account the order of nodes with positive `tabIndex` as it\n  // hinders accessibility to have tab order different from visual order.\n  return nodes;\n}\n\n/**\n * Returns the first visible element in a list.\n * NOTE: Only checks visibility up to the `container`.\n */\nfunction findVisible(elements: HTMLElement[], container: HTMLElement) {\n  for (const element of elements) {\n    // we stop checking if it's hidden at the `container` level (excluding)\n    if (!isHidden(element, { upTo: container })) return element;\n  }\n}\n\nfunction isHidden(node: HTMLElement, { upTo }: { upTo?: HTMLElement }) {\n  if (getComputedStyle(node).visibility === 'hidden') return true;\n  while (node) {\n    // we stop at `upTo` (excluding it)\n    if (upTo !== undefined && node === upTo) return false;\n    if (getComputedStyle(node).display === 'none') return true;\n    node = node.parentElement as HTMLElement;\n  }\n  return false;\n}\n\nfunction isSelectableInput(element: any): element is FocusableTarget & { select: () => void } {\n  return element instanceof HTMLInputElement && 'select' in element;\n}\n\nfunction focus(element?: FocusableTarget | null, { select = false } = {}) {\n  // only focus if that element is focusable\n  if (element && element.focus) {\n    const previouslyFocusedElement = document.activeElement;\n    // NOTE: we prevent scrolling on focus, to minimize jarring transitions for users\n    element.focus({ preventScroll: true });\n    // only select if its not the same element, it supports selection and we need to select\n    if (element !== previouslyFocusedElement && isSelectableInput(element) && select)\n      element.select();\n  }\n}\n\n/* -------------------------------------------------------------------------------------------------\n * FocusScope stack\n * -----------------------------------------------------------------------------------------------*/\n\ntype FocusScopeAPI = { paused: boolean; pause(): void; resume(): void };\nconst focusScopesStack = createFocusScopesStack();\n\nfunction createFocusScopesStack() {\n  /** A stack of focus scopes, with the active one at the top */\n  let stack: FocusScopeAPI[] = [];\n\n  return {\n    add(focusScope: FocusScopeAPI) {\n      // pause the currently active focus scope (at the top of the stack)\n      const activeFocusScope = stack[0];\n      if (focusScope !== activeFocusScope) {\n        activeFocusScope?.pause();\n      }\n      // remove in case it already exists (because we'll re-add it at the top of the stack)\n      stack = arrayRemove(stack, focusScope);\n      stack.unshift(focusScope);\n    },\n\n    remove(focusScope: FocusScopeAPI) {\n      stack = arrayRemove(stack, focusScope);\n      stack[0]?.resume();\n    },\n  };\n}\n\nfunction arrayRemove<T>(array: T[], item: T) {\n  const updatedArray = [...array];\n  const index = updatedArray.indexOf(item);\n  if (index !== -1) {\n    updatedArray.splice(index, 1);\n  }\n  return updatedArray;\n}\n\nfunction removeLinks(items: HTMLElement[]) {\n  return items.filter((item) => item.tagName !== 'A');\n}\n\nconst Root = FocusScope;\n\nexport {\n  FocusScope,\n  //\n  Root,\n};\nexport type { FocusScopeProps };\n", "import * as React from 'react';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport { createContext } from '@radix-ui/react-context';\nimport { useBodyPointerEvents } from '@radix-ui/react-use-body-pointer-events';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\nimport { useEscapeKeydown } from '@radix-ui/react-use-escape-keydown';\n\nimport type * as Radix from '@radix-ui/react-primitive';\n\n// We need to compute the total count of layers AND a running count of all layers\n// in order to find which layer is the deepest one.\n// This is use to only dismiss the deepest layer when using the escape key\n// because we bind the key listener to document so cannot take advantage of event.stopPropagation()\nconst [TotalLayerCountProvider, useTotalLayerCount] = createTotalLayerCount();\nconst [RunningLayerCountProvider, usePreviousRunningLayerCount] = createRunningLayerCount();\n\n// We need to compute the total count of layers which set `disableOutsidePointerEvents` to `true` AND\n// a running count of all the layers which set `disableOutsidePointerEvents` to `true` in order to determine\n// which layers should be dismissed when interacting outside.\n// (ie. all layers that do not have a child layer which sets `disableOutsidePointerEvents` to `true`)\nconst [\n  TotalLayerCountWithDisabledOutsidePointerEventsProvider,\n  useTotalLayerCountWithDisabledOutsidePointerEvents,\n] = createTotalLayerCount('TotalLayerCountWithDisabledOutsidePointerEventsProvider');\nconst [\n  RunningLayerCountWithDisabledOutsidePointerEventsProvider,\n  usePreviousRunningLayerCountWithDisabledOutsidePointerEvents,\n] = createRunningLayerCount('RunningLayerCountWithDisabledOutsidePointerEventsProvider');\n\n/* -------------------------------------------------------------------------------------------------\n * DismissableLayer\n * -----------------------------------------------------------------------------------------------*/\n\nconst DISMISSABLE_LAYER_NAME = 'DismissableLayer';\n\ntype DismissableLayerElement = DismissableLayerImplElement;\ninterface DismissableLayerProps extends DismissableLayerImplProps {}\n\nconst DismissableLayer = React.forwardRef<DismissableLayerElement, DismissableLayerProps>(\n  (props, forwardedRef) => {\n    const runningLayerCount = usePreviousRunningLayerCount();\n    const isRootLayer = runningLayerCount === 0;\n    const layer = <DismissableLayerImpl {...props} ref={forwardedRef} />;\n\n    // if it's the root layer, we wrap it with our necessary root providers\n    // (effectively we wrap the whole tree of nested layers)\n    return isRootLayer ? (\n      <TotalLayerCountProvider>\n        <TotalLayerCountWithDisabledOutsidePointerEventsProvider>\n          {layer}\n        </TotalLayerCountWithDisabledOutsidePointerEventsProvider>\n      </TotalLayerCountProvider>\n    ) : (\n      layer\n    );\n  }\n);\n\nDismissableLayer.displayName = DISMISSABLE_LAYER_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\ntype DismissableLayerImplElement = React.ElementRef<typeof Primitive.div>;\ntype PrimitiveDivProps = Radix.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface DismissableLayerImplProps extends PrimitiveDivProps {\n  /**\n   * When `true`, hover/focus/click interactions will be disabled on elements outside\n   * the `DismissableLayer`. Users will need to click twice on outside elements to\n   * interact with them: once to close the `DismissableLayer`, and again to trigger the element.\n   */\n  disableOutsidePointerEvents?: boolean;\n\n  /**\n   * Event handler called when the escape key is down.\n   * Can be prevented.\n   */\n  onEscapeKeyDown?: (event: KeyboardEvent) => void;\n\n  /**\n   * Event handler called when the a `pointerdown` event happens outside of the `DismissableLayer`.\n   * Can be prevented.\n   */\n  onPointerDownOutside?: (event: PointerDownOutsideEvent) => void;\n\n  /**\n   * Event handler called when the focus moves outside of the `DismissableLayer`.\n   * Can be prevented.\n   */\n  onFocusOutside?: (event: FocusOutsideEvent) => void;\n\n  /**\n   * Event handler called when an interaction happens outside the `DismissableLayer`.\n   * Specifically, when a `pointerdown` event happens outside or focus moves outside of it.\n   * Can be prevented.\n   */\n  onInteractOutside?: (event: PointerDownOutsideEvent | FocusOutsideEvent) => void;\n\n  /** Callback called when the `DismissableLayer` should be dismissed */\n  onDismiss?: () => void;\n}\n\nconst DismissableLayerImpl = React.forwardRef<\n  DismissableLayerImplElement,\n  DismissableLayerImplProps\n>((props, forwardedRef) => {\n  const {\n    disableOutsidePointerEvents = false,\n    onEscapeKeyDown,\n    onPointerDownOutside,\n    onFocusOutside,\n    onInteractOutside,\n    onDismiss,\n    ...layerProps\n  } = props;\n\n  const totalLayerCount = useTotalLayerCount();\n  const prevRunningLayerCount = usePreviousRunningLayerCount();\n  const runningLayerCount = prevRunningLayerCount + 1;\n  const isDeepestLayer = runningLayerCount === totalLayerCount;\n\n  const totalLayerCountWithDisabledOutsidePointerEvents =\n    useTotalLayerCountWithDisabledOutsidePointerEvents(disableOutsidePointerEvents);\n  const prevRunningLayerCountWithDisabledOutsidePointerEvents =\n    usePreviousRunningLayerCountWithDisabledOutsidePointerEvents();\n  const runningLayerCountWithDisabledOutsidePointerEvents =\n    prevRunningLayerCountWithDisabledOutsidePointerEvents + (disableOutsidePointerEvents ? 1 : 0);\n  const containsChildLayerWithDisabledOutsidePointerEvents =\n    runningLayerCountWithDisabledOutsidePointerEvents <\n    totalLayerCountWithDisabledOutsidePointerEvents;\n\n  // Disable pointer-events on `document.body` when at least one layer is disabling outside pointer events\n  useBodyPointerEvents({ disabled: disableOutsidePointerEvents });\n\n  // Dismiss on escape\n  useEscapeKeydown((event) => {\n    // Only dismiss if it's the deepest layer. his is effectively mimicking\n    // event.stopPropagation from the layer with disabled outside pointer events.\n    if (isDeepestLayer) {\n      onEscapeKeyDown?.(event);\n      if (!event.defaultPrevented) {\n        onDismiss?.();\n      }\n    }\n  });\n\n  // Dismiss on pointer down outside\n  const { onPointerDownCapture: handlePointerDownCapture } = usePointerDownOutside((event) => {\n    // Only dismiss if there's no deeper layer which disabled pointer events outside itself\n    if (!containsChildLayerWithDisabledOutsidePointerEvents) {\n      onPointerDownOutside?.(event);\n      onInteractOutside?.(event);\n      if (!event.defaultPrevented) {\n        onDismiss?.();\n      }\n    }\n  });\n\n  // Dismiss on focus outside\n  const { onBlurCapture: handleBlurCapture, onFocusCapture: handleFocusCapture } = useFocusOutside(\n    (event) => {\n      onFocusOutside?.(event);\n      onInteractOutside?.(event);\n      if (!event.defaultPrevented) {\n        onDismiss?.();\n      }\n    }\n  );\n\n  // If we have disabled pointer events on body, we need to reset `pointerEvents: 'auto'`\n  // on some layers. This depends on which layers set `disableOutsidePointerEvents` to `true`.\n  //\n  // NOTE: it's important we set it on ALL layers that need it as we cannot simply\n  // set it on the deepest layer which sets `disableOutsidePointerEvents` to `true` and rely\n  // on inheritence. This is because layers may be rendered in different portals where\n  // inheritence wouldn't apply, so we need to set it explicity on its children too.\n  const isBodyPointerEventsDisabled = totalLayerCountWithDisabledOutsidePointerEvents > 0;\n  const shouldReEnablePointerEvents =\n    isBodyPointerEventsDisabled && !containsChildLayerWithDisabledOutsidePointerEvents;\n\n  return (\n    <RunningLayerCountProvider runningCount={runningLayerCount}>\n      <RunningLayerCountWithDisabledOutsidePointerEventsProvider\n        runningCount={runningLayerCountWithDisabledOutsidePointerEvents}\n      >\n        <Primitive.div\n          {...layerProps}\n          ref={forwardedRef}\n          style={{\n            pointerEvents: shouldReEnablePointerEvents ? 'auto' : undefined,\n            ...layerProps.style,\n          }}\n          onPointerDownCapture={composeEventHandlers(\n            props.onPointerDownCapture,\n            handlePointerDownCapture\n          )}\n          onBlurCapture={composeEventHandlers(props.onBlurCapture, handleBlurCapture)}\n          onFocusCapture={composeEventHandlers(props.onFocusCapture, handleFocusCapture)}\n        />\n      </RunningLayerCountWithDisabledOutsidePointerEventsProvider>\n    </RunningLayerCountProvider>\n  );\n});\n\n/* -------------------------------------------------------------------------------------------------\n * Utility hooks\n * -----------------------------------------------------------------------------------------------*/\n\nconst POINTER_DOWN_OUTSIDE = 'dismissableLayer.pointerDownOutside';\nconst FOCUS_OUTSIDE = 'dismissableLayer.focusOutside';\ntype PointerDownOutsideEvent = CustomEvent<{ originalEvent: PointerEvent }>;\ntype FocusOutsideEvent = CustomEvent<{ originalEvent: FocusEvent }>;\n\n/**\n * Sets up `pointerdown` listener which listens for events outside a react subtree.\n *\n * We use `pointerdown` rather than `pointerup` to mimic layer dismissing behaviour\n * present in OS which usually happens on `pointerdown`.\n *\n * Returns props to pass to the node we want to check for outside events.\n */\n\nfunction usePointerDownOutside(onPointerDownOutside?: (event: PointerDownOutsideEvent) => void) {\n  const handlePointerDownOutside = useCallbackRef(onPointerDownOutside) as EventListener;\n  const isPointerInsideReactTreeRef = React.useRef(false);\n\n  React.useEffect(() => {\n    const handlePointerDown = (event: PointerEvent) => {\n      const target = event.target;\n      if (target && !isPointerInsideReactTreeRef.current) {\n        const pointerDownOutsideEvent: PointerDownOutsideEvent = new CustomEvent(\n          POINTER_DOWN_OUTSIDE,\n          { bubbles: false, cancelable: true, detail: { originalEvent: event } }\n        );\n        target.addEventListener(POINTER_DOWN_OUTSIDE, handlePointerDownOutside, { once: true });\n        target.dispatchEvent(pointerDownOutsideEvent);\n      }\n      isPointerInsideReactTreeRef.current = false;\n    };\n    /**\n     * if this hook executes in a component that mounts via a `pointerdown` event, the event\n     * would bubble up to the document and trigger a `pointerDownOutside` event. We avoid\n     * this by delaying the event listener registration on the document.\n     * This is not React specific, but rather how the DOM works, ie:\n     * ```\n     * button.addEventListener('pointerdown', () => {\n     *   console.log('I will log');\n     *   document.addEventListener('pointerdown', () => {\n     *     console.log('I will also log');\n     *   })\n     * });\n     */\n    const timerId = window.setTimeout(() => {\n      document.addEventListener('pointerdown', handlePointerDown);\n    }, 0);\n    return () => {\n      window.clearTimeout(timerId);\n      document.removeEventListener('pointerdown', handlePointerDown);\n    };\n  }, [handlePointerDownOutside]);\n\n  return {\n    // ensures we check React component tree (not just DOM tree)\n    onPointerDownCapture: () => (isPointerInsideReactTreeRef.current = true),\n  };\n}\n\n/**\n * Listens for when focus happens outside a react subtree.\n * Returns props to pass to the root (node) of the subtree we want to check.\n */\n\nfunction useFocusOutside(onFocusOutside?: (event: FocusOutsideEvent) => void) {\n  const handleFocusOutside = useCallbackRef(onFocusOutside) as EventListener;\n  const isFocusInsideReactTreeRef = React.useRef(false);\n\n  React.useEffect(() => {\n    const handleFocus = (event: FocusEvent) => {\n      const target = event.target;\n      if (target && !isFocusInsideReactTreeRef.current) {\n        const focusOutsideEvent: FocusOutsideEvent = new CustomEvent(FOCUS_OUTSIDE, {\n          bubbles: false,\n          cancelable: true,\n          detail: { originalEvent: event },\n        });\n        target.addEventListener(FOCUS_OUTSIDE, handleFocusOutside, { once: true });\n        target.dispatchEvent(focusOutsideEvent);\n      }\n    };\n    document.addEventListener('focusin', handleFocus);\n    return () => document.removeEventListener('focusin', handleFocus);\n  }, [handleFocusOutside]);\n\n  return {\n    onFocusCapture: () => (isFocusInsideReactTreeRef.current = true),\n    onBlurCapture: () => (isFocusInsideReactTreeRef.current = false),\n  };\n}\n\n/* -------------------------------------------------------------------------------------------------\n * Layer counting utilities\n * -----------------------------------------------------------------------------------------------*/\n\nfunction createTotalLayerCount(displayName?: string) {\n  const [TotalLayerCountProviderImpl, useTotalLayerCountContext] = createContext(\n    'TotalLayerCount',\n    { total: 0, onTotalIncrease: () => {}, onTotalDecrease: () => {} }\n  );\n\n  const TotalLayerCountProvider: React.FC = ({ children }) => {\n    const [total, setTotal] = React.useState(0);\n    return (\n      <TotalLayerCountProviderImpl\n        total={total}\n        onTotalIncrease={React.useCallback(() => setTotal((n) => n + 1), [])}\n        onTotalDecrease={React.useCallback(() => setTotal((n) => n - 1), [])}\n      >\n        {children}\n      </TotalLayerCountProviderImpl>\n    );\n  };\n  if (displayName) {\n    TotalLayerCountProvider.displayName = displayName;\n  }\n\n  function useTotalLayerCount(counted = true) {\n    const { total, onTotalIncrease, onTotalDecrease } =\n      useTotalLayerCountContext('TotalLayerCountConsumer');\n\n    React.useLayoutEffect(() => {\n      if (counted) {\n        onTotalIncrease();\n        return () => onTotalDecrease();\n      }\n    }, [counted, onTotalIncrease, onTotalDecrease]);\n\n    return total;\n  }\n\n  return [TotalLayerCountProvider, useTotalLayerCount] as const;\n}\n\nfunction createRunningLayerCount(displayName?: string) {\n  const [RunningLayerCountProviderImp, useRunningLayerCount] = createContext('RunningLayerCount', {\n    count: 0,\n  });\n\n  const RunningLayerCountProvider: React.FC<{ runningCount: number }> = (props) => {\n    const { children, runningCount } = props;\n    return (\n      <RunningLayerCountProviderImp count={runningCount}>{children}</RunningLayerCountProviderImp>\n    );\n  };\n  if (displayName) {\n    RunningLayerCountProvider.displayName = displayName;\n  }\n\n  function usePreviousRunningLayerCount() {\n    const context = useRunningLayerCount('RunningLayerCountConsumer');\n    return context.count || 0;\n  }\n\n  return [RunningLayerCountProvider, usePreviousRunningLayerCount] as const;\n}\n\nconst Root = DismissableLayer;\n\nexport {\n  DismissableLayer,\n  //\n  Root,\n};\nexport type { DismissableLayerProps };\n", "import * as React from 'react';\nimport { RemoveScroll } from 'react-remove-scroll';\nimport { hideOthers } from 'aria-hidden';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { createCollection } from '@radix-ui/react-collection';\nimport { useComposedRefs, composeRefs } from '@radix-ui/react-compose-refs';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { DismissableLayer } from '@radix-ui/react-dismissable-layer';\nimport { FocusScope } from '@radix-ui/react-focus-scope';\nimport { Presence } from '@radix-ui/react-presence';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport * as PopperPrimitive from '@radix-ui/react-popper';\nimport { createPopperScope } from '@radix-ui/react-popper';\nimport { Portal } from '@radix-ui/react-portal';\nimport * as RovingFocusGroup from '@radix-ui/react-roving-focus';\nimport { createRovingFocusGroupScope } from '@radix-ui/react-roving-focus';\nimport { useDirection } from '@radix-ui/react-use-direction';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\nimport { useFocusGuards } from '@radix-ui/react-focus-guards';\nimport { useId } from '@radix-ui/react-id';\n\nimport type * as Radix from '@radix-ui/react-primitive';\nimport type { Scope } from '@radix-ui/react-context';\n\ntype Direction = 'ltr' | 'rtl';\n\nconst SELECTION_KEYS = ['Enter', ' '];\nconst FIRST_KEYS = ['ArrowDown', 'PageUp', 'Home'];\nconst LAST_KEYS = ['ArrowUp', 'PageDown', 'End'];\nconst FIRST_LAST_KEYS = [...FIRST_KEYS, ...LAST_KEYS];\nconst SUB_OPEN_KEYS: Record<Direction, string[]> = {\n  ltr: [...SELECTION_KEYS, 'ArrowRight'],\n  rtl: [...SELECTION_KEYS, 'ArrowLeft'],\n};\nconst SUB_CLOSE_KEYS: Record<Direction, string[]> = {\n  ltr: ['ArrowLeft'],\n  rtl: ['ArrowRight'],\n};\n\n/* -------------------------------------------------------------------------------------------------\n * Menu\n * -----------------------------------------------------------------------------------------------*/\n\nconst MENU_NAME = 'Menu';\n\ntype ItemData = { disabled: boolean; textValue: string };\nconst [Collection, useCollection, createCollectionScope] = createCollection<\n  MenuItemElement,\n  ItemData\n>(MENU_NAME);\n\ntype ScopedProps<P> = P & { __scopeMenu?: Scope };\nconst [createMenuContext, createMenuScope] = createContextScope(MENU_NAME, [\n  createCollectionScope,\n  createPopperScope,\n  createRovingFocusGroupScope,\n]);\nconst usePopperScope = createPopperScope();\nconst useRovingFocusGroupScope = createRovingFocusGroupScope();\n\ntype MenuRootContextValue = {\n  isSubmenu: false;\n  isUsingKeyboardRef: React.RefObject<boolean>;\n  dir: Direction;\n  open: boolean;\n  onOpenChange(open: boolean): void;\n  content: MenuContentElement | null;\n  onContentChange(content: MenuContentElement | null): void;\n  onRootClose(): void;\n  modal: boolean;\n};\n\ntype MenuSubContextValue = Omit<MenuRootContextValue, 'isSubmenu'> & {\n  isSubmenu: true;\n  contentId: string;\n  triggerId: string;\n  trigger: MenuSubTriggerElement | null;\n  onTriggerChange(trigger: MenuSubTriggerElement | null): void;\n};\n\nconst [MenuProvider, useMenuContext] = createMenuContext<\n  MenuRootContextValue | MenuSubContextValue\n>(MENU_NAME);\n\ninterface MenuProps {\n  open?: boolean;\n  onOpenChange?(open: boolean): void;\n  dir?: Direction;\n  modal?: boolean;\n  children?: React.ReactNode;\n}\n\nconst Menu: React.FC<MenuProps> = (props: ScopedProps<MenuProps>) => {\n  const { __scopeMenu, open = false, children, onOpenChange, modal = true } = props;\n  const popperScope = usePopperScope(__scopeMenu);\n  const [content, setContent] = React.useState<MenuContentElement | null>(null);\n  const isUsingKeyboardRef = React.useRef(false);\n  const handleOpenChange = useCallbackRef(onOpenChange);\n  const computedDirection = useDirection(content, props.dir);\n\n  React.useEffect(() => {\n    const handleKeyDown = () => (isUsingKeyboardRef.current = true);\n    const handlePointer = () => (isUsingKeyboardRef.current = false);\n    // Capture phase ensures we set the boolean before any side effects execute\n    // in response to the key or pointer event as they might depend on this value.\n    document.addEventListener('keydown', handleKeyDown, { capture: true });\n    document.addEventListener('pointerdown', handlePointer, { capture: true });\n    document.addEventListener('pointermove', handlePointer, { capture: true });\n    return () => {\n      document.removeEventListener('keydown', handleKeyDown, { capture: true });\n      document.removeEventListener('pointerdown', handlePointer, { capture: true });\n      document.removeEventListener('pointermove', handlePointer, { capture: true });\n    };\n  }, []);\n\n  return (\n    <PopperPrimitive.Root {...popperScope}>\n      <MenuProvider\n        scope={__scopeMenu}\n        isSubmenu={false}\n        isUsingKeyboardRef={isUsingKeyboardRef}\n        dir={computedDirection}\n        open={open}\n        onOpenChange={handleOpenChange}\n        content={content}\n        onContentChange={setContent}\n        onRootClose={React.useCallback(() => handleOpenChange(false), [handleOpenChange])}\n        modal={modal}\n      >\n        {children}\n      </MenuProvider>\n    </PopperPrimitive.Root>\n  );\n};\n\nMenu.displayName = MENU_NAME;\n\n/* ---------------------------------------------------------------------------------------------- */\n\nconst SUB_NAME = 'MenuSub';\n\ninterface MenuSubProps {\n  open?: boolean;\n  onOpenChange?(open: boolean): void;\n  children?: React.ReactNode;\n}\n\nconst MenuSub: React.FC<MenuSubProps> = (props: ScopedProps<MenuSubProps>) => {\n  const { __scopeMenu, children, open = false, onOpenChange } = props;\n  const parentMenuContext = useMenuContext(SUB_NAME, __scopeMenu);\n  const popperScope = usePopperScope(__scopeMenu);\n  const [trigger, setTrigger] = React.useState<MenuSubTriggerElement | null>(null);\n  const [content, setContent] = React.useState<MenuContentElement | null>(null);\n  const handleOpenChange = useCallbackRef(onOpenChange);\n\n  // Prevent the parent menu from reopening with open submenus.\n  React.useEffect(() => {\n    if (parentMenuContext.open === false) handleOpenChange(false);\n    return () => handleOpenChange(false);\n  }, [parentMenuContext.open, handleOpenChange]);\n\n  return (\n    <PopperPrimitive.Root {...popperScope}>\n      <MenuProvider\n        scope={__scopeMenu}\n        isSubmenu={true}\n        isUsingKeyboardRef={parentMenuContext.isUsingKeyboardRef}\n        dir={parentMenuContext.dir}\n        open={open}\n        onOpenChange={handleOpenChange}\n        content={content}\n        onContentChange={setContent}\n        onRootClose={parentMenuContext.onRootClose}\n        contentId={useId()}\n        trigger={trigger}\n        onTriggerChange={setTrigger}\n        triggerId={useId()}\n        modal={false}\n      >\n        {children}\n      </MenuProvider>\n    </PopperPrimitive.Root>\n  );\n};\n\nMenuSub.displayName = SUB_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuAnchor\n * -----------------------------------------------------------------------------------------------*/\n\nconst ANCHOR_NAME = 'MenuAnchor';\n\ntype MenuAnchorElement = React.ElementRef<typeof PopperPrimitive.Anchor>;\ntype PopperAnchorProps = Radix.ComponentPropsWithoutRef<typeof PopperPrimitive.Anchor>;\ninterface MenuAnchorProps extends PopperAnchorProps {}\n\nconst MenuAnchor = React.forwardRef<MenuAnchorElement, MenuAnchorProps>(\n  (props: ScopedProps<MenuAnchorProps>, forwardedRef) => {\n    const { __scopeMenu, ...anchorProps } = props;\n    const popperScope = usePopperScope(__scopeMenu);\n    return <PopperPrimitive.Anchor {...popperScope} {...anchorProps} ref={forwardedRef} />;\n  }\n);\n\nMenuAnchor.displayName = ANCHOR_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuContent\n * -----------------------------------------------------------------------------------------------*/\n\nconst CONTENT_NAME = 'MenuContent';\n\ntype MenuContentContextValue = {\n  onItemEnter(event: React.PointerEvent): void;\n  onItemLeave(event: React.PointerEvent): void;\n  onTriggerLeave(event: React.PointerEvent): void;\n  searchRef: React.RefObject<string>;\n  pointerGraceTimerRef: React.MutableRefObject<number>;\n  onPointerGraceIntentChange(intent: GraceIntent | null): void;\n};\nconst [MenuContentProvider, useMenuContentContext] =\n  createMenuContext<MenuContentContextValue>(CONTENT_NAME);\n\ntype MenuContentElement = MenuRootContentElement | MenuSubContentElement;\n/**\n * We purposefully don't union MenuRootContent and MenuSubContent props here because\n * they have conflicting prop types. We agreed that we would allow MenuSubContent to\n * accept props that it would just ignore.\n */\ninterface MenuContentProps extends MenuRootContentProps {\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst MenuContent = React.forwardRef<MenuContentElement, MenuContentProps>(\n  (props: ScopedProps<MenuContentProps>, forwardedRef) => {\n    const { forceMount, ...contentProps } = props;\n    const context = useMenuContext(CONTENT_NAME, props.__scopeMenu);\n    return (\n      <Collection.Provider scope={props.__scopeMenu}>\n        <Presence present={forceMount || context.open}>\n          <Collection.Slot scope={props.__scopeMenu}>\n            {context.isSubmenu ? (\n              <MenuSubContent {...contentProps} ref={forwardedRef} />\n            ) : (\n              <MenuRootContent {...contentProps} ref={forwardedRef} />\n            )}\n          </Collection.Slot>\n        </Presence>\n      </Collection.Provider>\n    );\n  }\n);\n\n/* ---------------------------------------------------------------------------------------------- */\n\ntype MenuRootContentElement = MenuRootContentTypeElement;\ninterface MenuRootContentProps\n  extends Omit<MenuRootContentTypeProps, keyof MenuContentImplPrivateProps> {}\n\nconst MenuRootContent = React.forwardRef<MenuRootContentElement, MenuRootContentProps>(\n  (props: ScopedProps<MenuRootContentProps>, forwardedRef) => {\n    const context = useMenuContext(CONTENT_NAME, props.__scopeMenu);\n    return context.modal ? (\n      <MenuRootContentModal {...props} ref={forwardedRef} />\n    ) : (\n      <MenuRootContentNonModal {...props} ref={forwardedRef} />\n    );\n  }\n);\n\ntype MenuRootContentTypeElement = MenuContentImplElement;\ninterface MenuRootContentTypeProps\n  extends Omit<\n    MenuContentImplProps,\n    'trapFocus' | 'disableOutsidePointerEvents' | 'disableOutsideScroll'\n  > {}\n\nconst MenuRootContentModal = React.forwardRef<MenuRootContentTypeElement, MenuRootContentTypeProps>(\n  (props: ScopedProps<MenuRootContentTypeProps>, forwardedRef) => {\n    const context = useMenuContext(CONTENT_NAME, props.__scopeMenu);\n    const ref = React.useRef<MenuRootContentTypeElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, ref);\n\n    // Hide everything from ARIA except the `MenuContent`\n    React.useEffect(() => {\n      const content = ref.current;\n      if (content) return hideOthers(content);\n    }, []);\n\n    return (\n      <MenuContentImpl\n        {...props}\n        ref={composedRefs}\n        // we make sure we're not trapping once it's been closed\n        // (closed !== unmounted when animating out)\n        trapFocus={context.open}\n        // make sure to only disable pointer events when open\n        // this avoids blocking interactions while animating out\n        disableOutsidePointerEvents={context.open}\n        disableOutsideScroll\n        // When focus is trapped, a `focusout` event may still happen.\n        // We make sure we don't trigger our `onDismiss` in such case.\n        onFocusOutside={composeEventHandlers(\n          props.onFocusOutside,\n          (event) => event.preventDefault(),\n          { checkForDefaultPrevented: false }\n        )}\n        onDismiss={() => context.onOpenChange(false)}\n      />\n    );\n  }\n);\n\nconst MenuRootContentNonModal = React.forwardRef<\n  MenuRootContentTypeElement,\n  MenuRootContentTypeProps\n>((props: ScopedProps<MenuRootContentTypeProps>, forwardedRef) => {\n  const context = useMenuContext(CONTENT_NAME, props.__scopeMenu);\n  return (\n    <MenuContentImpl\n      {...props}\n      ref={forwardedRef}\n      trapFocus={false}\n      disableOutsidePointerEvents={false}\n      disableOutsideScroll={false}\n      onDismiss={() => context.onOpenChange(false)}\n    />\n  );\n});\n\n/* ---------------------------------------------------------------------------------------------- */\n\ntype MenuSubContentElement = MenuContentImplElement;\ninterface MenuSubContentProps\n  extends Omit<\n    MenuContentImplProps,\n    | keyof MenuContentImplPrivateProps\n    | 'align'\n    | 'side'\n    | 'portalled'\n    | 'disabledOutsidePointerEvents'\n    | 'disableOutsideScroll'\n    | 'trapFocus'\n    | 'onCloseAutoFocus'\n  > {}\n\nconst MenuSubContent = React.forwardRef<MenuSubContentElement, MenuSubContentProps>(\n  (props: ScopedProps<MenuSubContentProps>, forwardedRef) => {\n    const context = useMenuContext(CONTENT_NAME, props.__scopeMenu);\n    const ref = React.useRef<MenuSubContentElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, ref);\n    return context.isSubmenu ? (\n      <MenuContentImpl\n        id={context.contentId}\n        aria-labelledby={context.triggerId}\n        {...props}\n        ref={composedRefs}\n        align=\"start\"\n        side={context.dir === 'rtl' ? 'left' : 'right'}\n        portalled\n        disableOutsidePointerEvents={false}\n        disableOutsideScroll={false}\n        trapFocus={false}\n        onOpenAutoFocus={(event) => {\n          // when opening a submenu, focus content for keyboard users only\n          if (context.isUsingKeyboardRef.current) ref.current?.focus();\n          event.preventDefault();\n        }}\n        // The menu might close because of focusing another menu item in the parent menu. We\n        // don't want it to refocus the trigger in that case so we handle trigger focus ourselves.\n        onCloseAutoFocus={(event) => event.preventDefault()}\n        onFocusOutside={composeEventHandlers(props.onFocusOutside, (event) => {\n          // We prevent closing when the trigger is focused to avoid triggering a re-open animation\n          // on pointer interaction.\n          if (event.target !== context.trigger) context.onOpenChange(false);\n        })}\n        onEscapeKeyDown={composeEventHandlers(props.onEscapeKeyDown, context.onRootClose)}\n        onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n          // Submenu key events bubble through portals. We only care about keys in this menu.\n          const isKeyDownInside = event.currentTarget.contains(event.target as HTMLElement);\n          const isCloseKey = SUB_CLOSE_KEYS[context.dir].includes(event.key);\n          if (isKeyDownInside && isCloseKey) {\n            context.onOpenChange(false);\n            // We focus manually because we prevented it in `onCloseAutoFocus`\n            context.trigger?.focus();\n            // prevent window from scrolling\n            event.preventDefault();\n          }\n        })}\n      />\n    ) : null;\n  }\n);\n\n/* ---------------------------------------------------------------------------------------------- */\n\ntype RemoveScrollProps = React.ComponentProps<typeof RemoveScroll>;\ntype MenuContentImplElement = React.ElementRef<typeof PopperPrimitive.Content>;\ntype FocusScopeProps = Radix.ComponentPropsWithoutRef<typeof FocusScope>;\ntype DismissableLayerProps = Radix.ComponentPropsWithoutRef<typeof DismissableLayer>;\ntype RovingFocusGroupProps = Radix.ComponentPropsWithoutRef<typeof RovingFocusGroup.Root>;\ntype PopperContentProps = Radix.ComponentPropsWithoutRef<typeof PopperPrimitive.Content>;\ntype MenuContentImplPrivateProps = {\n  onOpenAutoFocus?: FocusScopeProps['onMountAutoFocus'];\n  onDismiss?: DismissableLayerProps['onDismiss'];\n};\ninterface MenuContentImplProps\n  extends MenuContentImplPrivateProps,\n    PopperContentProps,\n    Omit<DismissableLayerProps, 'onDismiss'> {\n  /**\n   * Whether focus should be trapped within the `MenuContent`\n   * (default: false)\n   */\n  trapFocus?: FocusScopeProps['trapped'];\n\n  /**\n   * Event handler called when auto-focusing on close.\n   * Can be prevented.\n   */\n  onCloseAutoFocus?: FocusScopeProps['onUnmountAutoFocus'];\n\n  /**\n   * @see https://github.com/theKashey/react-remove-scroll#usage\n   */\n  allowPinchZoom?: RemoveScrollProps['allowPinchZoom'];\n\n  /**\n   * Whether scrolling outside the `MenuContent` should be prevented\n   * (default: `false`)\n   */\n  disableOutsideScroll?: boolean;\n\n  /**\n   * The direction of navigation between menu items.\n   * @defaultValue ltr\n   */\n  dir?: RovingFocusGroupProps['dir'];\n\n  /**\n   * Whether keyboard navigation should loop around\n   * @defaultValue false\n   */\n  loop?: RovingFocusGroupProps['loop'];\n\n  /**\n   * Whether the `MenuContent` should render in a `Portal`\n   * (default: `true`)\n   */\n  portalled?: boolean;\n}\n\nconst MenuContentImpl = React.forwardRef<MenuContentImplElement, MenuContentImplProps>(\n  (props: ScopedProps<MenuContentImplProps>, forwardedRef) => {\n    const {\n      __scopeMenu,\n      loop = false,\n      trapFocus,\n      onOpenAutoFocus,\n      onCloseAutoFocus,\n      disableOutsidePointerEvents,\n      onEscapeKeyDown,\n      onPointerDownOutside,\n      onFocusOutside,\n      onInteractOutside,\n      onDismiss,\n      disableOutsideScroll,\n      allowPinchZoom,\n      portalled,\n      ...contentProps\n    } = props;\n    const context = useMenuContext(CONTENT_NAME, __scopeMenu);\n    const popperScope = usePopperScope(__scopeMenu);\n    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeMenu);\n    const getItems = useCollection(__scopeMenu);\n    const [currentItemId, setCurrentItemId] = React.useState<string | null>(null);\n    const contentRef = React.useRef<HTMLDivElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, contentRef, context.onContentChange);\n    const timerRef = React.useRef(0);\n    const searchRef = React.useRef('');\n    const pointerGraceTimerRef = React.useRef(0);\n    const pointerGraceIntentRef = React.useRef<GraceIntent | null>(null);\n    const pointerDirRef = React.useRef<Side>('right');\n    const lastPointerXRef = React.useRef(0);\n\n    const PortalWrapper = portalled ? Portal : React.Fragment;\n    const ScrollLockWrapper = disableOutsideScroll ? RemoveScroll : React.Fragment;\n    const scrollLockWrapperProps = disableOutsideScroll ? { allowPinchZoom } : undefined;\n\n    const handleTypeaheadSearch = (key: string) => {\n      const search = searchRef.current + key;\n      const items = getItems().filter((item) => !item.disabled);\n      const currentItem = document.activeElement;\n      const currentMatch = items.find((item) => item.ref.current === currentItem)?.textValue;\n      const values = items.map((item) => item.textValue);\n      const nextMatch = getNextMatch(values, search, currentMatch);\n      const newItem = items.find((item) => item.textValue === nextMatch)?.ref.current;\n\n      // Reset `searchRef` 1 second after it was last updated\n      (function updateSearch(value: string) {\n        searchRef.current = value;\n        window.clearTimeout(timerRef.current);\n        if (value !== '') timerRef.current = window.setTimeout(() => updateSearch(''), 1000);\n      })(search);\n\n      if (newItem) {\n        /**\n         * Imperative focus during keydown is risky so we prevent React's batching updates\n         * to avoid potential bugs. See: https://github.com/facebook/react/issues/20332\n         */\n        setTimeout(() => (newItem as HTMLElement).focus());\n      }\n    };\n\n    React.useEffect(() => {\n      return () => window.clearTimeout(timerRef.current);\n    }, []);\n\n    // Make sure the whole tree has focus guards as our `MenuContent` may be\n    // the last element in the DOM (beacuse of the `Portal`)\n    useFocusGuards();\n\n    const isPointerMovingToSubmenu = React.useCallback((event: React.PointerEvent) => {\n      const isMovingTowards = pointerDirRef.current === pointerGraceIntentRef.current?.side;\n      return isMovingTowards && isPointerInGraceArea(event, pointerGraceIntentRef.current?.area);\n    }, []);\n\n    return (\n      <PortalWrapper>\n        <ScrollLockWrapper {...scrollLockWrapperProps}>\n          <MenuContentProvider\n            scope={__scopeMenu}\n            searchRef={searchRef}\n            onItemEnter={React.useCallback(\n              (event) => {\n                if (isPointerMovingToSubmenu(event)) event.preventDefault();\n              },\n              [isPointerMovingToSubmenu]\n            )}\n            onItemLeave={React.useCallback(\n              (event) => {\n                if (isPointerMovingToSubmenu(event)) return;\n                contentRef.current?.focus();\n                setCurrentItemId(null);\n              },\n              [isPointerMovingToSubmenu]\n            )}\n            onTriggerLeave={React.useCallback(\n              (event) => {\n                if (isPointerMovingToSubmenu(event)) event.preventDefault();\n              },\n              [isPointerMovingToSubmenu]\n            )}\n            pointerGraceTimerRef={pointerGraceTimerRef}\n            onPointerGraceIntentChange={React.useCallback((intent) => {\n              pointerGraceIntentRef.current = intent;\n            }, [])}\n          >\n            <FocusScope\n              asChild\n              trapped={trapFocus}\n              onMountAutoFocus={composeEventHandlers(onOpenAutoFocus, (event) => {\n                // when opening, explicitly focus the content area only and leave\n                // `onEntryFocus` in  control of focusing first item\n                event.preventDefault();\n                contentRef.current?.focus();\n              })}\n              onUnmountAutoFocus={onCloseAutoFocus}\n            >\n              <DismissableLayer\n                asChild\n                disableOutsidePointerEvents={disableOutsidePointerEvents}\n                onEscapeKeyDown={onEscapeKeyDown}\n                onPointerDownOutside={onPointerDownOutside}\n                onFocusOutside={onFocusOutside}\n                onInteractOutside={onInteractOutside}\n                onDismiss={onDismiss}\n              >\n                <RovingFocusGroup.Root\n                  asChild\n                  {...rovingFocusGroupScope}\n                  dir={context.dir}\n                  orientation=\"vertical\"\n                  loop={loop}\n                  currentTabStopId={currentItemId}\n                  onCurrentTabStopIdChange={setCurrentItemId}\n                  onEntryFocus={(event) => {\n                    // only focus first item when using keyboard\n                    if (!context.isUsingKeyboardRef.current) event.preventDefault();\n                  }}\n                >\n                  <PopperPrimitive.Content\n                    role=\"menu\"\n                    aria-orientation=\"vertical\"\n                    data-state={getOpenState(context.open)}\n                    dir={context.dir}\n                    {...popperScope}\n                    {...contentProps}\n                    ref={composedRefs}\n                    style={{ outline: 'none', ...contentProps.style }}\n                    onKeyDown={composeEventHandlers(contentProps.onKeyDown, (event) => {\n                      // submenu key events bubble through portals. We only care about keys in this menu.\n                      const target = event.target as HTMLElement;\n                      const isKeyDownInside = event.currentTarget.contains(target);\n                      const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;\n                      if (isKeyDownInside && !isModifierKey && event.key.length === 1) {\n                        handleTypeaheadSearch(event.key);\n                      }\n                      // menus should not be navigated using tab key so we prevent it\n                      if (event.key === 'Tab') event.preventDefault();\n                      // focus first/last item based on key pressed\n                      const content = contentRef.current;\n                      if (event.target !== content) return;\n                      if (!FIRST_LAST_KEYS.includes(event.key)) return;\n                      event.preventDefault();\n                      const items = getItems().filter((item) => !item.disabled);\n                      const candidateNodes = items.map((item) => item.ref.current!);\n                      if (LAST_KEYS.includes(event.key)) candidateNodes.reverse();\n                      focusFirst(candidateNodes);\n                    })}\n                    onBlur={composeEventHandlers(props.onBlur, (event) => {\n                      // clear search buffer when leaving the menu\n                      if (!event.currentTarget.contains(event.target)) {\n                        window.clearTimeout(timerRef.current);\n                        searchRef.current = '';\n                      }\n                    })}\n                    onPointerMove={composeEventHandlers(\n                      props.onPointerMove,\n                      whenMouse((event) => {\n                        const target = event.target as HTMLElement;\n                        const pointerXHasChanged = lastPointerXRef.current !== event.clientX;\n\n                        // We don't use `event.movementX` for this check because Safari will\n                        // always return `0` on a pointer event.\n                        if (event.currentTarget.contains(target) && pointerXHasChanged) {\n                          const newDir = event.clientX > lastPointerXRef.current ? 'right' : 'left';\n                          pointerDirRef.current = newDir;\n                          lastPointerXRef.current = event.clientX;\n                        }\n                      })\n                    )}\n                  />\n                </RovingFocusGroup.Root>\n              </DismissableLayer>\n            </FocusScope>\n          </MenuContentProvider>\n        </ScrollLockWrapper>\n      </PortalWrapper>\n    );\n  }\n);\n\nMenuContent.displayName = CONTENT_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuGroup\n * -----------------------------------------------------------------------------------------------*/\n\nconst GROUP_NAME = 'MenuGroup';\n\ntype MenuGroupElement = React.ElementRef<typeof Primitive.div>;\ntype PrimitiveDivProps = Radix.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface MenuGroupProps extends PrimitiveDivProps {}\n\nconst MenuGroup = React.forwardRef<MenuGroupElement, MenuGroupProps>(\n  (props: ScopedProps<MenuGroupProps>, forwardedRef) => {\n    const { __scopeMenu, ...groupProps } = props;\n    return <Primitive.div role=\"group\" {...groupProps} ref={forwardedRef} />;\n  }\n);\n\nMenuGroup.displayName = GROUP_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuLabel\n * -----------------------------------------------------------------------------------------------*/\n\nconst LABEL_NAME = 'MenuLabel';\n\ntype MenuLabelElement = React.ElementRef<typeof Primitive.div>;\ninterface MenuLabelProps extends PrimitiveDivProps {}\n\nconst MenuLabel = React.forwardRef<MenuLabelElement, MenuLabelProps>(\n  (props: ScopedProps<MenuLabelProps>, forwardedRef) => {\n    const { __scopeMenu, ...labelProps } = props;\n    return <Primitive.div {...labelProps} ref={forwardedRef} />;\n  }\n);\n\nMenuLabel.displayName = LABEL_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst ITEM_NAME = 'MenuItem';\nconst ITEM_SELECT = 'menu.itemSelect';\n\ntype MenuItemElement = MenuItemImplElement;\ninterface MenuItemProps extends Omit<MenuItemImplProps, 'onSelect'> {\n  onSelect?: (event: Event) => void;\n}\n\nconst MenuItem = React.forwardRef<MenuItemElement, MenuItemProps>(\n  (props: ScopedProps<MenuItemProps>, forwardedRef) => {\n    const { disabled = false, onSelect, ...itemProps } = props;\n    const ref = React.useRef<HTMLDivElement>(null);\n    const context = useMenuContext(ITEM_NAME, props.__scopeMenu);\n    const contentContext = useMenuContentContext(ITEM_NAME, props.__scopeMenu);\n    const composedRefs = useComposedRefs(forwardedRef, ref);\n    const isPointerDownRef = React.useRef(false);\n\n    const handleSelect = () => {\n      const menuItem = ref.current;\n      if (!disabled && menuItem) {\n        const itemSelectEvent = new Event(ITEM_SELECT, { bubbles: true, cancelable: true });\n        menuItem.addEventListener(ITEM_SELECT, (event) => onSelect?.(event), { once: true });\n        menuItem.dispatchEvent(itemSelectEvent);\n        if (itemSelectEvent.defaultPrevented) {\n          isPointerDownRef.current = false;\n        } else {\n          context.onRootClose();\n        }\n      }\n    };\n\n    return (\n      <MenuItemImpl\n        {...itemProps}\n        ref={composedRefs}\n        disabled={disabled}\n        onClick={composeEventHandlers(props.onClick, handleSelect)}\n        onPointerDown={(event) => {\n          props.onPointerDown?.(event);\n          isPointerDownRef.current = true;\n        }}\n        onPointerUp={composeEventHandlers(props.onPointerUp, (event) => {\n          // Pointer down can move to a different menu item which should activate it on pointer up.\n          // We dispatch a click for selection to allow composition with click based triggers and to\n          // prevent Firefox from getting stuck in text selection mode when the menu closes.\n          if (!isPointerDownRef.current) event.currentTarget?.click();\n        })}\n        onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n          const isTypingAhead = contentContext.searchRef.current !== '';\n          if (disabled || (isTypingAhead && event.key === ' ')) return;\n          if (SELECTION_KEYS.includes(event.key)) {\n            event.currentTarget.click();\n            /**\n             * We prevent default browser behaviour for selection keys as they should trigger\n             * a selection only:\n             * - prevents space from scrolling the page.\n             * - if keydown causes focus to move, prevents keydown from firing on the new target.\n             */\n            event.preventDefault();\n          }\n        })}\n      />\n    );\n  }\n);\n\nMenuItem.displayName = ITEM_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuSubTrigger\n * -----------------------------------------------------------------------------------------------*/\n\nconst SUB_TRIGGER_NAME = 'MenuSubTrigger';\n\ntype MenuSubTriggerElement = MenuItemImplElement;\ninterface MenuSubTriggerProps extends MenuItemImplProps {}\n\nconst MenuSubTrigger = React.forwardRef<MenuSubTriggerElement, MenuSubTriggerProps>(\n  (props: ScopedProps<MenuSubTriggerProps>, forwardedRef) => {\n    const context = useMenuContext(SUB_TRIGGER_NAME, props.__scopeMenu);\n    const contentContext = useMenuContentContext(SUB_TRIGGER_NAME, props.__scopeMenu);\n    const openTimerRef = React.useRef<number | null>(null);\n    const { pointerGraceTimerRef, onPointerGraceIntentChange } = contentContext;\n\n    const clearOpenTimer = React.useCallback(() => {\n      if (openTimerRef.current) window.clearTimeout(openTimerRef.current);\n      openTimerRef.current = null;\n    }, []);\n\n    React.useEffect(() => clearOpenTimer, [clearOpenTimer]);\n\n    React.useEffect(() => {\n      const pointerGraceTimer = pointerGraceTimerRef.current;\n      return () => {\n        window.clearTimeout(pointerGraceTimer);\n        onPointerGraceIntentChange(null);\n      };\n    }, [pointerGraceTimerRef, onPointerGraceIntentChange]);\n\n    return context.isSubmenu ? (\n      <MenuAnchor asChild {...props}>\n        <MenuItemImpl\n          id={context.triggerId}\n          aria-haspopup=\"menu\"\n          aria-expanded={context.open}\n          aria-controls={context.contentId}\n          data-state={getOpenState(context.open)}\n          {...props}\n          ref={composeRefs(forwardedRef, context.onTriggerChange)}\n          // This is redundant for mouse users but we cannot determine pointer type from\n          // click event and we cannot use pointerup event (see git history for reasons why)\n          onClick={(event) => {\n            props.onClick?.(event);\n            if (props.disabled || event.defaultPrevented) return;\n            /**\n             * We manually focus because iOS Safari doesn't always focus on click (e.g. buttons)\n             * and we rely heavily on `onFocusOutside` for submenus to close when switching\n             * between separate submenus.\n             */\n            event.currentTarget.focus();\n            if (!context.open) context.onOpenChange(true);\n          }}\n          onPointerMove={composeEventHandlers(\n            props.onPointerMove,\n            whenMouse((event) => {\n              contentContext.onItemEnter(event);\n              if (event.defaultPrevented) return;\n              if (!props.disabled && !context.open && !openTimerRef.current) {\n                contentContext.onPointerGraceIntentChange(null);\n                openTimerRef.current = window.setTimeout(() => {\n                  context.onOpenChange(true);\n                  clearOpenTimer();\n                }, 100);\n              }\n            })\n          )}\n          onPointerLeave={composeEventHandlers(\n            props.onPointerLeave,\n            whenMouse((event) => {\n              clearOpenTimer();\n\n              const contentRect = context.content?.getBoundingClientRect();\n              if (contentRect) {\n                // TODO: make sure to update this when we change positioning logic\n                const side = context.content?.dataset.side as Side;\n                const rightSide = side === 'right';\n                const bleed = rightSide ? -5 : +5;\n                const contentNearEdge = contentRect[rightSide ? 'left' : 'right'];\n                const contentFarEdge = contentRect[rightSide ? 'right' : 'left'];\n\n                contentContext.onPointerGraceIntentChange({\n                  area: [\n                    // Apply a bleed on clientX to ensure that our exit point is\n                    // consistently within polygon bounds\n                    { x: event.clientX + bleed, y: event.clientY },\n                    { x: contentNearEdge, y: contentRect.top },\n                    { x: contentFarEdge, y: contentRect.top },\n                    { x: contentFarEdge, y: contentRect.bottom },\n                    { x: contentNearEdge, y: contentRect.bottom },\n                  ],\n                  side,\n                });\n\n                window.clearTimeout(pointerGraceTimerRef.current);\n                pointerGraceTimerRef.current = window.setTimeout(\n                  () => contentContext.onPointerGraceIntentChange(null),\n                  300\n                );\n              } else {\n                contentContext.onTriggerLeave(event);\n                if (event.defaultPrevented) return;\n\n                // There's 100ms where the user may leave an item before the submenu was opened.\n                contentContext.onPointerGraceIntentChange(null);\n              }\n            })\n          )}\n          onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n            const isTypingAhead = contentContext.searchRef.current !== '';\n            if (props.disabled || (isTypingAhead && event.key === ' ')) return;\n            if (SUB_OPEN_KEYS[context.dir].includes(event.key)) {\n              context.onOpenChange(true);\n              // The trigger may hold focus if opened via pointer interaction\n              // so we ensure content is given focus again when switching to keyboard.\n              context.content?.focus();\n              // prevent window from scrolling\n              event.preventDefault();\n            }\n          })}\n        />\n      </MenuAnchor>\n    ) : null;\n  }\n);\n\nMenuSubTrigger.displayName = SUB_TRIGGER_NAME;\n\n/* ---------------------------------------------------------------------------------------------- */\n\ntype MenuItemImplElement = React.ElementRef<typeof Primitive.div>;\ninterface MenuItemImplProps extends PrimitiveDivProps {\n  disabled?: boolean;\n  textValue?: string;\n}\n\nconst MenuItemImpl = React.forwardRef<MenuItemImplElement, MenuItemImplProps>(\n  (props: ScopedProps<MenuItemImplProps>, forwardedRef) => {\n    const { __scopeMenu, disabled = false, textValue, ...itemProps } = props;\n    const contentContext = useMenuContentContext(ITEM_NAME, __scopeMenu);\n    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeMenu);\n    const ref = React.useRef<HTMLDivElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, ref);\n\n    // get the item's `.textContent` as default strategy for typeahead `textValue`\n    const [textContent, setTextContent] = React.useState('');\n    React.useEffect(() => {\n      const menuItem = ref.current;\n      if (menuItem) {\n        setTextContent((menuItem.textContent ?? '').trim());\n      }\n    }, [itemProps.children]);\n\n    return (\n      <Collection.ItemSlot\n        scope={__scopeMenu}\n        disabled={disabled}\n        textValue={textValue ?? textContent}\n      >\n        <RovingFocusGroup.Item asChild {...rovingFocusGroupScope} focusable={!disabled}>\n          <Primitive.div\n            role=\"menuitem\"\n            aria-disabled={disabled || undefined}\n            data-disabled={disabled ? '' : undefined}\n            {...itemProps}\n            ref={composedRefs}\n            /**\n             * We focus items on `pointerMove` to achieve the following:\n             *\n             * - Mouse over an item (it focuses)\n             * - Leave mouse where it is and use keyboard to focus a different item\n             * - Wiggle mouse without it leaving previously focused item\n             * - Previously focused item should re-focus\n             *\n             * If we used `mouseOver`/`mouseEnter` it would not re-focus when the mouse\n             * wiggles. This is to match native menu implementation.\n             */\n            onPointerMove={composeEventHandlers(\n              props.onPointerMove,\n              whenMouse((event) => {\n                if (disabled) {\n                  contentContext.onItemLeave(event);\n                } else {\n                  contentContext.onItemEnter(event);\n                  if (!event.defaultPrevented) {\n                    const item = event.currentTarget;\n                    item.focus();\n                  }\n                }\n              })\n            )}\n            onPointerLeave={composeEventHandlers(\n              props.onPointerLeave,\n              whenMouse((event) => contentContext.onItemLeave(event))\n            )}\n          />\n        </RovingFocusGroup.Item>\n      </Collection.ItemSlot>\n    );\n  }\n);\n\n/* -------------------------------------------------------------------------------------------------\n * MenuCheckboxItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst CHECKBOX_ITEM_NAME = 'MenuCheckboxItem';\n\ntype MenuCheckboxItemElement = MenuItemElement;\ninterface MenuCheckboxItemProps extends MenuItemProps {\n  checked?: boolean;\n  onCheckedChange?: (checked: boolean) => void;\n}\n\nconst MenuCheckboxItem = React.forwardRef<MenuCheckboxItemElement, MenuCheckboxItemProps>(\n  (props: ScopedProps<MenuCheckboxItemProps>, forwardedRef) => {\n    const { checked = false, onCheckedChange, ...checkboxItemProps } = props;\n    return (\n      <ItemIndicatorProvider scope={props.__scopeMenu} checked={checked}>\n        <MenuItem\n          role=\"menuitemcheckbox\"\n          aria-checked={checked}\n          {...checkboxItemProps}\n          ref={forwardedRef}\n          data-state={getCheckedState(checked)}\n          onSelect={composeEventHandlers(\n            checkboxItemProps.onSelect,\n            () => onCheckedChange?.(!checked),\n            { checkForDefaultPrevented: false }\n          )}\n        />\n      </ItemIndicatorProvider>\n    );\n  }\n);\n\nMenuCheckboxItem.displayName = CHECKBOX_ITEM_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuRadioGroup\n * -----------------------------------------------------------------------------------------------*/\n\nconst RADIO_GROUP_NAME = 'MenuRadioGroup';\n\nconst [RadioGroupProvider, useRadioGroupContext] = createMenuContext<MenuRadioGroupProps>(\n  RADIO_GROUP_NAME,\n  { value: undefined, onValueChange: () => {} }\n);\n\ntype MenuRadioGroupElement = React.ElementRef<typeof MenuGroup>;\ninterface MenuRadioGroupProps extends MenuGroupProps {\n  value?: string;\n  onValueChange?: (value: string) => void;\n}\n\nconst MenuRadioGroup = React.forwardRef<MenuRadioGroupElement, MenuRadioGroupProps>(\n  (props: ScopedProps<MenuRadioGroupProps>, forwardedRef) => {\n    const { value, onValueChange, ...groupProps } = props;\n    const handleValueChange = useCallbackRef(onValueChange);\n    return (\n      <RadioGroupProvider scope={props.__scopeMenu} value={value} onValueChange={handleValueChange}>\n        <MenuGroup {...groupProps} ref={forwardedRef} />\n      </RadioGroupProvider>\n    );\n  }\n);\n\nMenuRadioGroup.displayName = RADIO_GROUP_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuRadioItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst RADIO_ITEM_NAME = 'MenuRadioItem';\n\ntype MenuRadioItemElement = React.ElementRef<typeof MenuItem>;\ninterface MenuRadioItemProps extends MenuItemProps {\n  value: string;\n}\n\nconst MenuRadioItem = React.forwardRef<MenuRadioItemElement, MenuRadioItemProps>(\n  (props: ScopedProps<MenuRadioItemProps>, forwardedRef) => {\n    const { value, ...radioItemProps } = props;\n    const context = useRadioGroupContext(RADIO_ITEM_NAME, props.__scopeMenu);\n    const checked = value === context.value;\n    return (\n      <ItemIndicatorProvider scope={props.__scopeMenu} checked={checked}>\n        <MenuItem\n          role=\"menuitemradio\"\n          aria-checked={checked}\n          {...radioItemProps}\n          ref={forwardedRef}\n          data-state={getCheckedState(checked)}\n          onSelect={composeEventHandlers(\n            radioItemProps.onSelect,\n            () => context.onValueChange?.(value),\n            { checkForDefaultPrevented: false }\n          )}\n        />\n      </ItemIndicatorProvider>\n    );\n  }\n);\n\nMenuRadioItem.displayName = RADIO_ITEM_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuItemIndicator\n * -----------------------------------------------------------------------------------------------*/\n\nconst ITEM_INDICATOR_NAME = 'MenuItemIndicator';\n\nconst [ItemIndicatorProvider, useItemIndicatorContext] = createMenuContext(ITEM_INDICATOR_NAME, {\n  checked: false,\n});\n\ntype MenuItemIndicatorElement = React.ElementRef<typeof Primitive.span>;\ntype PrimitiveSpanProps = Radix.ComponentPropsWithoutRef<typeof Primitive.span>;\ninterface MenuItemIndicatorProps extends PrimitiveSpanProps {\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst MenuItemIndicator = React.forwardRef<MenuItemIndicatorElement, MenuItemIndicatorProps>(\n  (props: ScopedProps<MenuItemIndicatorProps>, forwardedRef) => {\n    const { __scopeMenu, forceMount, ...itemIndicatorProps } = props;\n    const indicatorContext = useItemIndicatorContext(ITEM_INDICATOR_NAME, __scopeMenu);\n    return (\n      <Presence present={forceMount || indicatorContext.checked}>\n        <Primitive.span\n          {...itemIndicatorProps}\n          ref={forwardedRef}\n          data-state={getCheckedState(indicatorContext.checked)}\n        />\n      </Presence>\n    );\n  }\n);\n\nMenuItemIndicator.displayName = ITEM_INDICATOR_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuSeparator\n * -----------------------------------------------------------------------------------------------*/\n\nconst SEPARATOR_NAME = 'MenuSeparator';\n\ntype MenuSeparatorElement = React.ElementRef<typeof Primitive.div>;\ninterface MenuSeparatorProps extends PrimitiveDivProps {}\n\nconst MenuSeparator = React.forwardRef<MenuSeparatorElement, MenuSeparatorProps>(\n  (props: ScopedProps<MenuSeparatorProps>, forwardedRef) => {\n    const { __scopeMenu, ...separatorProps } = props;\n    return (\n      <Primitive.div\n        role=\"separator\"\n        aria-orientation=\"horizontal\"\n        {...separatorProps}\n        ref={forwardedRef}\n      />\n    );\n  }\n);\n\nMenuSeparator.displayName = SEPARATOR_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuArrow\n * -----------------------------------------------------------------------------------------------*/\n\nconst ARROW_NAME = 'MenuArrow';\n\ntype MenuArrowElement = React.ElementRef<typeof PopperPrimitive.Arrow>;\ntype PopperArrowProps = Radix.ComponentPropsWithoutRef<typeof PopperPrimitive.Arrow>;\ninterface MenuArrowProps extends PopperArrowProps {}\n\nconst MenuArrow = React.forwardRef<MenuArrowElement, MenuArrowProps>(\n  (props: ScopedProps<MenuArrowProps>, forwardedRef) => {\n    const { __scopeMenu, ...arrowProps } = props;\n    const popperScope = usePopperScope(__scopeMenu);\n    return <PopperPrimitive.Arrow {...popperScope} {...arrowProps} ref={forwardedRef} />;\n  }\n);\n\nMenuArrow.displayName = ARROW_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\nfunction getOpenState(open: boolean) {\n  return open ? 'open' : 'closed';\n}\n\nfunction getCheckedState(checked: boolean) {\n  return checked ? 'checked' : 'unchecked';\n}\n\nfunction focusFirst(candidates: HTMLElement[]) {\n  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;\n  for (const candidate of candidates) {\n    // if focus is already where we want to go, we don't want to keep going through the candidates\n    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;\n    candidate.focus();\n    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;\n  }\n}\n\n/**\n * Wraps an array around itself at a given start index\n * Example: `wrapArray(['a', 'b', 'c', 'd'], 2) === ['c', 'd', 'a', 'b']`\n */\nfunction wrapArray<T>(array: T[], startIndex: number) {\n  return array.map((_, index) => array[(startIndex + index) % array.length]);\n}\n\n/**\n * This is the \"meat\" of the typeahead matching logic. It takes in all the values,\n * the search and the current match, and returns the next match (or `undefined`).\n *\n * We normalize the search because if a user has repeatedly pressed a character,\n * we want the exact same behavior as if we only had that one character\n * (ie. cycle through options starting with that character)\n *\n * We also reorder the values by wrapping the array around the current match.\n * This is so we always look forward from the current match, and picking the first\n * match will always be the correct one.\n *\n * Finally, if the normalized search is exactly one character, we exclude the\n * current match from the values because otherwise it would be the first to match always\n * and focus would never move. This is as opposed to the regular case, where we\n * don't want focus to move if the current match still matches.\n */\nfunction getNextMatch(values: string[], search: string, currentMatch?: string) {\n  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);\n  const normalizedSearch = isRepeated ? search[0] : search;\n  const currentMatchIndex = currentMatch ? values.indexOf(currentMatch) : -1;\n  let wrappedValues = wrapArray(values, Math.max(currentMatchIndex, 0));\n  const excludeCurrentMatch = normalizedSearch.length === 1;\n  if (excludeCurrentMatch) wrappedValues = wrappedValues.filter((v) => v !== currentMatch);\n  const nextMatch = wrappedValues.find((value) =>\n    value.toLowerCase().startsWith(normalizedSearch.toLowerCase())\n  );\n  return nextMatch !== currentMatch ? nextMatch : undefined;\n}\n\ntype Point = { x: number; y: number };\ntype Polygon = Point[];\ntype Side = 'left' | 'right';\ntype GraceIntent = { area: Polygon; side: Side };\n\n// Determine if a point is inside of a polygon.\n// Based on https://github.com/substack/point-in-polygon\nfunction isPointInPolygon(point: Point, polygon: Polygon) {\n  const { x, y } = point;\n  let inside = false;\n  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n    const xi = polygon[i].x;\n    const yi = polygon[i].y;\n    const xj = polygon[j].x;\n    const yj = polygon[j].y;\n\n    // prettier-ignore\n    const intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);\n    if (intersect) inside = !inside;\n  }\n\n  return inside;\n}\n\nfunction isPointerInGraceArea(event: React.PointerEvent, area?: Polygon) {\n  if (!area) return false;\n  const cursorPos = { x: event.clientX, y: event.clientY };\n  return isPointInPolygon(cursorPos, area);\n}\n\nfunction whenMouse<E>(handler: React.PointerEventHandler<E>): React.PointerEventHandler<E> {\n  return (event) => (event.pointerType === 'mouse' ? handler(event) : undefined);\n}\n\nconst Root = Menu;\nconst Sub = MenuSub;\nconst Anchor = MenuAnchor;\nconst SubTrigger = MenuSubTrigger;\nconst Content = MenuContent;\nconst Group = MenuGroup;\nconst Label = MenuLabel;\nconst Item = MenuItem;\nconst CheckboxItem = MenuCheckboxItem;\nconst RadioGroup = MenuRadioGroup;\nconst RadioItem = MenuRadioItem;\nconst ItemIndicator = MenuItemIndicator;\nconst Separator = MenuSeparator;\nconst Arrow = MenuArrow;\n\nexport {\n  createMenuScope,\n  //\n  Menu,\n  MenuSub,\n  MenuAnchor,\n  MenuSubTrigger,\n  MenuContent,\n  MenuGroup,\n  MenuLabel,\n  MenuItem,\n  MenuCheckboxItem,\n  MenuRadioGroup,\n  MenuRadioItem,\n  MenuItemIndicator,\n  MenuSeparator,\n  MenuArrow,\n  //\n  Root,\n  Sub,\n  Anchor,\n  SubTrigger,\n  Content,\n  Group,\n  Label,\n  Item,\n  CheckboxItem,\n  RadioGroup,\n  RadioItem,\n  ItemIndicator,\n  Separator,\n  Arrow,\n};\nexport type {\n  MenuProps,\n  MenuSubProps,\n  MenuAnchorProps,\n  MenuSubTriggerProps,\n  MenuContentProps,\n  MenuGroupProps,\n  MenuLabelProps,\n  MenuItemProps,\n  MenuCheckboxItemProps,\n  MenuRadioGroupProps,\n  MenuRadioItemProps,\n  MenuItemIndicatorProps,\n  MenuSeparatorProps,\n  MenuArrowProps,\n};\n", "import * as React from 'react';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { composeRefs } from '@radix-ui/react-compose-refs';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport * as MenuPrimitive from '@radix-ui/react-menu';\nimport { createMenuScope } from '@radix-ui/react-menu';\nimport { useId } from '@radix-ui/react-id';\n\nimport type * as Radix from '@radix-ui/react-primitive';\nimport type { Scope } from '@radix-ui/react-context';\n\ntype Direction = 'ltr' | 'rtl';\n\n/* -------------------------------------------------------------------------------------------------\n * DropdownMenu\n * -----------------------------------------------------------------------------------------------*/\n\nconst DROPDOWN_MENU_NAME = 'DropdownMenu';\n\ntype ScopedProps<P> = P & { __scopeDropdownMenu?: Scope };\nconst [createDropdownMenuContext, createDropdownMenuScope] = createContextScope(\n  DROPDOWN_MENU_NAME,\n  [createMenuScope]\n);\nconst useMenuScope = createMenuScope();\n\ntype DropdownMenuRootContextValue = {\n  isRootMenu: true;\n  triggerId: string;\n  triggerRef: React.RefObject<HTMLButtonElement>;\n  contentId: string;\n  open: boolean;\n  onOpenChange(open: boolean): void;\n  onOpenToggle(): void;\n  modal: boolean;\n};\n\ntype DropdownMenuSubContextValue = {\n  isRootMenu: false;\n  open: boolean;\n  onOpenChange(open: boolean): void;\n  onOpenToggle(): void;\n};\n\nconst [DropdownMenuProvider, useDropdownMenuContext] = createDropdownMenuContext<\n  DropdownMenuRootContextValue | DropdownMenuSubContextValue\n>(DROPDOWN_MENU_NAME);\n\ninterface DropdownMenuProps {\n  dir?: Direction;\n  open?: boolean;\n  defaultOpen?: boolean;\n  onOpenChange?(open: boolean): void;\n  modal?: boolean;\n  children?: React.ReactNode;\n}\n\nconst DropdownMenu: React.FC<DropdownMenuProps> = (props: ScopedProps<DropdownMenuProps>) => {\n  const { __scopeDropdownMenu, children, open: openProp, defaultOpen, onOpenChange } = props;\n  const contentContext = useContentContext(DROPDOWN_MENU_NAME, __scopeDropdownMenu);\n  const menuScope = useMenuScope(__scopeDropdownMenu);\n  const [open = false, setOpen] = useControllableState({\n    prop: openProp,\n    defaultProp: defaultOpen,\n    onChange: onOpenChange,\n  });\n\n  const handleOpenToggle = React.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]);\n\n  return contentContext.isInsideContent ? (\n    <DropdownMenuProvider\n      scope={__scopeDropdownMenu}\n      isRootMenu={false}\n      open={open}\n      onOpenChange={setOpen}\n      onOpenToggle={handleOpenToggle}\n    >\n      <MenuPrimitive.Sub {...menuScope} open={open} onOpenChange={setOpen}>\n        {children}\n      </MenuPrimitive.Sub>\n    </DropdownMenuProvider>\n  ) : (\n    <DropdownMenuRoot {...props} open={open} onOpenChange={setOpen} onOpenToggle={handleOpenToggle}>\n      {children}\n    </DropdownMenuRoot>\n  );\n};\n\nDropdownMenu.displayName = DROPDOWN_MENU_NAME;\n\n/* ---------------------------------------------------------------------------------------------- */\n\ninterface DropdownMenuRootProps {\n  dir?: Direction;\n  open: boolean;\n  onOpenChange(open: boolean): void;\n  onOpenToggle(): void;\n  modal?: boolean;\n  children?: React.ReactNode;\n}\n\nconst DropdownMenuRoot: React.FC<DropdownMenuRootProps> = (\n  props: ScopedProps<DropdownMenuRootProps>\n) => {\n  const {\n    __scopeDropdownMenu,\n    children,\n    dir,\n    open,\n    onOpenChange,\n    onOpenToggle,\n    modal = true,\n  } = props;\n  const menuScope = useMenuScope(__scopeDropdownMenu);\n  const triggerRef = React.useRef<HTMLButtonElement>(null);\n  return (\n    <DropdownMenuProvider\n      scope={__scopeDropdownMenu}\n      isRootMenu={true}\n      triggerId={useId()}\n      triggerRef={triggerRef}\n      contentId={useId()}\n      open={open}\n      onOpenChange={onOpenChange}\n      onOpenToggle={onOpenToggle}\n      modal={modal}\n    >\n      <MenuPrimitive.Root\n        {...menuScope}\n        open={open}\n        onOpenChange={onOpenChange}\n        dir={dir}\n        modal={modal}\n      >\n        {children}\n      </MenuPrimitive.Root>\n    </DropdownMenuProvider>\n  );\n};\n\n/* -------------------------------------------------------------------------------------------------\n * DropdownMenuTrigger\n * -----------------------------------------------------------------------------------------------*/\n\nconst TRIGGER_NAME = 'DropdownMenuTrigger';\n\ntype DropdownMenuTriggerElement = React.ElementRef<typeof Primitive.button>;\ntype PrimitiveButtonProps = Radix.ComponentPropsWithoutRef<typeof Primitive.button>;\ninterface DropdownMenuTriggerProps extends PrimitiveButtonProps {}\n\nconst DropdownMenuTrigger = React.forwardRef<DropdownMenuTriggerElement, DropdownMenuTriggerProps>(\n  (props: ScopedProps<DropdownMenuTriggerProps>, forwardedRef) => {\n    const { __scopeDropdownMenu, disabled = false, ...triggerProps } = props;\n    const context = useDropdownMenuContext(TRIGGER_NAME, __scopeDropdownMenu);\n    const menuScope = useMenuScope(__scopeDropdownMenu);\n    return context.isRootMenu ? (\n      <MenuPrimitive.Anchor asChild {...menuScope}>\n        <Primitive.button\n          type=\"button\"\n          id={context.triggerId}\n          aria-haspopup=\"menu\"\n          aria-expanded={context.open ? true : undefined}\n          aria-controls={context.open ? context.contentId : undefined}\n          data-state={context.open ? 'open' : 'closed'}\n          data-disabled={disabled ? '' : undefined}\n          disabled={disabled}\n          {...triggerProps}\n          ref={composeRefs(forwardedRef, context.triggerRef)}\n          // Handle anything that the browser considers a click for the element type if\n          // not using pointer e.g. Space keyup and Enter keydown\n          onClick={composeEventHandlers(props.onClick, () => context.onOpenChange(true))}\n          onPointerDown={composeEventHandlers(props.onPointerDown, (event) => {\n            // only call handler if it's the left button (mousedown gets triggered by all mouse buttons)\n            // but not when the control key is pressed (avoiding MacOS right click)\n            if (!disabled && event.button === 0 && event.ctrlKey === false) {\n              // prevent trigger focusing when opening\n              // this allows the content to be given focus without competition\n              if (!context.open) event.preventDefault();\n              context.onOpenToggle();\n            }\n          })}\n          onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n            if (!disabled && event.key === 'ArrowDown') {\n              event.preventDefault();\n              context.onOpenChange(true);\n            }\n          })}\n        />\n      </MenuPrimitive.Anchor>\n    ) : null;\n  }\n);\n\nDropdownMenuTrigger.displayName = TRIGGER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * DropdownMenuContent\n * -----------------------------------------------------------------------------------------------*/\n\nconst CONTENT_NAME = 'DropdownMenuContent';\n\nconst [ContentProvider, useContentContext] = createDropdownMenuContext(CONTENT_NAME, {\n  isInsideContent: false,\n});\n\ntype DropdownMenuContentElement =\n  | DropdownMenuRootContentElement\n  | React.ElementRef<typeof MenuPrimitive.Content>;\ntype MenuContentProps = Radix.ComponentPropsWithoutRef<typeof MenuPrimitive.Content>;\ninterface DropdownMenuContentProps extends DropdownMenuRootContentProps, MenuContentProps {}\n\nconst DropdownMenuContent = React.forwardRef<DropdownMenuContentElement, DropdownMenuContentProps>(\n  (props: ScopedProps<DropdownMenuContentProps>, forwardedRef) => {\n    const { __scopeDropdownMenu, ...contentProps } = props;\n    const context = useDropdownMenuContext(CONTENT_NAME, __scopeDropdownMenu);\n    const menuScope = useMenuScope(__scopeDropdownMenu);\n    const commonProps = {\n      ...contentProps,\n      style: {\n        ...props.style,\n        // re-namespace exposed content custom property\n        ['--radix-dropdown-menu-content-transform-origin' as any]:\n          'var(--radix-popper-transform-origin)',\n      },\n    };\n\n    return (\n      <ContentProvider scope={__scopeDropdownMenu} isInsideContent={true}>\n        {context.isRootMenu ? (\n          <DropdownMenuRootContent\n            __scopeDropdownMenu={__scopeDropdownMenu}\n            {...commonProps}\n            ref={forwardedRef}\n          />\n        ) : (\n          <MenuPrimitive.Content {...menuScope} {...commonProps} ref={forwardedRef} />\n        )}\n      </ContentProvider>\n    );\n  }\n);\n\nDropdownMenuContent.displayName = CONTENT_NAME;\n\n/* ---------------------------------------------------------------------------------------------- */\n\ntype DropdownMenuRootContentElement = React.ElementRef<typeof MenuPrimitive.Content>;\ninterface DropdownMenuRootContentProps extends ScopedProps<MenuContentProps> {}\n\nconst DropdownMenuRootContent = React.forwardRef<\n  DropdownMenuRootContentElement,\n  DropdownMenuRootContentProps\n>((props, forwardedRef) => {\n  const { __scopeDropdownMenu, portalled = true, ...contentProps } = props;\n  const context = useDropdownMenuContext(CONTENT_NAME, __scopeDropdownMenu);\n  const menuScope = useMenuScope(__scopeDropdownMenu);\n  const hasInteractedOutsideRef = React.useRef(false);\n\n  return context.isRootMenu ? (\n    <MenuPrimitive.Content\n      id={context.contentId}\n      aria-labelledby={context.triggerId}\n      {...menuScope}\n      {...contentProps}\n      ref={forwardedRef}\n      portalled={portalled}\n      onCloseAutoFocus={(event) => {\n        props.onCloseAutoFocus?.(event);\n\n        if (!event.defaultPrevented) {\n          if (!hasInteractedOutsideRef.current) context.triggerRef.current?.focus();\n          // Always prevent auto focus because we either focus manually or want user agent focus\n          event.preventDefault();\n        }\n\n        hasInteractedOutsideRef.current = false;\n      }}\n      onInteractOutside={(event) => {\n        props.onInteractOutside?.(event);\n\n        if (!event.defaultPrevented) {\n          const originalEvent = event.detail.originalEvent as PointerEvent;\n          const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;\n          const isRightClick = originalEvent.button === 2 || ctrlLeftClick;\n\n          if (!context.modal || isRightClick) hasInteractedOutsideRef.current = true;\n        }\n\n        // Prevent dismissing when clicking the trigger.\n        // As the trigger is already setup to close, without doing so would\n        // cause it to close and immediately open.\n        //\n        // We use `onInteractOutside` as some browsers also\n        // focus on pointer down, creating the same issue.\n        const target = event.target as HTMLElement;\n        const targetIsTrigger = context.triggerRef.current?.contains(target);\n        if (targetIsTrigger) event.preventDefault();\n      }}\n    />\n  ) : null;\n});\n\n/* -------------------------------------------------------------------------------------------------\n * DropdownMenuGroup\n * -----------------------------------------------------------------------------------------------*/\n\nconst GROUP_NAME = 'DropdownMenuGroup';\n\ntype DropdownMenuGroupElement = React.ElementRef<typeof MenuPrimitive.Group>;\ntype MenuGroupProps = Radix.ComponentPropsWithoutRef<typeof MenuPrimitive.Group>;\ninterface DropdownMenuGroupProps extends MenuGroupProps {}\n\nconst DropdownMenuGroup = React.forwardRef<DropdownMenuGroupElement, DropdownMenuGroupProps>(\n  (props: ScopedProps<DropdownMenuGroupProps>, forwardedRef) => {\n    const { __scopeDropdownMenu, ...groupProps } = props;\n    const menuScope = useMenuScope(__scopeDropdownMenu);\n    return <MenuPrimitive.Group {...menuScope} {...groupProps} ref={forwardedRef} />;\n  }\n);\n\nDropdownMenuGroup.displayName = GROUP_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * DropdownMenuLabel\n * -----------------------------------------------------------------------------------------------*/\n\nconst LABEL_NAME = 'DropdownMenuLabel';\n\ntype DropdownMenuLabelElement = React.ElementRef<typeof MenuPrimitive.Label>;\ntype MenuLabelProps = Radix.ComponentPropsWithoutRef<typeof MenuPrimitive.Label>;\ninterface DropdownMenuLabelProps extends MenuLabelProps {}\n\nconst DropdownMenuLabel = React.forwardRef<DropdownMenuLabelElement, DropdownMenuLabelProps>(\n  (props: ScopedProps<DropdownMenuLabelProps>, forwardedRef) => {\n    const { __scopeDropdownMenu, ...labelProps } = props;\n    const menuScope = useMenuScope(__scopeDropdownMenu);\n    return <MenuPrimitive.Label {...menuScope} {...labelProps} ref={forwardedRef} />;\n  }\n);\n\nDropdownMenuLabel.displayName = LABEL_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * DropdownMenuItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst ITEM_NAME = 'DropdownMenuItem';\n\ntype DropdownMenuItemElement = React.ElementRef<typeof MenuPrimitive.Item>;\ntype MenuItemProps = Radix.ComponentPropsWithoutRef<typeof MenuPrimitive.Item>;\ninterface DropdownMenuItemProps extends MenuItemProps {}\n\nconst DropdownMenuItem = React.forwardRef<DropdownMenuItemElement, DropdownMenuItemProps>(\n  (props: ScopedProps<DropdownMenuItemProps>, forwardedRef) => {\n    const { __scopeDropdownMenu, ...itemProps } = props;\n    const menuScope = useMenuScope(__scopeDropdownMenu);\n    return <MenuPrimitive.Item {...menuScope} {...itemProps} ref={forwardedRef} />;\n  }\n);\n\nDropdownMenuItem.displayName = ITEM_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * DropdownMenuTriggerItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst TRIGGER_ITEM_NAME = 'DropdownMenuTriggerItem';\n\ntype DropdownMenuTriggerItemElement = React.ElementRef<typeof MenuPrimitive.SubTrigger>;\ntype MenuSubTriggerProps = Radix.ComponentPropsWithoutRef<typeof MenuPrimitive.SubTrigger>;\ninterface DropdownMenuTriggerItemProps extends MenuSubTriggerProps {}\n\nconst DropdownMenuTriggerItem = React.forwardRef<\n  DropdownMenuTriggerItemElement,\n  DropdownMenuTriggerItemProps\n>((props: ScopedProps<DropdownMenuTriggerItemProps>, forwardedRef) => {\n  const { __scopeDropdownMenu, ...triggerItemProps } = props;\n  const menuScope = useMenuScope(__scopeDropdownMenu);\n  return <MenuPrimitive.SubTrigger {...menuScope} {...triggerItemProps} ref={forwardedRef} />;\n});\n\nDropdownMenuTriggerItem.displayName = TRIGGER_ITEM_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * DropdownMenuCheckboxItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst CHECKBOX_ITEM_NAME = 'DropdownMenuCheckboxItem';\n\ntype DropdownMenuCheckboxItemElement = React.ElementRef<typeof MenuPrimitive.CheckboxItem>;\ntype MenuCheckboxItemProps = Radix.ComponentPropsWithoutRef<typeof MenuPrimitive.CheckboxItem>;\ninterface DropdownMenuCheckboxItemProps extends MenuCheckboxItemProps {}\n\nconst DropdownMenuCheckboxItem = React.forwardRef<\n  DropdownMenuCheckboxItemElement,\n  DropdownMenuCheckboxItemProps\n>((props: ScopedProps<DropdownMenuCheckboxItemProps>, forwardedRef) => {\n  const { __scopeDropdownMenu, ...checkboxItemProps } = props;\n  const menuScope = useMenuScope(__scopeDropdownMenu);\n  return <MenuPrimitive.CheckboxItem {...menuScope} {...checkboxItemProps} ref={forwardedRef} />;\n});\n\nDropdownMenuCheckboxItem.displayName = CHECKBOX_ITEM_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * DropdownMenuRadioGroup\n * -----------------------------------------------------------------------------------------------*/\n\nconst RADIO_GROUP_NAME = 'DropdownMenuRadioGroup';\n\ntype DropdownMenuRadioGroupElement = React.ElementRef<typeof MenuPrimitive.RadioGroup>;\ntype MenuRadioGroupProps = Radix.ComponentPropsWithoutRef<typeof MenuPrimitive.RadioGroup>;\ninterface DropdownMenuRadioGroupProps extends MenuRadioGroupProps {}\n\nconst DropdownMenuRadioGroup = React.forwardRef<\n  DropdownMenuRadioGroupElement,\n  DropdownMenuRadioGroupProps\n>((props: ScopedProps<DropdownMenuRadioGroupProps>, forwardedRef) => {\n  const { __scopeDropdownMenu, ...radioGroupProps } = props;\n  const menuScope = useMenuScope(__scopeDropdownMenu);\n  return <MenuPrimitive.RadioGroup {...menuScope} {...radioGroupProps} ref={forwardedRef} />;\n});\n\nDropdownMenuRadioGroup.displayName = RADIO_GROUP_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * DropdownMenuRadioItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst RADIO_ITEM_NAME = 'DropdownMenuRadioItem';\n\ntype DropdownMenuRadioItemElement = React.ElementRef<typeof MenuPrimitive.RadioItem>;\ntype MenuRadioItemProps = Radix.ComponentPropsWithoutRef<typeof MenuPrimitive.RadioItem>;\ninterface DropdownMenuRadioItemProps extends MenuRadioItemProps {}\n\nconst DropdownMenuRadioItem = React.forwardRef<\n  DropdownMenuRadioItemElement,\n  DropdownMenuRadioItemProps\n>((props: ScopedProps<DropdownMenuRadioItemProps>, forwardedRef) => {\n  const { __scopeDropdownMenu, ...radioItemProps } = props;\n  const menuScope = useMenuScope(__scopeDropdownMenu);\n  return <MenuPrimitive.RadioItem {...menuScope} {...radioItemProps} ref={forwardedRef} />;\n});\n\nDropdownMenuRadioItem.displayName = RADIO_ITEM_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * DropdownMenuItemIndicator\n * -----------------------------------------------------------------------------------------------*/\n\nconst INDICATOR_NAME = 'DropdownMenuItemIndicator';\n\ntype DropdownMenuItemIndicatorElement = React.ElementRef<typeof MenuPrimitive.ItemIndicator>;\ntype MenuItemIndicatorProps = Radix.ComponentPropsWithoutRef<typeof MenuPrimitive.ItemIndicator>;\ninterface DropdownMenuItemIndicatorProps extends MenuItemIndicatorProps {}\n\nconst DropdownMenuItemIndicator = React.forwardRef<\n  DropdownMenuItemIndicatorElement,\n  DropdownMenuItemIndicatorProps\n>((props: ScopedProps<DropdownMenuItemIndicatorProps>, forwardedRef) => {\n  const { __scopeDropdownMenu, ...itemIndicatorProps } = props;\n  const menuScope = useMenuScope(__scopeDropdownMenu);\n  return <MenuPrimitive.ItemIndicator {...menuScope} {...itemIndicatorProps} ref={forwardedRef} />;\n});\n\nDropdownMenuItemIndicator.displayName = INDICATOR_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * DropdownMenuSeparator\n * -----------------------------------------------------------------------------------------------*/\n\nconst SEPARATOR_NAME = 'DropdownMenuSeparator';\n\ntype DropdownMenuSeparatorElement = React.ElementRef<typeof MenuPrimitive.Separator>;\ntype MenuSeparatorProps = Radix.ComponentPropsWithoutRef<typeof MenuPrimitive.Separator>;\ninterface DropdownMenuSeparatorProps extends MenuSeparatorProps {}\n\nconst DropdownMenuSeparator = React.forwardRef<\n  DropdownMenuSeparatorElement,\n  DropdownMenuSeparatorProps\n>((props: ScopedProps<DropdownMenuSeparatorProps>, forwardedRef) => {\n  const { __scopeDropdownMenu, ...separatorProps } = props;\n  const menuScope = useMenuScope(__scopeDropdownMenu);\n  return <MenuPrimitive.Separator {...menuScope} {...separatorProps} ref={forwardedRef} />;\n});\n\nDropdownMenuSeparator.displayName = SEPARATOR_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * DropdownMenuArrow\n * -----------------------------------------------------------------------------------------------*/\n\nconst ARROW_NAME = 'DropdownMenuArrow';\n\ntype DropdownMenuArrowElement = React.ElementRef<typeof MenuPrimitive.Arrow>;\ntype MenuArrowProps = Radix.ComponentPropsWithoutRef<typeof MenuPrimitive.Arrow>;\ninterface DropdownMenuArrowProps extends MenuArrowProps {}\n\nconst DropdownMenuArrow = React.forwardRef<DropdownMenuArrowElement, DropdownMenuArrowProps>(\n  (props: ScopedProps<DropdownMenuArrowProps>, forwardedRef) => {\n    const { __scopeDropdownMenu, ...arrowProps } = props;\n    const menuScope = useMenuScope(__scopeDropdownMenu);\n    return <MenuPrimitive.Arrow {...menuScope} {...arrowProps} ref={forwardedRef} />;\n  }\n);\n\nDropdownMenuArrow.displayName = ARROW_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\nconst Root = DropdownMenu;\nconst Trigger = DropdownMenuTrigger;\nconst Content = DropdownMenuContent;\nconst Group = DropdownMenuGroup;\nconst Label = DropdownMenuLabel;\nconst Item = DropdownMenuItem;\nconst TriggerItem = DropdownMenuTriggerItem;\nconst CheckboxItem = DropdownMenuCheckboxItem;\nconst RadioGroup = DropdownMenuRadioGroup;\nconst RadioItem = DropdownMenuRadioItem;\nconst ItemIndicator = DropdownMenuItemIndicator;\nconst Separator = DropdownMenuSeparator;\nconst Arrow = DropdownMenuArrow;\n\nexport {\n  createDropdownMenuScope,\n  //\n  DropdownMenu,\n  DropdownMenuTrigger,\n  DropdownMenuContent,\n  DropdownMenuGroup,\n  DropdownMenuLabel,\n  DropdownMenuItem,\n  DropdownMenuTriggerItem,\n  DropdownMenuCheckboxItem,\n  DropdownMenuRadioGroup,\n  DropdownMenuRadioItem,\n  DropdownMenuItemIndicator,\n  DropdownMenuSeparator,\n  DropdownMenuArrow,\n  //\n  Root,\n  Trigger,\n  Content,\n  Group,\n  Label,\n  Item,\n  TriggerItem,\n  CheckboxItem,\n  RadioGroup,\n  RadioItem,\n  ItemIndicator,\n  Separator,\n  Arrow,\n};\nexport type {\n  DropdownMenuProps,\n  DropdownMenuTriggerProps,\n  DropdownMenuContentProps,\n  DropdownMenuGroupProps,\n  DropdownMenuLabelProps,\n  DropdownMenuItemProps,\n  DropdownMenuTriggerItemProps,\n  DropdownMenuCheckboxItemProps,\n  DropdownMenuRadioGroupProps,\n  DropdownMenuRadioItemProps,\n  DropdownMenuItemIndicatorProps,\n  DropdownMenuSeparatorProps,\n  DropdownMenuArrowProps,\n};\n"],
  "mappings": "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",
  "names": ["useReactId", "React", "toString", "count", "useId", "deterministicId", "id", "setId", "useState", "useLayoutEffect", "reactId", "String", "useDirection", "element", "directionProp", "direction", "setDirection", "useState", "computedStyle", "setComputedStyle", "rAFRef", "useRef", "useEffect", "parentElement", "getComputedStyle", "getDirection", "current", "requestAnimationFrame", "dir", "cancelAnimationFrame", "Primitive", "reduce", "primitive", "node", "forwardRef", "props", "forwardedRef", "asChild", "primitiveProps", "Comp", "Slot", "useEffect", "window", "Symbol", "for", "as", "console", "error", "AS_ERROR", "createElement", "_babelRuntimeHelpersEsmExtends", "ref", "createCollection", "name", "PROVIDER_NAME", "createCollectionContext", "createCollectionScope", "createContextScope", "CollectionProviderImpl", "useCollectionContext", "collectionRef", "current", "itemMap", "Map", "CollectionProvider", "props", "scope", "children", "ref", "React", "useRef", "_react", "createElement", "COLLECTION_SLOT_NAME", "CollectionSlot", "forwardRef", "forwardedRef", "context", "composedRefs", "useComposedRefs", "Slot", "ITEM_SLOT_NAME", "ITEM_DATA_ATTR", "CollectionItemSlot", "itemData", "useEffect", "set", "delete", "Provider", "ItemSlot", "useCallback", "collectionNode", "orderedNodes", "Array", "from", "querySelectorAll", "values", "sort", "a", "b", "indexOf", "EVENT_OPTIONS", "bubbles", "cancelable", "Collection", "useCollection", "createCollectionScope", "createCollection", "createRovingFocusGroupContext", "createRovingFocusGroupScope", "createContextScope", "RovingFocusProvider", "useRovingFocusContext", "createRovingFocusGroupContext", "RovingFocusGroup", "forwardRef", "props", "forwardedRef", "createElement", "$aa7392b6d04813384a511e60e09$var$Collection", "Provider", "scope", "__scopeRovingFocusGroup", "Slot", "$aa7392b6d04813384a511e60e09$var$RovingFocusGroupImpl", "_babelRuntimeHelpersEsmExtends", "ref", "RovingFocusGroupImpl", "orientation", "dir", "loop", "currentTabStopId", "currentTabStopIdProp", "defaultCurrentTabStopId", "onCurrentTabStopIdChange", "onEntryFocus", "groupProps", "useRef", "composedRefs", "useComposedRefs", "setCurrentTabStopId", "useControllableState", "prop", "defaultProp", "onChange", "isTabbingBackOut", "setIsTabbingBackOut", "useState", "handleEntryFocus", "useCallbackRef", "getItems", "useCollection", "isClickFocusRef", "useEffect", "node", "current", "addEventListener", "removeEventListener", "$aa7392b6d04813384a511e60e09$var$RovingFocusProvider", "onItemFocus", "useCallback", "tabStopId", "onItemShiftTab", "Primitive", "div", "tabIndex", "style", "outline", "onMouseDown", "composeEventHandlers", "onFocus", "event", "isKeyboardFocus", "target", "currentTarget", "entryFocusEvent", "Event", "EVENT_OPTIONS", "dispatchEvent", "defaultPrevented", "items", "filter", "item", "focusable", "focusFirst", "find", "active", "id", "Boolean", "map", "onBlur", "RovingFocusGroupItem", "itemProps", "useId", "context", "isCurrentTabStop", "ItemSlot", "span", "preventDefault", "onKeyDown", "key", "shiftKey", "focusIntent", "includes", "MAP_KEY_TO_FOCUS_INTENT", "candidateNodes", "reverse", "currentIndex", "indexOf", "startIndex", "array", "_", "index", "length", "slice", "setTimeout", "ArrowLeft", "ArrowUp", "ArrowRight", "ArrowDown", "PageUp", "Home", "PageDown", "End", "candidates", "PREVIOUSLY_FOCUSED_ELEMENT", "document", "activeElement", "candidate", "focus", "Root", "Item", "Portal", "forwardRef", "props", "forwardedRef", "_containerRef$current", "_globalThis$document", "containerRef", "style", "portalProps", "hostElement", "current", "globalThis", "document", "body", "forceUpdate", "useState", "useLayoutEffect", "ReactDOM", "createPortal", "createElement", "Primitive", "div", "_babelRuntimeHelpersEsmExtends", "ref", "position", "top", "left", "zIndex", "undefined", "UnstablePortal", "_globalThis$document2", "container", "Arrow", "forwardRef", "props", "forwardedRef", "children", "width", "height", "arrowProps", "createElement", "Primitive", "svg", "_babelRuntimeHelpersEsmExtends", "ref", "viewBox", "preserveAspectRatio", "asChild", "points", "Root", "useSize", "element", "size", "setSize", "useState", "undefined", "useEffect", "resizeObserver", "ResizeObserver", "entries", "Array", "isArray", "length", "entry", "width", "height", "borderSizeEntry", "borderSize", "rect", "getBoundingClientRect", "observe", "box", "unobserve", "observeElementRect", "elementToObserve", "callback", "observedData", "observedElements", "get", "set", "rect", "callbacks", "size", "rafId", "requestAnimationFrame", "runLoop", "push", "getBoundingClientRect", "index", "indexOf", "splice", "length", "delete", "cancelAnimationFrame", "Map", "changedRectsData", "forEach", "data", "element", "newRect", "rect1", "rect2", "width", "height", "top", "right", "bottom", "left", "useRect", "measurable", "rect", "setRect", "useState", "useEffect", "unobserve", "observeElementRect", "undefined", "getPlacementData", "anchorRect", "popperSize", "arrowSize", "arrowOffset", "side", "sideOffset", "align", "alignOffset", "shouldAvoidCollisions", "collisionBoundariesRect", "collisionTolerance", "popperStyles", "UNMEASURED_POPPER_STYLES", "arrowStyles", "UNMEASURED_ARROW_STYLES", "allPlacementPoints", "arrowBaseToTipLength", "height", "x", "getPopperSlotsForAxis", "y", "topY", "before", "bottomY", "after", "leftX", "rightX", "top", "start", "center", "end", "right", "bottom", "left", "popperPoint", "getPlacementStylesForPoint", "getPopperArrowStyles", "getTransformOrigin", "placedSide", "placedAlign", "popperRect", "DOMRect", "fromRect", "collisionBoundariesRectWithTolerance", "rect", "amount", "width", "popperCollisions", "getCollisions", "oppositeSidePopperPoint", "getOppositeSide", "collisions", "oppositeSideCollisions", "oppositeSide", "anchorSize", "isHorizontalSide", "startBound", "endBound", "dimension", "isAnchorBigger", "axis", "anchorStart", "anchorDimension", "popperDimension", "point", "position", "minWidth", "willChange", "transform", "Math", "round", "window", "scrollX", "scrollY", "arrowBaseLength", "opacity", "popperCenterX", "popperCenterY", "rotation", "arrowMaxDimension", "max", "styles", "direction", "getArrowCssDirection", "createPopperContext", "createPopperScope", "createContextScope", "PopperProvider", "usePopperContext", "createPopperContext", "Popper", "props", "__scopePopper", "children", "anchor", "setAnchor", "useState", "createElement", "$d4fb2a15a6483a4f85af0f96fd68687d$var$PopperProvider", "scope", "onAnchorChange", "PopperAnchor", "forwardRef", "forwardedRef", "virtualRef", "anchorProps", "context", "ref", "useRef", "composedRefs", "useComposedRefs", "useEffect", "current", "Primitive", "div", "_babelRuntimeHelpersEsmExtends", "PopperContentProvider", "useContentContext", "PopperContent", "side", "sideOffset", "align", "alignOffset", "collisionTolerance", "avoidCollisions", "contentProps", "arrowOffset", "setArrowOffset", "anchorRect", "useRect", "content", "setContent", "contentSize", "useSize", "arrow", "setArrow", "arrowSize", "node", "windowSize", "setWindowSize", "undefined", "debounceTimerId", "updateWindowSize", "width", "window", "innerWidth", "height", "innerHeight", "handleResize", "clearTimeout", "setTimeout", "addEventListener", "removeEventListener", "useWindowSize", "collisionBoundariesRect", "DOMRect", "fromRect", "x", "y", "popperStyles", "arrowStyles", "placedSide", "placedAlign", "getPlacementData", "popperSize", "shouldAvoidCollisions", "isPlaced", "style", "$d4fb2a15a6483a4f85af0f96fd68687d$var$PopperContentProvider", "onArrowChange", "onArrowOffsetChange", "animation", "PopperArrow", "offset", "arrowProps", "pointerEvents", "display", "verticalAlign", "Root", "Anchor", "Content", "Arrow", "EVENT_OPTIONS", "bubbles", "cancelable", "FocusScope", "forwardRef", "props", "forwardedRef", "loop", "trapped", "onMountAutoFocus", "onMountAutoFocusProp", "onUnmountAutoFocus", "onUnmountAutoFocusProp", "scopeProps", "container", "setContainer", "useState", "useCallbackRef", "lastFocusedElementRef", "useRef", "composedRefs", "useComposedRefs", "node", "focusScope", "paused", "pause", "this", "resume", "current", "React", "useEffect", "handleFocusIn", "event", "target", "contains", "focus", "select", "handleFocusOut", "relatedTarget", "document", "addEventListener", "removeEventListener", "focusScopesStack", "add", "previouslyFocusedElement", "activeElement", "mountEvent", "Event", "dispatchEvent", "defaultPrevented", "candidates", "candidate", "items", "getTabbableCandidates", "filter", "item", "tagName", "setTimeout", "unmountEvent", "body", "remove", "handleKeyDown", "useCallback", "isTabKey", "key", "altKey", "ctrlKey", "metaKey", "focusedElement", "currentTarget", "first", "last", "findVisible", "reverse", "shiftKey", "preventDefault", "createElement", "Primitive", "div", "_babelRuntimeHelpersEsmExtends", "tabIndex", "ref", "onKeyDown", "nodes", "walker", "createTreeWalker", "NodeFilter", "SHOW_ELEMENT", "acceptNode", "isHiddenInput", "type", "disabled", "hidden", "FILTER_SKIP", "FILTER_ACCEPT", "nextNode", "push", "currentNode", "elements", "element", "isHidden", "upTo", "getComputedStyle", "visibility", "display", "parentElement", "preventScroll", "HTMLInputElement", "stack", "activeFocusScope", "arrayRemove", "unshift", "_stack$", "createFocusScopesStack", "array", "updatedArray", "index", "indexOf", "splice", "TotalLayerCountProvider", "useTotalLayerCount", "createTotalLayerCount", "RunningLayerCountProvider", "usePreviousRunningLayerCount", "createRunningLayerCount", "TotalLayerCountWithDisabledOutsidePointerEventsProvider", "useTotalLayerCountWithDisabledOutsidePointerEvents", "RunningLayerCountWithDisabledOutsidePointerEventsProvider", "usePreviousRunningLayerCountWithDisabledOutsidePointerEvents", "DismissableLayer", "forwardRef", "props", "forwardedRef", "isRootLayer", "layer", "createElement", "$b3ca5e0c42ec5d7395c8cb24157$var$DismissableLayerImpl", "_babelRuntimeHelpersEsmExtends", "ref", "$b3ca5e0c42ec5d7395c8cb24157$var$TotalLayerCountProvider", "$b3ca5e0c42ec5d7395c8cb24157$var$TotalLayerCountWithDisabledOutsidePointerEventsProvider", "DismissableLayerImpl", "disableOutsidePointerEvents", "onEscapeKeyDown", "onPointerDownOutside", "onFocusOutside", "onInteractOutside", "onDismiss", "layerProps", "totalLayerCount", "runningLayerCount", "isDeepestLayer", "totalLayerCountWithDisabledOutsidePointerEvents", "runningLayerCountWithDisabledOutsidePointerEvents", "containsChildLayerWithDisabledOutsidePointerEvents", "useBodyPointerEvents", "disabled", "useEscapeKeydown", "event", "defaultPrevented", "onPointerDownCapture", "handlePointerDownCapture", "handlePointerDownOutside", "useCallbackRef", "isPointerInsideReactTreeRef", "useRef", "useEffect", "handlePointerDown", "target", "current", "pointerDownOutsideEvent", "CustomEvent", "bubbles", "cancelable", "detail", "originalEvent", "addEventListener", "once", "dispatchEvent", "timerId", "window", "setTimeout", "document", "clearTimeout", "removeEventListener", "onBlurCapture", "handleBlurCapture", "onFocusCapture", "handleFocusCapture", "handleFocusOutside", "isFocusInsideReactTreeRef", "handleFocus", "focusOutsideEvent", "shouldReEnablePointerEvents", "$b3ca5e0c42ec5d7395c8cb24157$var$RunningLayerCountProvider", "runningCount", "$b3ca5e0c42ec5d7395c8cb24157$var$RunningLayerCountWithDisabledOutsidePointerEventsProvider", "Primitive", "div", "style", "pointerEvents", "undefined", "composeEventHandlers", "displayName", "TotalLayerCountProviderImpl", "useTotalLayerCountContext", "createContext", "total", "onTotalIncrease", "onTotalDecrease", "children", "setTotal", "useState", "useCallback", "n", "counted", "useLayoutEffect", "RunningLayerCountProviderImp", "useRunningLayerCount", "count", "SELECTION_KEYS", "LAST_KEYS", "FIRST_LAST_KEYS", "SUB_OPEN_KEYS", "ltr", "rtl", "SUB_CLOSE_KEYS", "Collection", "useCollection", "createCollectionScope", "createCollection", "createMenuContext", "createMenuScope", "createContextScope", "createPopperScope", "createRovingFocusGroupScope", "usePopperScope", "createPopperScope", "useRovingFocusGroupScope", "createRovingFocusGroupScope", "MenuProvider", "useMenuContext", "createMenuContext", "Menu", "props", "__scopeMenu", "open", "children", "onOpenChange", "modal", "popperScope", "content", "setContent", "useState", "isUsingKeyboardRef", "useRef", "handleOpenChange", "useCallbackRef", "computedDirection", "useDirection", "dir", "useEffect", "handleKeyDown", "current", "handlePointer", "document", "addEventListener", "capture", "removeEventListener", "createElement", "Root", "$e9e2cf92950df0b951e7bac95d18$var$MenuProvider", "scope", "isSubmenu", "onContentChange", "onRootClose", "useCallback", "MenuSub", "parentMenuContext", "trigger", "setTrigger", "contentId", "useId", "onTriggerChange", "triggerId", "MenuAnchor", "forwardRef", "forwardedRef", "anchorProps", "Anchor", "_babelRuntimeHelpersEsmExtends", "ref", "MenuContentProvider", "useMenuContentContext", "MenuContent", "forceMount", "contentProps", "context", "$e9e2cf92950df0b951e7bac95d18$var$Collection", "Provider", "Presence", "present", "Slot", "$e9e2cf92950df0b951e7bac95d18$var$MenuSubContent", "$e9e2cf92950df0b951e7bac95d18$var$MenuRootContent", "MenuRootContent", "$e9e2cf92950df0b951e7bac95d18$var$MenuRootContentModal", "$e9e2cf92950df0b951e7bac95d18$var$MenuRootContentNonModal", "MenuRootContentModal", "composedRefs", "useComposedRefs", "hideOthers", "$e9e2cf92950df0b951e7bac95d18$var$MenuContentImpl", "trapFocus", "disableOutsidePointerEvents", "disableOutsideScroll", "onFocusOutside", "composeEventHandlers", "event", "preventDefault", "checkForDefaultPrevented", "onDismiss", "MenuRootContentNonModal", "MenuSubContent", "id", "align", "side", "portalled", "onOpenAutoFocus", "_ref$current", "focus", "onCloseAutoFocus", "target", "onEscapeKeyDown", "onKeyDown", "isKeyDownInside", "currentTarget", "contains", "isCloseKey", "SUB_CLOSE_KEYS", "includes", "key", "_context$trigger", "MenuContentImpl", "loop", "onPointerDownOutside", "onInteractOutside", "allowPinchZoom", "rovingFocusGroupScope", "getItems", "useCollection", "currentItemId", "setCurrentItemId", "contentRef", "timerRef", "searchRef", "pointerGraceTimerRef", "pointerGraceIntentRef", "pointerDirRef", "lastPointerXRef", "PortalWrapper", "Portal", "Fragment", "ScrollLockWrapper", "RemoveScroll", "scrollLockWrapperProps", "handleTypeaheadSearch", "_items$find", "_items$find2", "search", "items", "filter", "item", "disabled", "currentItem", "activeElement", "currentMatch", "find", "textValue", "nextMatch", "values", "normalizedSearch", "length", "Array", "from", "every", "char", "currentMatchIndex", "indexOf", "wrappedValues", "array", "startIndex", "Math", "max", "map", "_", "index", "v", "value", "toLowerCase", "startsWith", "undefined", "newItem", "updateSearch", "window", "clearTimeout", "setTimeout", "React", "useFocusGuards", "isPointerMovingToSubmenu", "_pointerGraceIntentRe", "_pointerGraceIntentRe2", "area", "point", "polygon", "x", "y", "inside", "i", "j", "xi", "yi", "xj", "yj", "clientX", "clientY", "$e9e2cf92950df0b951e7bac95d18$var$MenuContentProvider", "onItemEnter", "onItemLeave", "_contentRef$current", "onTriggerLeave", "onPointerGraceIntentChange", "intent", "FocusScope", "asChild", "trapped", "onMountAutoFocus", "_contentRef$current2", "onUnmountAutoFocus", "DismissableLayer", "orientation", "currentTabStopId", "onCurrentTabStopIdChange", "onEntryFocus", "Content", "role", "getOpenState", "style", "outline", "isModifierKey", "ctrlKey", "altKey", "metaKey", "FIRST_LAST_KEYS", "candidateNodes", "LAST_KEYS", "reverse", "candidates", "PREVIOUSLY_FOCUSED_ELEMENT", "candidate", "onBlur", "onPointerMove", "whenMouse", "pointerXHasChanged", "newDir", "MenuGroup", "groupProps", "Primitive", "div", "MenuLabel", "labelProps", "MenuItem", "onSelect", "itemProps", "contentContext", "isPointerDownRef", "$e9e2cf92950df0b951e7bac95d18$var$MenuItemImpl", "onClick", "menuItem", "itemSelectEvent", "Event", "bubbles", "cancelable", "once", "dispatchEvent", "defaultPrevented", "onPointerDown", "_props$onPointerDown", "call", "onPointerUp", "_event$currentTarget", "click", "isTypingAhead", "SELECTION_KEYS", "MenuSubTrigger", "openTimerRef", "clearOpenTimer", "pointerGraceTimer", "composeRefs", "_props$onClick", "onPointerLeave", "_context$content", "contentRect", "getBoundingClientRect", "_context$content2", "dataset", "rightSide", "bleed", "contentNearEdge", "contentFarEdge", "top", "bottom", "_context$content3", "SUB_OPEN_KEYS", "MenuItemImpl", "textContent", "setTextContent", "_menuItem$textContent", "trim", "ItemSlot", "Item", "focusable", "MenuCheckboxItem", "checked", "onCheckedChange", "checkboxItemProps", "$e9e2cf92950df0b951e7bac95d18$var$ItemIndicatorProvider", "getCheckedState", "RadioGroupProvider", "useRadioGroupContext", "onValueChange", "MenuRadioGroup", "handleValueChange", "$e9e2cf92950df0b951e7bac95d18$var$RadioGroupProvider", "MenuRadioItem", "radioItemProps", "_context$onValueChang", "ItemIndicatorProvider", "useItemIndicatorContext", "MenuItemIndicator", "itemIndicatorProps", "indicatorContext", "span", "MenuSeparator", "separatorProps", "MenuArrow", "arrowProps", "Arrow", "handler", "pointerType", "Sub", "SubTrigger", "Group", "Label", "CheckboxItem", "RadioGroup", "RadioItem", "ItemIndicator", "Separator", "createDropdownMenuContext", "createDropdownMenuScope", "createContextScope", "createMenuScope", "useMenuScope", "createMenuScope", "DropdownMenuProvider", "useDropdownMenuContext", "createDropdownMenuContext", "DropdownMenu", "props", "__scopeDropdownMenu", "children", "open", "openProp", "defaultOpen", "onOpenChange", "contentContext", "useContentContext", "menuScope", "setOpen", "useControllableState", "prop", "defaultProp", "onChange", "handleOpenToggle", "useCallback", "prevOpen", "isInsideContent", "createElement", "$c7ff2201b6eec7866a95d2679b05981$var$DropdownMenuProvider", "scope", "isRootMenu", "onOpenToggle", "Sub", "_babelRuntimeHelpersEsmExtends", "$c7ff2201b6eec7866a95d2679b05981$var$DropdownMenuRoot", "DropdownMenuRoot", "dir", "modal", "triggerRef", "useRef", "triggerId", "useId", "contentId", "Root", "DropdownMenuTrigger", "forwardRef", "forwardedRef", "disabled", "triggerProps", "context", "Anchor", "asChild", "Primitive", "button", "type", "id", "ref", "composeRefs", "onClick", "composeEventHandlers", "onPointerDown", "event", "ctrlKey", "preventDefault", "onKeyDown", "key", "ContentProvider", "DropdownMenuContent", "contentProps", "commonProps", "style", "$c7ff2201b6eec7866a95d2679b05981$var$ContentProvider", "$c7ff2201b6eec7866a95d2679b05981$var$DropdownMenuRootContent", "Content", "DropdownMenuRootContent", "portalled", "hasInteractedOutsideRef", "onCloseAutoFocus", "_props$onCloseAutoFoc", "_context$triggerRef$c", "call", "defaultPrevented", "current", "focus", "onInteractOutside", "_props$onInteractOuts", "_context$triggerRef$c2", "originalEvent", "detail", "ctrlLeftClick", "isRightClick", "target", "contains", "DropdownMenuGroup", "groupProps", "Group", "DropdownMenuLabel", "labelProps", "Label", "DropdownMenuItem", "itemProps", "Item", "DropdownMenuTriggerItem", "triggerItemProps", "SubTrigger", "DropdownMenuCheckboxItem", "checkboxItemProps", "CheckboxItem", "DropdownMenuRadioGroup", "radioGroupProps", "RadioGroup", "DropdownMenuRadioItem", "radioItemProps", "RadioItem", "DropdownMenuItemIndicator", "itemIndicatorProps", "ItemIndicator", "DropdownMenuSeparator", "separatorProps", "Separator", "DropdownMenuArrow", "arrowProps", "Arrow", "Trigger", "TriggerItem"]
}
