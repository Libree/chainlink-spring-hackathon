import {
  __commonJS,
  __toESM
} from "./chunk-J43GMYXM.js";

// ../../node_modules/@elastic/apm-rum-core/node_modules/stackframe/stackframe.js
var require_stackframe = __commonJS({
  "../../node_modules/@elastic/apm-rum-core/node_modules/stackframe/stackframe.js"(exports, module) {
    (function(root, factory) {
      "use strict";
      if (typeof define === "function" && define.amd) {
        define("stackframe", [], factory);
      } else if (typeof exports === "object") {
        module.exports = factory();
      } else {
        root.StackFrame = factory();
      }
    })(exports, function() {
      "use strict";
      function _isNumber(n) {
        return !isNaN(parseFloat(n)) && isFinite(n);
      }
      function StackFrame(functionName, args, fileName, lineNumber, columnNumber, source) {
        if (functionName !== void 0) {
          this.setFunctionName(functionName);
        }
        if (args !== void 0) {
          this.setArgs(args);
        }
        if (fileName !== void 0) {
          this.setFileName(fileName);
        }
        if (lineNumber !== void 0) {
          this.setLineNumber(lineNumber);
        }
        if (columnNumber !== void 0) {
          this.setColumnNumber(columnNumber);
        }
        if (source !== void 0) {
          this.setSource(source);
        }
      }
      StackFrame.prototype = {
        getFunctionName: function() {
          return this.functionName;
        },
        setFunctionName: function(v) {
          this.functionName = String(v);
        },
        getArgs: function() {
          return this.args;
        },
        setArgs: function(v) {
          if (Object.prototype.toString.call(v) !== "[object Array]") {
            throw new TypeError("Args must be an Array");
          }
          this.args = v;
        },
        getFileName: function() {
          return this.fileName;
        },
        setFileName: function(v) {
          this.fileName = String(v);
        },
        getLineNumber: function() {
          return this.lineNumber;
        },
        setLineNumber: function(v) {
          if (!_isNumber(v)) {
            throw new TypeError("Line Number must be a Number");
          }
          this.lineNumber = Number(v);
        },
        getColumnNumber: function() {
          return this.columnNumber;
        },
        setColumnNumber: function(v) {
          if (!_isNumber(v)) {
            throw new TypeError("Column Number must be a Number");
          }
          this.columnNumber = Number(v);
        },
        getSource: function() {
          return this.source;
        },
        setSource: function(v) {
          this.source = String(v);
        },
        toString: function() {
          var functionName = this.getFunctionName() || "{anonymous}";
          var args = "(" + (this.getArgs() || []).join(",") + ")";
          var fileName = this.getFileName() ? "@" + this.getFileName() : "";
          var lineNumber = _isNumber(this.getLineNumber()) ? ":" + this.getLineNumber() : "";
          var columnNumber = _isNumber(this.getColumnNumber()) ? ":" + this.getColumnNumber() : "";
          return functionName + args + fileName + lineNumber + columnNumber;
        }
      };
      return StackFrame;
    });
  }
});

// ../../node_modules/@elastic/apm-rum-core/node_modules/error-stack-parser/error-stack-parser.js
var require_error_stack_parser = __commonJS({
  "../../node_modules/@elastic/apm-rum-core/node_modules/error-stack-parser/error-stack-parser.js"(exports, module) {
    (function(root, factory) {
      "use strict";
      if (typeof define === "function" && define.amd) {
        define("error-stack-parser", ["stackframe"], factory);
      } else if (typeof exports === "object") {
        module.exports = factory(require_stackframe());
      } else {
        root.ErrorStackParser = factory(root.StackFrame);
      }
    })(exports, function ErrorStackParser(StackFrame) {
      "use strict";
      var FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\S+\:\d+/;
      var CHROME_IE_STACK_REGEXP = /^\s*at .*(\S+\:\d+|\(native\))/m;
      var SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\[native code\])?$/;
      function _map(array, fn, thisArg) {
        if (typeof Array.prototype.map === "function") {
          return array.map(fn, thisArg);
        } else {
          var output = new Array(array.length);
          for (var i = 0; i < array.length; i++) {
            output[i] = fn.call(thisArg, array[i]);
          }
          return output;
        }
      }
      function _filter(array, fn, thisArg) {
        if (typeof Array.prototype.filter === "function") {
          return array.filter(fn, thisArg);
        } else {
          var output = [];
          for (var i = 0; i < array.length; i++) {
            if (fn.call(thisArg, array[i])) {
              output.push(array[i]);
            }
          }
          return output;
        }
      }
      function _indexOf(array, target) {
        if (typeof Array.prototype.indexOf === "function") {
          return array.indexOf(target);
        } else {
          for (var i = 0; i < array.length; i++) {
            if (array[i] === target) {
              return i;
            }
          }
          return -1;
        }
      }
      return {
        parse: function ErrorStackParser$$parse(error) {
          if (typeof error.stacktrace !== "undefined" || typeof error["opera#sourceloc"] !== "undefined") {
            return this.parseOpera(error);
          } else if (error.stack && error.stack.match(CHROME_IE_STACK_REGEXP)) {
            return this.parseV8OrIE(error);
          } else if (error.stack) {
            return this.parseFFOrSafari(error);
          } else {
            throw new Error("Cannot parse given Error object");
          }
        },
        extractLocation: function ErrorStackParser$$extractLocation(urlLike) {
          if (urlLike.indexOf(":") === -1) {
            return [urlLike];
          }
          var regExp = /(.+?)(?:\:(\d+))?(?:\:(\d+))?$/;
          var parts = regExp.exec(urlLike.replace(/[\(\)]/g, ""));
          return [parts[1], parts[2] || void 0, parts[3] || void 0];
        },
        parseV8OrIE: function ErrorStackParser$$parseV8OrIE(error) {
          var filtered = _filter(error.stack.split("\n"), function(line) {
            return !!line.match(CHROME_IE_STACK_REGEXP);
          }, this);
          return _map(filtered, function(line) {
            if (line.indexOf("(eval ") > -1) {
              line = line.replace(/eval code/g, "eval").replace(/(\(eval at [^\()]*)|(\)\,.*$)/g, "");
            }
            var tokens = line.replace(/^\s+/, "").replace(/\(eval code/g, "(").split(/\s+/).slice(1);
            var locationParts = this.extractLocation(tokens.pop());
            var functionName = tokens.join(" ") || void 0;
            var fileName = _indexOf(["eval", "<anonymous>"], locationParts[0]) > -1 ? void 0 : locationParts[0];
            return new StackFrame(functionName, void 0, fileName, locationParts[1], locationParts[2], line);
          }, this);
        },
        parseFFOrSafari: function ErrorStackParser$$parseFFOrSafari(error) {
          var filtered = _filter(error.stack.split("\n"), function(line) {
            return !line.match(SAFARI_NATIVE_CODE_REGEXP);
          }, this);
          return _map(filtered, function(line) {
            if (line.indexOf(" > eval") > -1) {
              line = line.replace(/ line (\d+)(?: > eval line \d+)* > eval\:\d+\:\d+/g, ":$1");
            }
            if (line.indexOf("@") === -1 && line.indexOf(":") === -1) {
              return new StackFrame(line);
            } else {
              var tokens = line.split("@");
              var locationParts = this.extractLocation(tokens.pop());
              var functionName = tokens.join("@") || void 0;
              return new StackFrame(
                functionName,
                void 0,
                locationParts[0],
                locationParts[1],
                locationParts[2],
                line
              );
            }
          }, this);
        },
        parseOpera: function ErrorStackParser$$parseOpera(e) {
          if (!e.stacktrace || e.message.indexOf("\n") > -1 && e.message.split("\n").length > e.stacktrace.split("\n").length) {
            return this.parseOpera9(e);
          } else if (!e.stack) {
            return this.parseOpera10(e);
          } else {
            return this.parseOpera11(e);
          }
        },
        parseOpera9: function ErrorStackParser$$parseOpera9(e) {
          var lineRE = /Line (\d+).*script (?:in )?(\S+)/i;
          var lines = e.message.split("\n");
          var result = [];
          for (var i = 2, len = lines.length; i < len; i += 2) {
            var match = lineRE.exec(lines[i]);
            if (match) {
              result.push(new StackFrame(void 0, void 0, match[2], match[1], void 0, lines[i]));
            }
          }
          return result;
        },
        parseOpera10: function ErrorStackParser$$parseOpera10(e) {
          var lineRE = /Line (\d+).*script (?:in )?(\S+)(?:: In function (\S+))?$/i;
          var lines = e.stacktrace.split("\n");
          var result = [];
          for (var i = 0, len = lines.length; i < len; i += 2) {
            var match = lineRE.exec(lines[i]);
            if (match) {
              result.push(
                new StackFrame(
                  match[3] || void 0,
                  void 0,
                  match[2],
                  match[1],
                  void 0,
                  lines[i]
                )
              );
            }
          }
          return result;
        },
        parseOpera11: function ErrorStackParser$$parseOpera11(error) {
          var filtered = _filter(error.stack.split("\n"), function(line) {
            return !!line.match(FIREFOX_SAFARI_STACK_REGEXP) && !line.match(/^Error created at/);
          }, this);
          return _map(filtered, function(line) {
            var tokens = line.split("@");
            var locationParts = this.extractLocation(tokens.pop());
            var functionCall = tokens.shift() || "";
            var functionName = functionCall.replace(/<anonymous function(: (\w+))?>/, "$2").replace(/\([^\)]*\)/g, "") || void 0;
            var argsRaw;
            if (functionCall.match(/\(([^\)]*)\)/)) {
              argsRaw = functionCall.replace(/^[^\(]+\(([^\)]*)\)$/, "$1");
            }
            var args = argsRaw === void 0 || argsRaw === "[arguments not available]" ? void 0 : argsRaw.split(",");
            return new StackFrame(
              functionName,
              args,
              locationParts[0],
              locationParts[1],
              locationParts[2],
              line
            );
          }, this);
        }
      };
    });
  }
});

// ../../node_modules/opentracing/lib/constants.js
var require_constants = __commonJS({
  "../../node_modules/opentracing/lib/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FORMAT_BINARY = "binary";
    exports.FORMAT_TEXT_MAP = "text_map";
    exports.FORMAT_HTTP_HEADERS = "http_headers";
    exports.REFERENCE_CHILD_OF = "child_of";
    exports.REFERENCE_FOLLOWS_FROM = "follows_from";
  }
});

// ../../node_modules/opentracing/lib/span_context.js
var require_span_context = __commonJS({
  "../../node_modules/opentracing/lib/span_context.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var SpanContext = function() {
      function SpanContext2() {
      }
      SpanContext2.prototype.toTraceId = function() {
        return "";
      };
      SpanContext2.prototype.toSpanId = function() {
        return "";
      };
      return SpanContext2;
    }();
    exports.SpanContext = SpanContext;
    exports.default = SpanContext;
  }
});

// ../../node_modules/opentracing/lib/noop.js
var require_noop = __commonJS({
  "../../node_modules/opentracing/lib/noop.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var span_1 = require_span();
    var span_context_1 = require_span_context();
    var tracer_1 = require_tracer();
    exports.tracer = null;
    exports.spanContext = null;
    exports.span = null;
    function initialize() {
      exports.tracer = new tracer_1.default();
      exports.span = new span_1.default();
      exports.spanContext = new span_context_1.default();
    }
    exports.initialize = initialize;
  }
});

// ../../node_modules/opentracing/lib/span.js
var require_span = __commonJS({
  "../../node_modules/opentracing/lib/span.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var noop3 = require_noop();
    var Span3 = function() {
      function Span4() {
      }
      Span4.prototype.context = function() {
        return this._context();
      };
      Span4.prototype.tracer = function() {
        return this._tracer();
      };
      Span4.prototype.setOperationName = function(name) {
        this._setOperationName(name);
        return this;
      };
      Span4.prototype.setBaggageItem = function(key, value) {
        this._setBaggageItem(key, value);
        return this;
      };
      Span4.prototype.getBaggageItem = function(key) {
        return this._getBaggageItem(key);
      };
      Span4.prototype.setTag = function(key, value) {
        var _a;
        this._addTags((_a = {}, _a[key] = value, _a));
        return this;
      };
      Span4.prototype.addTags = function(keyValueMap) {
        this._addTags(keyValueMap);
        return this;
      };
      Span4.prototype.log = function(keyValuePairs, timestamp) {
        this._log(keyValuePairs, timestamp);
        return this;
      };
      Span4.prototype.logEvent = function(eventName, payload) {
        return this._log({ event: eventName, payload });
      };
      Span4.prototype.finish = function(finishTime) {
        this._finish(finishTime);
      };
      Span4.prototype._context = function() {
        return noop3.spanContext;
      };
      Span4.prototype._tracer = function() {
        return noop3.tracer;
      };
      Span4.prototype._setOperationName = function(name) {
      };
      Span4.prototype._setBaggageItem = function(key, value) {
      };
      Span4.prototype._getBaggageItem = function(key) {
        return void 0;
      };
      Span4.prototype._addTags = function(keyValuePairs) {
      };
      Span4.prototype._log = function(keyValuePairs, timestamp) {
      };
      Span4.prototype._finish = function(finishTime) {
      };
      return Span4;
    }();
    exports.Span = Span3;
    exports.default = Span3;
  }
});

// ../../node_modules/opentracing/lib/reference.js
var require_reference = __commonJS({
  "../../node_modules/opentracing/lib/reference.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var span_1 = require_span();
    var Reference = function() {
      function Reference2(type, referencedContext) {
        this._type = type;
        this._referencedContext = referencedContext instanceof span_1.default ? referencedContext.context() : referencedContext;
      }
      Reference2.prototype.type = function() {
        return this._type;
      };
      Reference2.prototype.referencedContext = function() {
        return this._referencedContext;
      };
      return Reference2;
    }();
    exports.default = Reference;
  }
});

// ../../node_modules/opentracing/lib/functions.js
var require_functions = __commonJS({
  "../../node_modules/opentracing/lib/functions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Constants = require_constants();
    var reference_1 = require_reference();
    var span_1 = require_span();
    function childOf(spanContext) {
      if (spanContext instanceof span_1.default) {
        spanContext = spanContext.context();
      }
      return new reference_1.default(Constants.REFERENCE_CHILD_OF, spanContext);
    }
    exports.childOf = childOf;
    function followsFrom(spanContext) {
      if (spanContext instanceof span_1.default) {
        spanContext = spanContext.context();
      }
      return new reference_1.default(Constants.REFERENCE_FOLLOWS_FROM, spanContext);
    }
    exports.followsFrom = followsFrom;
  }
});

// ../../node_modules/opentracing/lib/tracer.js
var require_tracer = __commonJS({
  "../../node_modules/opentracing/lib/tracer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Functions = require_functions();
    var Noop = require_noop();
    var span_1 = require_span();
    var Tracer2 = function() {
      function Tracer3() {
      }
      Tracer3.prototype.startSpan = function(name, options) {
        if (options === void 0) {
          options = {};
        }
        if (options.childOf) {
          var childOf = Functions.childOf(options.childOf);
          if (options.references) {
            options.references.push(childOf);
          } else {
            options.references = [childOf];
          }
          delete options.childOf;
        }
        return this._startSpan(name, options);
      };
      Tracer3.prototype.inject = function(spanContext, format, carrier) {
        if (spanContext instanceof span_1.default) {
          spanContext = spanContext.context();
        }
        return this._inject(spanContext, format, carrier);
      };
      Tracer3.prototype.extract = function(format, carrier) {
        return this._extract(format, carrier);
      };
      Tracer3.prototype._startSpan = function(name, fields) {
        return Noop.span;
      };
      Tracer3.prototype._inject = function(spanContext, format, carrier) {
      };
      Tracer3.prototype._extract = function(format, carrier) {
        return Noop.spanContext;
      };
      return Tracer3;
    }();
    exports.Tracer = Tracer2;
    exports.default = Tracer2;
  }
});

// ../../node_modules/@elastic/apm-rum-core/dist/es/error-logging/stack-trace.js
var import_error_stack_parser = __toESM(require_error_stack_parser());
function filePathToFileName(fileUrl) {
  var origin = window.location.origin || window.location.protocol + "//" + window.location.hostname + (window.location.port ? ":" + window.location.port : "");
  if (fileUrl.indexOf(origin) > -1) {
    fileUrl = fileUrl.replace(origin + "/", "");
  }
  return fileUrl;
}
function cleanFilePath(filePath) {
  if (filePath === void 0) {
    filePath = "";
  }
  if (filePath === "<anonymous>") {
    filePath = "";
  }
  return filePath;
}
function isFileInline(fileUrl) {
  if (fileUrl) {
    return window.location.href.indexOf(fileUrl) === 0;
  }
  return false;
}
function normalizeStackFrames(stackFrames) {
  return stackFrames.map(function(frame) {
    if (frame.functionName) {
      frame.functionName = normalizeFunctionName(frame.functionName);
    }
    return frame;
  });
}
function normalizeFunctionName(fnName) {
  var parts = fnName.split("/");
  if (parts.length > 1) {
    fnName = ["Object", parts[parts.length - 1]].join(".");
  } else {
    fnName = parts[0];
  }
  fnName = fnName.replace(/.<$/gi, ".<anonymous>");
  fnName = fnName.replace(/^Anonymous function$/, "<anonymous>");
  parts = fnName.split(".");
  if (parts.length > 1) {
    fnName = parts[parts.length - 1];
  } else {
    fnName = parts[0];
  }
  return fnName;
}
function createStackTraces(errorEvent) {
  var error = errorEvent.error, filename = errorEvent.filename, lineno = errorEvent.lineno, colno = errorEvent.colno;
  var stackTraces = [];
  if (error) {
    try {
      stackTraces = import_error_stack_parser.default.parse(error);
    } catch (e) {
    }
  }
  if (stackTraces.length === 0) {
    stackTraces = [{
      fileName: filename,
      lineNumber: lineno,
      columnNumber: colno
    }];
  }
  var normalizedStackTraces = normalizeStackFrames(stackTraces);
  return normalizedStackTraces.map(function(stack) {
    var fileName = stack.fileName, lineNumber = stack.lineNumber, columnNumber = stack.columnNumber, _stack$functionName = stack.functionName, functionName = _stack$functionName === void 0 ? "<anonymous>" : _stack$functionName;
    if (!fileName && !lineNumber) {
      return {};
    }
    if (!columnNumber && !lineNumber) {
      return {};
    }
    var filePath = cleanFilePath(fileName);
    var cleanedFileName = filePathToFileName(filePath);
    if (isFileInline(filePath)) {
      cleanedFileName = "(inline script)";
    }
    return {
      abs_path: fileName,
      filename: cleanedFileName,
      function: functionName,
      lineno: lineNumber,
      colno: columnNumber
    };
  });
}
function filterInvalidFrames(frames) {
  return frames.filter(function(_ref) {
    var filename = _ref.filename, lineno = _ref.lineno;
    return typeof filename !== "undefined" && typeof lineno !== "undefined";
  });
}

// ../../node_modules/promise-polyfill/src/finally.js
function finallyConstructor(callback) {
  var constructor = this.constructor;
  return this.then(
    function(value) {
      return constructor.resolve(callback()).then(function() {
        return value;
      });
    },
    function(reason) {
      return constructor.resolve(callback()).then(function() {
        return constructor.reject(reason);
      });
    }
  );
}
var finally_default = finallyConstructor;

// ../../node_modules/promise-polyfill/src/allSettled.js
function allSettled(arr) {
  var P = this;
  return new P(function(resolve2, reject2) {
    if (!(arr && typeof arr.length !== "undefined")) {
      return reject2(
        new TypeError(
          typeof arr + " " + arr + " is not iterable(cannot read property Symbol(Symbol.iterator))"
        )
      );
    }
    var args = Array.prototype.slice.call(arr);
    if (args.length === 0)
      return resolve2([]);
    var remaining = args.length;
    function res(i2, val) {
      if (val && (typeof val === "object" || typeof val === "function")) {
        var then = val.then;
        if (typeof then === "function") {
          then.call(
            val,
            function(val2) {
              res(i2, val2);
            },
            function(e) {
              args[i2] = { status: "rejected", reason: e };
              if (--remaining === 0) {
                resolve2(args);
              }
            }
          );
          return;
        }
      }
      args[i2] = { status: "fulfilled", value: val };
      if (--remaining === 0) {
        resolve2(args);
      }
    }
    for (var i = 0; i < args.length; i++) {
      res(i, args[i]);
    }
  });
}
var allSettled_default = allSettled;

// ../../node_modules/promise-polyfill/src/index.js
var setTimeoutFunc = setTimeout;
var setImmediateFunc = typeof setImmediate !== "undefined" ? setImmediate : null;
function isArray(x) {
  return Boolean(x && typeof x.length !== "undefined");
}
function noop() {
}
function bind(fn, thisArg) {
  return function() {
    fn.apply(thisArg, arguments);
  };
}
function Promise2(fn) {
  if (!(this instanceof Promise2))
    throw new TypeError("Promises must be constructed via new");
  if (typeof fn !== "function")
    throw new TypeError("not a function");
  this._state = 0;
  this._handled = false;
  this._value = void 0;
  this._deferreds = [];
  doResolve(fn, this);
}
function handle(self2, deferred) {
  while (self2._state === 3) {
    self2 = self2._value;
  }
  if (self2._state === 0) {
    self2._deferreds.push(deferred);
    return;
  }
  self2._handled = true;
  Promise2._immediateFn(function() {
    var cb = self2._state === 1 ? deferred.onFulfilled : deferred.onRejected;
    if (cb === null) {
      (self2._state === 1 ? resolve : reject)(deferred.promise, self2._value);
      return;
    }
    var ret;
    try {
      ret = cb(self2._value);
    } catch (e) {
      reject(deferred.promise, e);
      return;
    }
    resolve(deferred.promise, ret);
  });
}
function resolve(self2, newValue) {
  try {
    if (newValue === self2)
      throw new TypeError("A promise cannot be resolved with itself.");
    if (newValue && (typeof newValue === "object" || typeof newValue === "function")) {
      var then = newValue.then;
      if (newValue instanceof Promise2) {
        self2._state = 3;
        self2._value = newValue;
        finale(self2);
        return;
      } else if (typeof then === "function") {
        doResolve(bind(then, newValue), self2);
        return;
      }
    }
    self2._state = 1;
    self2._value = newValue;
    finale(self2);
  } catch (e) {
    reject(self2, e);
  }
}
function reject(self2, newValue) {
  self2._state = 2;
  self2._value = newValue;
  finale(self2);
}
function finale(self2) {
  if (self2._state === 2 && self2._deferreds.length === 0) {
    Promise2._immediateFn(function() {
      if (!self2._handled) {
        Promise2._unhandledRejectionFn(self2._value);
      }
    });
  }
  for (var i = 0, len = self2._deferreds.length; i < len; i++) {
    handle(self2, self2._deferreds[i]);
  }
  self2._deferreds = null;
}
function Handler(onFulfilled, onRejected, promise) {
  this.onFulfilled = typeof onFulfilled === "function" ? onFulfilled : null;
  this.onRejected = typeof onRejected === "function" ? onRejected : null;
  this.promise = promise;
}
function doResolve(fn, self2) {
  var done = false;
  try {
    fn(
      function(value) {
        if (done)
          return;
        done = true;
        resolve(self2, value);
      },
      function(reason) {
        if (done)
          return;
        done = true;
        reject(self2, reason);
      }
    );
  } catch (ex) {
    if (done)
      return;
    done = true;
    reject(self2, ex);
  }
}
Promise2.prototype["catch"] = function(onRejected) {
  return this.then(null, onRejected);
};
Promise2.prototype.then = function(onFulfilled, onRejected) {
  var prom = new this.constructor(noop);
  handle(this, new Handler(onFulfilled, onRejected, prom));
  return prom;
};
Promise2.prototype["finally"] = finally_default;
Promise2.all = function(arr) {
  return new Promise2(function(resolve2, reject2) {
    if (!isArray(arr)) {
      return reject2(new TypeError("Promise.all accepts an array"));
    }
    var args = Array.prototype.slice.call(arr);
    if (args.length === 0)
      return resolve2([]);
    var remaining = args.length;
    function res(i2, val) {
      try {
        if (val && (typeof val === "object" || typeof val === "function")) {
          var then = val.then;
          if (typeof then === "function") {
            then.call(
              val,
              function(val2) {
                res(i2, val2);
              },
              reject2
            );
            return;
          }
        }
        args[i2] = val;
        if (--remaining === 0) {
          resolve2(args);
        }
      } catch (ex) {
        reject2(ex);
      }
    }
    for (var i = 0; i < args.length; i++) {
      res(i, args[i]);
    }
  });
};
Promise2.allSettled = allSettled_default;
Promise2.resolve = function(value) {
  if (value && typeof value === "object" && value.constructor === Promise2) {
    return value;
  }
  return new Promise2(function(resolve2) {
    resolve2(value);
  });
};
Promise2.reject = function(value) {
  return new Promise2(function(resolve2, reject2) {
    reject2(value);
  });
};
Promise2.race = function(arr) {
  return new Promise2(function(resolve2, reject2) {
    if (!isArray(arr)) {
      return reject2(new TypeError("Promise.race accepts an array"));
    }
    for (var i = 0, len = arr.length; i < len; i++) {
      Promise2.resolve(arr[i]).then(resolve2, reject2);
    }
  });
};
Promise2._immediateFn = typeof setImmediateFunc === "function" && function(fn) {
  setImmediateFunc(fn);
} || function(fn) {
  setTimeoutFunc(fn, 0);
};
Promise2._unhandledRejectionFn = function _unhandledRejectionFn(err) {
  if (typeof console !== "undefined" && console) {
    console.warn("Possible Unhandled Promise Rejection:", err);
  }
};
var src_default = Promise2;

// ../../node_modules/@elastic/apm-rum-core/dist/es/common/polyfills.js
var local = {};
if (isBrowser) {
  local = window;
} else if (typeof self !== "undefined") {
  local = self;
}
var Promise3 = "Promise" in local ? local.Promise : src_default;

// ../../node_modules/@elastic/apm-rum-core/dist/es/common/utils.js
var slice = [].slice;
var isBrowser = typeof window !== "undefined";
var PERF = isBrowser && typeof performance !== "undefined" ? performance : {};
function isCORSSupported() {
  var xhr = new window.XMLHttpRequest();
  return "withCredentials" in xhr;
}
var byteToHex = [];
for (i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 256).toString(16).substr(1);
}
var i;
function bytesToHex(buffer) {
  var hexOctets = [];
  for (var _i = 0; _i < buffer.length; _i++) {
    hexOctets.push(byteToHex[buffer[_i]]);
  }
  return hexOctets.join("");
}
var destination = new Uint8Array(16);
function rng() {
  if (typeof crypto != "undefined" && typeof crypto.getRandomValues == "function") {
    return crypto.getRandomValues(destination);
  } else if (typeof msCrypto != "undefined" && typeof msCrypto.getRandomValues == "function") {
    return msCrypto.getRandomValues(destination);
  }
  return destination;
}
function generateRandomId(length) {
  var id = bytesToHex(rng());
  return id.substr(0, length);
}
function getDtHeaderValue(span) {
  var dtVersion = "00";
  var dtUnSampledFlags = "00";
  var dtSampledFlags = "01";
  if (span && span.traceId && span.id && span.parentId) {
    var flags = span.sampled ? dtSampledFlags : dtUnSampledFlags;
    var id = span.sampled ? span.id : span.parentId;
    return dtVersion + "-" + span.traceId + "-" + id + "-" + flags;
  }
}
function parseDtHeaderValue(value) {
  var parsed = /^([\da-f]{2})-([\da-f]{32})-([\da-f]{16})-([\da-f]{2})$/.exec(value);
  if (parsed) {
    var flags = parsed[4];
    var sampled = flags !== "00";
    return {
      traceId: parsed[2],
      id: parsed[3],
      sampled
    };
  }
}
function isDtHeaderValid(header) {
  return /^[\da-f]{2}-[\da-f]{32}-[\da-f]{16}-[\da-f]{2}$/.test(header) && header.slice(3, 35) !== "00000000000000000000000000000000" && header.slice(36, 52) !== "0000000000000000";
}
function getTSHeaderValue(_ref) {
  var sampleRate = _ref.sampleRate;
  if (typeof sampleRate !== "number" || String(sampleRate).length > 256) {
    return;
  }
  var NAMESPACE = "es";
  var SEPARATOR = "=";
  return "" + NAMESPACE + SEPARATOR + "s:" + sampleRate;
}
function setRequestHeader(target, name, value) {
  if (typeof target.setRequestHeader === "function") {
    target.setRequestHeader(name, value);
  } else if (target.headers && typeof target.headers.append === "function") {
    target.headers.append(name, value);
  } else {
    target[name] = value;
  }
}
function checkSameOrigin(source, target) {
  var isSame = false;
  if (typeof target === "string") {
    isSame = source === target;
  } else if (target && typeof target.test === "function") {
    isSame = target.test(source);
  } else if (Array.isArray(target)) {
    target.forEach(function(t) {
      if (!isSame) {
        isSame = checkSameOrigin(source, t);
      }
    });
  }
  return isSame;
}
function isPlatformSupported() {
  return isBrowser && typeof Set === "function" && typeof JSON.stringify === "function" && PERF && typeof PERF.now === "function" && isCORSSupported();
}
function setLabel(key, value, obj) {
  if (!obj || !key)
    return;
  var skey = removeInvalidChars(key);
  var valueType = typeof value;
  if (value != void 0 && valueType !== "boolean" && valueType !== "number") {
    value = String(value);
  }
  obj[skey] = value;
  return obj;
}
function getServerTimingInfo(serverTimingEntries) {
  if (serverTimingEntries === void 0) {
    serverTimingEntries = [];
  }
  var serverTimingInfo = [];
  var entrySeparator = ", ";
  var valueSeparator = ";";
  for (var _i2 = 0; _i2 < serverTimingEntries.length; _i2++) {
    var _serverTimingEntries$ = serverTimingEntries[_i2], name = _serverTimingEntries$.name, duration = _serverTimingEntries$.duration, description = _serverTimingEntries$.description;
    var timingValue = name;
    if (description) {
      timingValue += valueSeparator + "desc=" + description;
    }
    if (duration) {
      timingValue += valueSeparator + "dur=" + duration;
    }
    serverTimingInfo.push(timingValue);
  }
  return serverTimingInfo.join(entrySeparator);
}
function getTimeOrigin() {
  return PERF.timing.fetchStart;
}
function stripQueryStringFromUrl(url) {
  return url && url.split("?")[0];
}
function isObject(value) {
  return value !== null && typeof value === "object";
}
function isFunction(value) {
  return typeof value === "function";
}
function baseExtend(dst, objs, deep) {
  for (var i = 0, ii = objs.length; i < ii; ++i) {
    var obj = objs[i];
    if (!isObject(obj) && !isFunction(obj))
      continue;
    var keys = Object.keys(obj);
    for (var j = 0, jj = keys.length; j < jj; j++) {
      var key = keys[j];
      var src = obj[key];
      if (deep && isObject(src)) {
        if (!isObject(dst[key]))
          dst[key] = Array.isArray(src) ? [] : {};
        baseExtend(dst[key], [src], false);
      } else {
        dst[key] = src;
      }
    }
  }
  return dst;
}
function getElasticScript() {
  if (typeof document !== "undefined") {
    var scripts = document.getElementsByTagName("script");
    for (var i = 0, l = scripts.length; i < l; i++) {
      var sc = scripts[i];
      if (sc.src.indexOf("elastic") > 0) {
        return sc;
      }
    }
  }
}
function getCurrentScript() {
  if (typeof document !== "undefined") {
    var currentScript = document.currentScript;
    if (!currentScript) {
      return getElasticScript();
    }
    return currentScript;
  }
}
function extend(dst) {
  return baseExtend(dst, slice.call(arguments, 1), false);
}
function merge(dst) {
  return baseExtend(dst, slice.call(arguments, 1), true);
}
function isUndefined(obj) {
  return typeof obj === "undefined";
}
function noop2() {
}
function find(array, predicate, thisArg) {
  if (array == null) {
    throw new TypeError("array is null or not defined");
  }
  var o = Object(array);
  var len = o.length >>> 0;
  if (typeof predicate !== "function") {
    throw new TypeError("predicate must be a function");
  }
  var k = 0;
  while (k < len) {
    var kValue = o[k];
    if (predicate.call(thisArg, kValue, k, o)) {
      return kValue;
    }
    k++;
  }
  return void 0;
}
function removeInvalidChars(key) {
  return key.replace(/[.*"]/g, "_");
}
function getLatestNonXHRSpan(spans) {
  var latestSpan = null;
  for (var _i3 = 0; _i3 < spans.length; _i3++) {
    var span = spans[_i3];
    if (String(span.type).indexOf("external") === -1 && (!latestSpan || latestSpan._end < span._end)) {
      latestSpan = span;
    }
  }
  return latestSpan;
}
function getEarliestSpan(spans) {
  var earliestSpan = spans[0];
  for (var _i4 = 1; _i4 < spans.length; _i4++) {
    var span = spans[_i4];
    if (earliestSpan._start > span._start) {
      earliestSpan = span;
    }
  }
  return earliestSpan;
}
function now() {
  return PERF.now();
}
function getTime(time) {
  return typeof time === "number" && time >= 0 ? time : now();
}
function getDuration(start, end) {
  if (isUndefined(end) || isUndefined(start)) {
    return null;
  }
  return parseInt(end - start);
}
function scheduleMicroTask(callback) {
  Promise3.resolve().then(callback);
}
function isPerfTimelineSupported() {
  return typeof PERF.getEntriesByType === "function";
}
function isPerfTypeSupported(type) {
  return typeof PerformanceObserver !== "undefined" && PerformanceObserver.supportedEntryTypes && PerformanceObserver.supportedEntryTypes.indexOf(type) >= 0;
}

// ../../node_modules/@elastic/apm-rum-core/dist/es/common/url.js
function isDefaultPort(port, protocol) {
  switch (protocol) {
    case "http:":
      return port === "80";
    case "https:":
      return port === "443";
  }
  return true;
}
var RULES = [["#", "hash"], ["?", "query"], ["/", "path"], ["@", "auth", 1], [NaN, "host", void 0, 1]];
var PROTOCOL_REGEX = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\S\s]*)/i;
var Url = function() {
  function Url2(url) {
    var _this$extractProtocol = this.extractProtocol(url || ""), protocol = _this$extractProtocol.protocol, address = _this$extractProtocol.address, slashes = _this$extractProtocol.slashes;
    var relative = !protocol && !slashes;
    var location2 = this.getLocation();
    var instructions = RULES.slice();
    address = address.replace("\\", "/");
    if (!slashes) {
      instructions[2] = [NaN, "path"];
    }
    var index;
    for (var i = 0; i < instructions.length; i++) {
      var instruction = instructions[i];
      var parse = instruction[0];
      var key = instruction[1];
      if (typeof parse === "string") {
        index = address.indexOf(parse);
        if (~index) {
          var instLength = instruction[2];
          if (instLength) {
            var newIndex = address.lastIndexOf(parse);
            index = Math.max(index, newIndex);
            this[key] = address.slice(0, index);
            address = address.slice(index + instLength);
          } else {
            this[key] = address.slice(index);
            address = address.slice(0, index);
          }
        }
      } else {
        this[key] = address;
        address = "";
      }
      this[key] = this[key] || (relative && instruction[3] ? location2[key] || "" : "");
      if (instruction[3])
        this[key] = this[key].toLowerCase();
    }
    if (relative && this.path.charAt(0) !== "/") {
      this.path = "/" + this.path;
    }
    this.relative = relative;
    this.protocol = protocol || location2.protocol;
    this.hostname = this.host;
    this.port = "";
    if (/:\d+$/.test(this.host)) {
      var value = this.host.split(":");
      var port = value.pop();
      var hostname = value.join(":");
      if (isDefaultPort(port, this.protocol)) {
        this.host = hostname;
      } else {
        this.port = port;
      }
      this.hostname = hostname;
    }
    this.origin = this.protocol && this.host && this.protocol !== "file:" ? this.protocol + "//" + this.host : "null";
    this.href = this.toString();
  }
  var _proto = Url2.prototype;
  _proto.toString = function toString() {
    var result = this.protocol;
    result += "//";
    if (this.auth) {
      var REDACTED = "[REDACTED]";
      var userpass = this.auth.split(":");
      var username = userpass[0] ? REDACTED : "";
      var password = userpass[1] ? ":" + REDACTED : "";
      result += username + password + "@";
    }
    result += this.host;
    result += this.path;
    result += this.query;
    result += this.hash;
    return result;
  };
  _proto.getLocation = function getLocation() {
    var globalVar = {};
    if (isBrowser) {
      globalVar = window;
    }
    return globalVar.location;
  };
  _proto.extractProtocol = function extractProtocol(url) {
    var match = PROTOCOL_REGEX.exec(url);
    return {
      protocol: match[1] ? match[1].toLowerCase() : "",
      slashes: !!match[2],
      address: match[3]
    };
  };
  return Url2;
}();
function slugifyUrl(urlStr, depth) {
  if (depth === void 0) {
    depth = 2;
  }
  var parsedUrl = new Url(urlStr);
  var query = parsedUrl.query, path = parsedUrl.path;
  var pathParts = path.substring(1).split("/");
  var redactString = ":id";
  var wildcard = "*";
  var specialCharsRegex = /\W|_/g;
  var digitsRegex = /[0-9]/g;
  var lowerCaseRegex = /[a-z]/g;
  var upperCaseRegex = /[A-Z]/g;
  var redactedParts = [];
  var redactedBefore = false;
  for (var index = 0; index < pathParts.length; index++) {
    var part = pathParts[index];
    if (redactedBefore || index > depth - 1) {
      if (part) {
        redactedParts.push(wildcard);
      }
      break;
    }
    var numberOfSpecialChars = (part.match(specialCharsRegex) || []).length;
    if (numberOfSpecialChars >= 2) {
      redactedParts.push(redactString);
      redactedBefore = true;
      continue;
    }
    var numberOfDigits = (part.match(digitsRegex) || []).length;
    if (numberOfDigits > 3 || part.length > 3 && numberOfDigits / part.length >= 0.3) {
      redactedParts.push(redactString);
      redactedBefore = true;
      continue;
    }
    var numberofUpperCase = (part.match(upperCaseRegex) || []).length;
    var numberofLowerCase = (part.match(lowerCaseRegex) || []).length;
    var lowerCaseRate = numberofLowerCase / part.length;
    var upperCaseRate = numberofUpperCase / part.length;
    if (part.length > 5 && (upperCaseRate > 0.3 && upperCaseRate < 0.6 || lowerCaseRate > 0.3 && lowerCaseRate < 0.6)) {
      redactedParts.push(redactString);
      redactedBefore = true;
      continue;
    }
    part && redactedParts.push(part);
  }
  var redacted = "/" + (redactedParts.length >= 2 ? redactedParts.join("/") : redactedParts.join("")) + (query ? "?{query}" : "");
  return redacted;
}

// ../../node_modules/@elastic/apm-rum-core/dist/es/common/constants.js
var SCHEDULE = "schedule";
var INVOKE = "invoke";
var ADD_EVENT_LISTENER_STR = "addEventListener";
var REMOVE_EVENT_LISTENER_STR = "removeEventListener";
var RESOURCE_INITIATOR_TYPES = ["link", "css", "script", "img", "xmlhttprequest", "fetch", "beacon", "iframe"];
var REUSABILITY_THRESHOLD = 5e3;
var MAX_SPAN_DURATION = 5 * 60 * 1e3;
var PAGE_LOAD = "page-load";
var ROUTE_CHANGE = "route-change";
var TYPE_CUSTOM = "custom";
var USER_INTERACTION = "user-interaction";
var HTTP_REQUEST_TYPE = "http-request";
var TEMPORARY_TYPE = "temporary";
var NAME_UNKNOWN = "Unknown";
var TRANSACTION_TYPE_ORDER = [PAGE_LOAD, ROUTE_CHANGE, USER_INTERACTION, HTTP_REQUEST_TYPE, TYPE_CUSTOM, TEMPORARY_TYPE];
var OUTCOME_SUCCESS = "success";
var OUTCOME_FAILURE = "failure";
var USER_TIMING_THRESHOLD = 60;
var TRANSACTION_START = "transaction:start";
var TRANSACTION_END = "transaction:end";
var CONFIG_CHANGE = "config:change";
var XMLHTTPREQUEST = "xmlhttprequest";
var FETCH = "fetch";
var HISTORY = "history";
var EVENT_TARGET = "eventtarget";
var ERROR = "error";
var BEFORE_EVENT = ":before";
var AFTER_EVENT = ":after";
var LOCAL_CONFIG_KEY = "elastic_apm_config";
var LONG_TASK = "longtask";
var PAINT = "paint";
var MEASURE = "measure";
var NAVIGATION = "navigation";
var RESOURCE = "resource";
var FIRST_CONTENTFUL_PAINT = "first-contentful-paint";
var LARGEST_CONTENTFUL_PAINT = "largest-contentful-paint";
var FIRST_INPUT = "first-input";
var LAYOUT_SHIFT = "layout-shift";
var ERRORS = "errors";
var TRANSACTIONS = "transactions";
var CONFIG_SERVICE = "ConfigService";
var LOGGING_SERVICE = "LoggingService";
var APM_SERVER = "ApmServer";
var TRUNCATED_TYPE = ".truncated";
var KEYWORD_LIMIT = 1024;
var SESSION_TIMEOUT = 30 * 6e4;

// ../../node_modules/@elastic/apm-rum-core/dist/es/common/context.js
var _excluded = ["tags"];
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
var LEFT_SQUARE_BRACKET = 91;
var RIGHT_SQUARE_BRACKET = 93;
var EXTERNAL = "external";
var RESOURCE2 = "resource";
var HARD_NAVIGATION = "hard-navigation";
function getPortNumber(port, protocol) {
  if (port === "") {
    port = protocol === "http:" ? "80" : protocol === "https:" ? "443" : "";
  }
  return port;
}
function getResponseContext(perfTimingEntry) {
  var transferSize = perfTimingEntry.transferSize, encodedBodySize = perfTimingEntry.encodedBodySize, decodedBodySize = perfTimingEntry.decodedBodySize, serverTiming = perfTimingEntry.serverTiming;
  var respContext = {
    transfer_size: transferSize,
    encoded_body_size: encodedBodySize,
    decoded_body_size: decodedBodySize
  };
  var serverTimingStr = getServerTimingInfo(serverTiming);
  if (serverTimingStr) {
    respContext.headers = {
      "server-timing": serverTimingStr
    };
  }
  return respContext;
}
function getDestination(parsedUrl, type) {
  var port = parsedUrl.port, protocol = parsedUrl.protocol, hostname = parsedUrl.hostname, host = parsedUrl.host;
  var portNumber = getPortNumber(port, protocol);
  var ipv6Hostname = hostname.charCodeAt(0) === LEFT_SQUARE_BRACKET && hostname.charCodeAt(hostname.length - 1) === RIGHT_SQUARE_BRACKET;
  var address = hostname;
  if (ipv6Hostname) {
    address = hostname.slice(1, -1);
  }
  return {
    service: {
      name: protocol + "//" + host,
      resource: hostname + ":" + portNumber,
      type
    },
    address,
    port: Number(portNumber)
  };
}
function getResourceContext(data) {
  var entry = data.entry, url = data.url;
  var parsedUrl = new Url(url);
  var destination2 = getDestination(parsedUrl, RESOURCE2);
  return {
    http: {
      url,
      response: getResponseContext(entry)
    },
    destination: destination2
  };
}
function getExternalContext(data) {
  var url = data.url, method = data.method, target = data.target, response = data.response;
  var parsedUrl = new Url(url);
  var destination2 = getDestination(parsedUrl, EXTERNAL);
  var context = {
    http: {
      method,
      url: parsedUrl.href
    },
    destination: destination2
  };
  var statusCode;
  if (target && typeof target.status !== "undefined") {
    statusCode = target.status;
  } else if (response) {
    statusCode = response.status;
  }
  context.http.status_code = statusCode;
  return context;
}
function getNavigationContext(data) {
  var url = data.url;
  var parsedUrl = new Url(url);
  var destination2 = getDestination(parsedUrl, HARD_NAVIGATION);
  return {
    destination: destination2
  };
}
function getPageContext() {
  return {
    page: {
      referer: document.referrer,
      url: location.href
    }
  };
}
function addSpanContext(span, data) {
  if (!data) {
    return;
  }
  var type = span.type;
  var context;
  switch (type) {
    case EXTERNAL:
      context = getExternalContext(data);
      break;
    case RESOURCE2:
      context = getResourceContext(data);
      break;
    case HARD_NAVIGATION:
      context = getNavigationContext(data);
      break;
  }
  span.addContext(context);
}
function addTransactionContext(transaction, _temp) {
  var _ref = _temp === void 0 ? {} : _temp, tags = _ref.tags, configContext = _objectWithoutPropertiesLoose(_ref, _excluded);
  var pageContext = getPageContext();
  var responseContext = {};
  if (transaction.type === PAGE_LOAD && isPerfTimelineSupported()) {
    var entries = PERF.getEntriesByType(NAVIGATION);
    if (entries && entries.length > 0) {
      responseContext = {
        response: getResponseContext(entries[0])
      };
    }
  }
  transaction.addContext(pageContext, responseContext, configContext);
}

// ../../node_modules/@elastic/apm-rum-core/dist/es/common/truncate.js
var METADATA_MODEL = {
  service: {
    name: [KEYWORD_LIMIT, true],
    version: true,
    agent: {
      version: [KEYWORD_LIMIT, true]
    },
    environment: true
  },
  labels: {
    "*": true
  }
};
var RESPONSE_MODEL = {
  "*": true,
  headers: {
    "*": true
  }
};
var DESTINATION_MODEL = {
  address: [KEYWORD_LIMIT],
  service: {
    "*": [KEYWORD_LIMIT, true]
  }
};
var CONTEXT_MODEL = {
  user: {
    id: true,
    email: true,
    username: true
  },
  tags: {
    "*": true
  },
  http: {
    response: RESPONSE_MODEL
  },
  destination: DESTINATION_MODEL,
  response: RESPONSE_MODEL
};
var SPAN_MODEL = {
  name: [KEYWORD_LIMIT, true],
  type: [KEYWORD_LIMIT, true],
  id: [KEYWORD_LIMIT, true],
  trace_id: [KEYWORD_LIMIT, true],
  parent_id: [KEYWORD_LIMIT, true],
  transaction_id: [KEYWORD_LIMIT, true],
  subtype: true,
  action: true,
  context: CONTEXT_MODEL
};
var TRANSACTION_MODEL = {
  name: true,
  parent_id: true,
  type: [KEYWORD_LIMIT, true],
  id: [KEYWORD_LIMIT, true],
  trace_id: [KEYWORD_LIMIT, true],
  span_count: {
    started: [KEYWORD_LIMIT, true]
  },
  context: CONTEXT_MODEL
};
var ERROR_MODEL = {
  id: [KEYWORD_LIMIT, true],
  trace_id: true,
  transaction_id: true,
  parent_id: true,
  culprit: true,
  exception: {
    type: true
  },
  transaction: {
    type: true
  },
  context: CONTEXT_MODEL
};
function truncate(value, limit, required, placeholder) {
  if (limit === void 0) {
    limit = KEYWORD_LIMIT;
  }
  if (required === void 0) {
    required = false;
  }
  if (placeholder === void 0) {
    placeholder = "N/A";
  }
  if (required && isEmpty(value)) {
    value = placeholder;
  }
  if (typeof value === "string") {
    return value.substring(0, limit);
  }
  return value;
}
function isEmpty(value) {
  return value == null || value === "" || typeof value === "undefined";
}
function replaceValue(target, key, currModel) {
  var value = truncate(target[key], currModel[0], currModel[1]);
  if (isEmpty(value)) {
    delete target[key];
    return;
  }
  target[key] = value;
}
function truncateModel(model, target, childTarget) {
  if (model === void 0) {
    model = {};
  }
  if (childTarget === void 0) {
    childTarget = target;
  }
  var keys = Object.keys(model);
  var emptyArr = [];
  var _loop = function _loop2(i2) {
    var currKey = keys[i2];
    var currModel = model[currKey] === true ? emptyArr : model[currKey];
    if (!Array.isArray(currModel)) {
      truncateModel(currModel, target, childTarget[currKey]);
    } else {
      if (currKey === "*") {
        Object.keys(childTarget).forEach(function(key) {
          return replaceValue(childTarget, key, currModel);
        });
      } else {
        replaceValue(childTarget, currKey, currModel);
      }
    }
  };
  for (var i = 0; i < keys.length; i++) {
    _loop(i);
  }
  return target;
}

// ../../node_modules/@elastic/apm-rum-core/dist/es/error-logging/error-logging.js
var _excluded2 = ["tags"];
function _objectWithoutPropertiesLoose2(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
var IGNORE_KEYS = ["stack", "message"];
function getErrorProperties(error) {
  var propertyFound = false;
  var properties = {};
  Object.keys(error).forEach(function(key) {
    if (IGNORE_KEYS.indexOf(key) >= 0) {
      return;
    }
    var val = error[key];
    if (val == null || typeof val === "function") {
      return;
    }
    if (typeof val === "object") {
      if (typeof val.toISOString !== "function")
        return;
      val = val.toISOString();
    }
    properties[key] = val;
    propertyFound = true;
  });
  if (propertyFound) {
    return properties;
  }
}
var ErrorLogging = function() {
  function ErrorLogging2(apmServer, configService, transactionService) {
    this._apmServer = apmServer;
    this._configService = configService;
    this._transactionService = transactionService;
  }
  var _proto = ErrorLogging2.prototype;
  _proto.createErrorDataModel = function createErrorDataModel(errorEvent) {
    var frames = createStackTraces(errorEvent);
    var filteredFrames = filterInvalidFrames(frames);
    var culprit = "(inline script)";
    var lastFrame = filteredFrames[filteredFrames.length - 1];
    if (lastFrame && lastFrame.filename) {
      culprit = lastFrame.filename;
    }
    var message = errorEvent.message, error = errorEvent.error;
    var errorMessage = message;
    var errorType = "";
    var errorContext = {};
    if (error && typeof error === "object") {
      errorMessage = errorMessage || error.message;
      errorType = error.name;
      var customProperties = getErrorProperties(error);
      if (customProperties) {
        errorContext.custom = customProperties;
      }
    }
    if (!errorType) {
      if (errorMessage && errorMessage.indexOf(":") > -1) {
        errorType = errorMessage.split(":")[0];
      }
    }
    var currentTransaction = this._transactionService.getCurrentTransaction();
    var transactionContext = currentTransaction ? currentTransaction.context : {};
    var _this$_configService$ = this._configService.get("context"), tags = _this$_configService$.tags, configContext = _objectWithoutPropertiesLoose2(_this$_configService$, _excluded2);
    var pageContext = getPageContext();
    var context = merge({}, pageContext, transactionContext, configContext, errorContext);
    var errorObject = {
      id: generateRandomId(),
      culprit,
      exception: {
        message: errorMessage,
        stacktrace: filteredFrames,
        type: errorType
      },
      context
    };
    if (currentTransaction) {
      errorObject = extend(errorObject, {
        trace_id: currentTransaction.traceId,
        parent_id: currentTransaction.id,
        transaction_id: currentTransaction.id,
        transaction: {
          type: currentTransaction.type,
          sampled: currentTransaction.sampled
        }
      });
    }
    return truncateModel(ERROR_MODEL, errorObject);
  };
  _proto.logErrorEvent = function logErrorEvent(errorEvent) {
    if (typeof errorEvent === "undefined") {
      return;
    }
    var errorObject = this.createErrorDataModel(errorEvent);
    if (typeof errorObject.exception.message === "undefined") {
      return;
    }
    this._apmServer.addError(errorObject);
  };
  _proto.registerListeners = function registerListeners() {
    var _this = this;
    window.addEventListener("error", function(errorEvent) {
      return _this.logErrorEvent(errorEvent);
    });
    window.addEventListener("unhandledrejection", function(promiseRejectionEvent) {
      return _this.logPromiseEvent(promiseRejectionEvent);
    });
  };
  _proto.logPromiseEvent = function logPromiseEvent(promiseRejectionEvent) {
    var prefix = "Unhandled promise rejection: ";
    var reason = promiseRejectionEvent.reason;
    if (reason == null) {
      reason = "<no reason specified>";
    }
    var errorEvent;
    if (typeof reason.message === "string") {
      var name = reason.name ? reason.name + ": " : "";
      errorEvent = {
        error: reason,
        message: prefix + name + reason.message
      };
    } else {
      reason = typeof reason === "object" ? "<object>" : typeof reason === "function" ? "<function>" : reason;
      errorEvent = {
        message: prefix + reason
      };
    }
    this.logErrorEvent(errorEvent);
  };
  _proto.logError = function logError(messageOrError) {
    var errorEvent = {};
    if (typeof messageOrError === "string") {
      errorEvent.message = messageOrError;
    } else {
      errorEvent.error = messageOrError;
    }
    return this.logErrorEvent(errorEvent);
  };
  return ErrorLogging2;
}();
var error_logging_default = ErrorLogging;

// ../../node_modules/@elastic/apm-rum-core/dist/es/common/queue.js
var Queue = function() {
  function Queue2(onFlush, opts) {
    if (opts === void 0) {
      opts = {};
    }
    this.onFlush = onFlush;
    this.items = [];
    this.queueLimit = opts.queueLimit || -1;
    this.flushInterval = opts.flushInterval || 0;
    this.timeoutId = void 0;
  }
  var _proto = Queue2.prototype;
  _proto._setTimer = function _setTimer() {
    var _this = this;
    this.timeoutId = setTimeout(function() {
      return _this.flush();
    }, this.flushInterval);
  };
  _proto._clear = function _clear() {
    if (typeof this.timeoutId !== "undefined") {
      clearTimeout(this.timeoutId);
      this.timeoutId = void 0;
    }
    this.items = [];
  };
  _proto.flush = function flush() {
    this.onFlush(this.items);
    this._clear();
  };
  _proto.add = function add(item) {
    this.items.push(item);
    if (this.queueLimit !== -1 && this.items.length >= this.queueLimit) {
      this.flush();
    } else {
      if (typeof this.timeoutId === "undefined") {
        this._setTimer();
      }
    }
  };
  return Queue2;
}();
var queue_default = Queue;

// ../../node_modules/@elastic/apm-rum-core/dist/es/common/throttle.js
function throttle(fn, onThrottle, opts) {
  var context = this;
  var limit = opts.limit;
  var interval = opts.interval;
  var counter = 0;
  var timeoutId;
  return function() {
    counter++;
    if (typeof timeoutId === "undefined") {
      timeoutId = setTimeout(function() {
        counter = 0;
        timeoutId = void 0;
      }, interval);
    }
    if (counter > limit && typeof onThrottle === "function") {
      return onThrottle.apply(context, arguments);
    } else {
      return fn.apply(context, arguments);
    }
  };
}

// ../../node_modules/@elastic/apm-rum-core/dist/es/common/ndjson.js
var NDJSON = function() {
  function NDJSON2() {
  }
  NDJSON2.stringify = function stringify(object) {
    return JSON.stringify(object) + "\n";
  };
  return NDJSON2;
}();
var ndjson_default = NDJSON;

// ../../node_modules/@elastic/apm-rum-core/dist/es/common/patching/patch-utils.js
var globalState = {
  fetchInProgress: false
};
function apmSymbol(name) {
  return "__apm_symbol__" + name;
}
function isPropertyWritable(propertyDesc) {
  if (!propertyDesc) {
    return true;
  }
  if (propertyDesc.writable === false) {
    return false;
  }
  return !(typeof propertyDesc.get === "function" && typeof propertyDesc.set === "undefined");
}
function attachOriginToPatched(patched, original) {
  patched[apmSymbol("OriginalDelegate")] = original;
}
function patchMethod(target, name, patchFn) {
  var proto = target;
  while (proto && !proto.hasOwnProperty(name)) {
    proto = Object.getPrototypeOf(proto);
  }
  if (!proto && target[name]) {
    proto = target;
  }
  var delegateName = apmSymbol(name);
  var delegate;
  if (proto && !(delegate = proto[delegateName])) {
    delegate = proto[delegateName] = proto[name];
    var desc = proto && Object.getOwnPropertyDescriptor(proto, name);
    if (isPropertyWritable(desc)) {
      var patchDelegate = patchFn(delegate, delegateName, name);
      proto[name] = function() {
        return patchDelegate(this, arguments);
      };
      attachOriginToPatched(proto[name], delegate);
    }
  }
  return delegate;
}
var XHR_IGNORE = apmSymbol("xhrIgnore");
var XHR_SYNC = apmSymbol("xhrSync");
var XHR_URL = apmSymbol("xhrURL");
var XHR_METHOD = apmSymbol("xhrMethod");

// ../../node_modules/@elastic/apm-rum-core/dist/es/performance-monitoring/span-base.js
var SpanBase = function() {
  function SpanBase2(name, type, options) {
    if (options === void 0) {
      options = {};
    }
    if (!name) {
      name = NAME_UNKNOWN;
    }
    if (!type) {
      type = TYPE_CUSTOM;
    }
    this.name = name;
    this.type = type;
    this.options = options;
    this.id = options.id || generateRandomId(16);
    this.traceId = options.traceId;
    this.sampled = options.sampled;
    this.sampleRate = options.sampleRate;
    this.timestamp = options.timestamp;
    this._start = getTime(options.startTime);
    this._end = void 0;
    this.ended = false;
    this.outcome = void 0;
    this.onEnd = options.onEnd;
  }
  var _proto = SpanBase2.prototype;
  _proto.ensureContext = function ensureContext() {
    if (!this.context) {
      this.context = {};
    }
  };
  _proto.addLabels = function addLabels(tags) {
    this.ensureContext();
    var ctx = this.context;
    if (!ctx.tags) {
      ctx.tags = {};
    }
    var keys = Object.keys(tags);
    keys.forEach(function(k) {
      return setLabel(k, tags[k], ctx.tags);
    });
  };
  _proto.addContext = function addContext() {
    for (var _len = arguments.length, context = new Array(_len), _key = 0; _key < _len; _key++) {
      context[_key] = arguments[_key];
    }
    if (context.length === 0)
      return;
    this.ensureContext();
    merge.apply(void 0, [this.context].concat(context));
  };
  _proto.end = function end(endTime) {
    if (this.ended) {
      return;
    }
    this.ended = true;
    this._end = getTime(endTime);
    this.callOnEnd();
  };
  _proto.callOnEnd = function callOnEnd() {
    if (typeof this.onEnd === "function") {
      this.onEnd(this);
    }
  };
  _proto.duration = function duration() {
    return getDuration(this._start, this._end);
  };
  return SpanBase2;
}();
var span_base_default = SpanBase;

// ../../node_modules/@elastic/apm-rum-core/dist/es/performance-monitoring/span.js
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf5(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf(o, p);
}
var Span = function(_SpanBase) {
  _inheritsLoose(Span3, _SpanBase);
  function Span3(name, type, options) {
    var _this;
    _this = _SpanBase.call(this, name, type, options) || this;
    _this.parentId = _this.options.parentId;
    _this.subtype = void 0;
    _this.action = void 0;
    if (_this.type.indexOf(".") !== -1) {
      var fields = _this.type.split(".", 3);
      _this.type = fields[0];
      _this.subtype = fields[1];
      _this.action = fields[2];
    }
    _this.sync = _this.options.sync;
    return _this;
  }
  var _proto = Span3.prototype;
  _proto.end = function end(endTime, data) {
    _SpanBase.prototype.end.call(this, endTime);
    addSpanContext(this, data);
  };
  return Span3;
}(span_base_default);
var span_default = Span;

// ../../node_modules/@elastic/apm-rum-core/dist/es/state.js
var __DEV__ = true;
var state = {
  bootstrapTime: null,
  lastHiddenStart: Number.MIN_SAFE_INTEGER
};

// ../../node_modules/@elastic/apm-rum-core/dist/es/performance-monitoring/capture-navigation.js
var eventPairs = [["domainLookupStart", "domainLookupEnd", "Domain lookup"], ["connectStart", "connectEnd", "Making a connection to the server"], ["requestStart", "responseEnd", "Requesting and receiving the document"], ["domLoading", "domInteractive", "Parsing the document, executing sync. scripts"], ["domContentLoadedEventStart", "domContentLoadedEventEnd", 'Fire "DOMContentLoaded" event'], ["loadEventStart", "loadEventEnd", 'Fire "load" event']];
function shouldCreateSpan(start, end, trStart, trEnd, baseTime) {
  if (baseTime === void 0) {
    baseTime = 0;
  }
  return typeof start === "number" && typeof end === "number" && start >= baseTime && end > start && start - baseTime >= trStart && end - baseTime <= trEnd && end - start < MAX_SPAN_DURATION && start - baseTime < MAX_SPAN_DURATION && end - baseTime < MAX_SPAN_DURATION;
}
function createNavigationTimingSpans(timings, baseTime, trStart, trEnd) {
  var spans = [];
  for (var i = 0; i < eventPairs.length; i++) {
    var start = timings[eventPairs[i][0]];
    var end = timings[eventPairs[i][1]];
    if (!shouldCreateSpan(start, end, trStart, trEnd, baseTime)) {
      continue;
    }
    var span = new span_default(eventPairs[i][2], "hard-navigation.browser-timing");
    var data = null;
    if (eventPairs[i][0] === "requestStart") {
      span.pageResponse = true;
      data = {
        url: location.origin
      };
    }
    span._start = start - baseTime;
    span.end(end - baseTime, data);
    spans.push(span);
  }
  return spans;
}
function createResourceTimingSpan(resourceTimingEntry) {
  var name = resourceTimingEntry.name, initiatorType = resourceTimingEntry.initiatorType, startTime = resourceTimingEntry.startTime, responseEnd = resourceTimingEntry.responseEnd;
  var kind = "resource";
  if (initiatorType) {
    kind += "." + initiatorType;
  }
  var spanName = stripQueryStringFromUrl(name);
  var span = new span_default(spanName, kind);
  span._start = startTime;
  span.end(responseEnd, {
    url: name,
    entry: resourceTimingEntry
  });
  return span;
}
function isCapturedByPatching(resourceStartTime, requestPatchTime) {
  return requestPatchTime != null && resourceStartTime > requestPatchTime;
}
function isIntakeAPIEndpoint(url) {
  return /intake\/v\d+\/rum\/events/.test(url);
}
function createResourceTimingSpans(entries, requestPatchTime, trStart, trEnd) {
  var spans = [];
  for (var i = 0; i < entries.length; i++) {
    var _entries$i = entries[i], initiatorType = _entries$i.initiatorType, name = _entries$i.name, startTime = _entries$i.startTime, responseEnd = _entries$i.responseEnd;
    if (RESOURCE_INITIATOR_TYPES.indexOf(initiatorType) === -1 || name == null) {
      continue;
    }
    if ((initiatorType === "xmlhttprequest" || initiatorType === "fetch") && (isIntakeAPIEndpoint(name) || isCapturedByPatching(startTime, requestPatchTime))) {
      continue;
    }
    if (shouldCreateSpan(startTime, responseEnd, trStart, trEnd)) {
      spans.push(createResourceTimingSpan(entries[i]));
    }
  }
  return spans;
}
function createUserTimingSpans(entries, trStart, trEnd) {
  var userTimingSpans = [];
  for (var i = 0; i < entries.length; i++) {
    var _entries$i2 = entries[i], name = _entries$i2.name, startTime = _entries$i2.startTime, duration = _entries$i2.duration;
    var end = startTime + duration;
    if (duration <= USER_TIMING_THRESHOLD || !shouldCreateSpan(startTime, end, trStart, trEnd)) {
      continue;
    }
    var kind = "app";
    var span = new span_default(name, kind);
    span._start = startTime;
    span.end(end);
    userTimingSpans.push(span);
  }
  return userTimingSpans;
}
var NAVIGATION_TIMING_MARKS = ["fetchStart", "domainLookupStart", "domainLookupEnd", "connectStart", "connectEnd", "requestStart", "responseStart", "responseEnd", "domLoading", "domInteractive", "domContentLoadedEventStart", "domContentLoadedEventEnd", "domComplete", "loadEventStart", "loadEventEnd"];
var COMPRESSED_NAV_TIMING_MARKS = ["fs", "ls", "le", "cs", "ce", "qs", "rs", "re", "dl", "di", "ds", "de", "dc", "es", "ee"];
function getNavigationTimingMarks(timing) {
  var fetchStart = timing.fetchStart, navigationStart = timing.navigationStart, responseStart = timing.responseStart, responseEnd = timing.responseEnd;
  if (fetchStart >= navigationStart && responseStart >= fetchStart && responseEnd >= responseStart) {
    var marks = {};
    NAVIGATION_TIMING_MARKS.forEach(function(timingKey) {
      var m = timing[timingKey];
      if (m && m >= fetchStart) {
        marks[timingKey] = parseInt(m - fetchStart);
      }
    });
    return marks;
  }
  return null;
}
function getPageLoadMarks(timing) {
  var marks = getNavigationTimingMarks(timing);
  if (marks == null) {
    return null;
  }
  return {
    navigationTiming: marks,
    agent: {
      timeToFirstByte: marks.responseStart,
      domInteractive: marks.domInteractive,
      domComplete: marks.domComplete
    }
  };
}
function captureNavigation(transaction) {
  if (!transaction.captureTimings) {
    return;
  }
  var trEnd = transaction._end;
  if (transaction.type === PAGE_LOAD) {
    if (transaction.marks && transaction.marks.custom) {
      var customMarks = transaction.marks.custom;
      Object.keys(customMarks).forEach(function(key) {
        customMarks[key] += transaction._start;
      });
    }
    var trStart = 0;
    transaction._start = trStart;
    var timings = PERF.timing;
    createNavigationTimingSpans(timings, timings.fetchStart, trStart, trEnd).forEach(function(span) {
      span.traceId = transaction.traceId;
      span.sampled = transaction.sampled;
      if (span.pageResponse && transaction.options.pageLoadSpanId) {
        span.id = transaction.options.pageLoadSpanId;
      }
      transaction.spans.push(span);
    });
    transaction.addMarks(getPageLoadMarks(timings));
  }
  if (isPerfTimelineSupported()) {
    var _trStart = transaction._start;
    var resourceEntries = PERF.getEntriesByType(RESOURCE);
    createResourceTimingSpans(resourceEntries, state.bootstrapTime, _trStart, trEnd).forEach(function(span) {
      return transaction.spans.push(span);
    });
    var userEntries = PERF.getEntriesByType(MEASURE);
    createUserTimingSpans(userEntries, _trStart, trEnd).forEach(function(span) {
      return transaction.spans.push(span);
    });
  }
}

// ../../node_modules/@elastic/apm-rum-core/dist/es/common/compress.js
function compressStackFrames(frames) {
  return frames.map(function(frame) {
    return {
      ap: frame.abs_path,
      f: frame.filename,
      fn: frame.function,
      li: frame.lineno,
      co: frame.colno
    };
  });
}
function compressResponse(response) {
  return {
    ts: response.transfer_size,
    ebs: response.encoded_body_size,
    dbs: response.decoded_body_size
  };
}
function compressHTTP(http) {
  var compressed = {};
  var method = http.method, status_code = http.status_code, url = http.url, response = http.response;
  compressed.url = url;
  if (method) {
    compressed.mt = method;
  }
  if (status_code) {
    compressed.sc = status_code;
  }
  if (response) {
    compressed.r = compressResponse(response);
  }
  return compressed;
}
function compressContext(context) {
  if (!context) {
    return null;
  }
  var compressed = {};
  var page = context.page, http = context.http, response = context.response, destination2 = context.destination, user = context.user, custom = context.custom;
  if (page) {
    compressed.p = {
      rf: page.referer,
      url: page.url
    };
  }
  if (http) {
    compressed.h = compressHTTP(http);
  }
  if (response) {
    compressed.r = compressResponse(response);
  }
  if (destination2) {
    var service = destination2.service;
    compressed.dt = {
      se: {
        n: service.name,
        t: service.type,
        rc: service.resource
      },
      ad: destination2.address,
      po: destination2.port
    };
  }
  if (user) {
    compressed.u = {
      id: user.id,
      un: user.username,
      em: user.email
    };
  }
  if (custom) {
    compressed.cu = custom;
  }
  return compressed;
}
function compressMarks(marks) {
  if (!marks) {
    return null;
  }
  var navigationTiming = marks.navigationTiming, agent = marks.agent;
  var compressed = {
    nt: {}
  };
  COMPRESSED_NAV_TIMING_MARKS.forEach(function(mark, index) {
    var mapping = NAVIGATION_TIMING_MARKS[index];
    compressed.nt[mark] = navigationTiming[mapping];
  });
  compressed.a = {
    fb: compressed.nt.rs,
    di: compressed.nt.di,
    dc: compressed.nt.dc
  };
  var fp = agent.firstContentfulPaint;
  var lp = agent.largestContentfulPaint;
  if (fp) {
    compressed.a.fp = fp;
  }
  if (lp) {
    compressed.a.lp = lp;
  }
  return compressed;
}
function compressMetadata(metadata) {
  var service = metadata.service, labels = metadata.labels;
  var agent = service.agent, language = service.language;
  return {
    se: {
      n: service.name,
      ve: service.version,
      a: {
        n: agent.name,
        ve: agent.version
      },
      la: {
        n: language.name
      },
      en: service.environment
    },
    l: labels
  };
}
function compressTransaction(transaction) {
  var spans = transaction.spans.map(function(span) {
    var spanData = {
      id: span.id,
      n: span.name,
      t: span.type,
      s: span.start,
      d: span.duration,
      c: compressContext(span.context),
      o: span.outcome,
      sr: span.sample_rate
    };
    if (span.parent_id !== transaction.id) {
      spanData.pid = span.parent_id;
    }
    if (span.sync === true) {
      spanData.sy = true;
    }
    if (span.subtype) {
      spanData.su = span.subtype;
    }
    if (span.action) {
      spanData.ac = span.action;
    }
    return spanData;
  });
  var tr = {
    id: transaction.id,
    tid: transaction.trace_id,
    n: transaction.name,
    t: transaction.type,
    d: transaction.duration,
    c: compressContext(transaction.context),
    k: compressMarks(transaction.marks),
    me: compressMetricsets(transaction.breakdown),
    y: spans,
    yc: {
      sd: spans.length
    },
    sm: transaction.sampled,
    sr: transaction.sample_rate,
    o: transaction.outcome
  };
  if (transaction.experience) {
    var _transaction$experien = transaction.experience, cls = _transaction$experien.cls, fid = _transaction$experien.fid, tbt = _transaction$experien.tbt, longtask = _transaction$experien.longtask;
    tr.exp = {
      cls,
      fid,
      tbt,
      lt: longtask
    };
  }
  if (transaction.session) {
    var _transaction$session = transaction.session, id = _transaction$session.id, sequence = _transaction$session.sequence;
    tr.ses = {
      id,
      seq: sequence
    };
  }
  return tr;
}
function compressError(error) {
  var exception = error.exception;
  var compressed = {
    id: error.id,
    cl: error.culprit,
    ex: {
      mg: exception.message,
      st: compressStackFrames(exception.stacktrace),
      t: error.type
    },
    c: compressContext(error.context)
  };
  var transaction = error.transaction;
  if (transaction) {
    compressed.tid = error.trace_id;
    compressed.pid = error.parent_id;
    compressed.xid = error.transaction_id;
    compressed.x = {
      t: transaction.type,
      sm: transaction.sampled
    };
  }
  return compressed;
}
function compressMetricsets(breakdowns) {
  return breakdowns.map(function(_ref) {
    var span = _ref.span, samples = _ref.samples;
    var isSpan = span != null;
    if (isSpan) {
      return {
        y: {
          t: span.type
        },
        sa: {
          ysc: {
            v: samples["span.self_time.count"].value
          },
          yss: {
            v: samples["span.self_time.sum.us"].value
          }
        }
      };
    }
    return {
      sa: {
        xdc: {
          v: samples["transaction.duration.count"].value
        },
        xds: {
          v: samples["transaction.duration.sum.us"].value
        },
        xbc: {
          v: samples["transaction.breakdown.count"].value
        }
      }
    };
  });
}
function compressPayload(params, type) {
  if (type === void 0) {
    type = "gzip";
  }
  var isCompressionStreamSupported = typeof CompressionStream === "function";
  return new Promise3(function(resolve2) {
    if (!isCompressionStreamSupported) {
      return resolve2(params);
    }
    var payload = params.payload, headers = params.headers, beforeSend = params.beforeSend;
    var payloadStream = new Blob([payload]).stream();
    var compressedStream = payloadStream.pipeThrough(new CompressionStream(type));
    return new Response(compressedStream).blob().then(function(payload2) {
      headers["Content-Encoding"] = type;
      return resolve2({
        payload: payload2,
        headers,
        beforeSend
      });
    });
  });
}

// ../../node_modules/@elastic/apm-rum-core/dist/es/common/apm-server.js
var THROTTLE_INTERVAL = 6e4;
var ApmServer = function() {
  function ApmServer2(configService, loggingService) {
    this._configService = configService;
    this._loggingService = loggingService;
    this.queue = void 0;
    this.throttleEvents = noop2;
  }
  var _proto = ApmServer2.prototype;
  _proto.init = function init2() {
    var _this = this;
    var queueLimit = this._configService.get("queueLimit");
    var flushInterval = this._configService.get("flushInterval");
    var limit = this._configService.get("eventsLimit");
    var onFlush = function onFlush2(events) {
      var promise = _this.sendEvents(events);
      if (promise) {
        promise.catch(function(reason) {
          _this._loggingService.warn("Failed sending events!", _this._constructError(reason));
        });
      }
    };
    this.queue = new queue_default(onFlush, {
      queueLimit,
      flushInterval
    });
    this.throttleEvents = throttle(this.queue.add.bind(this.queue), function() {
      return _this._loggingService.warn("Dropped events due to throttling!");
    }, {
      limit,
      interval: THROTTLE_INTERVAL
    });
  };
  _proto._postJson = function _postJson(endPoint, payload) {
    var _this2 = this;
    var headers = {
      "Content-Type": "application/x-ndjson"
    };
    var apmRequest = this._configService.get("apmRequest");
    var params = {
      payload,
      headers,
      beforeSend: apmRequest
    };
    return compressPayload(params).catch(function(error) {
      if (__DEV__) {
        _this2._loggingService.debug("Compressing the payload using CompressionStream API failed", error.message);
      }
      return params;
    }).then(function(result) {
      return _this2._makeHttpRequest("POST", endPoint, result);
    }).then(function(_ref) {
      var responseText = _ref.responseText;
      return responseText;
    });
  };
  _proto._constructError = function _constructError(reason) {
    var url = reason.url, status = reason.status, responseText = reason.responseText;
    if (typeof status == "undefined") {
      return reason;
    }
    var message = url + " HTTP status: " + status;
    if (__DEV__ && responseText) {
      try {
        var serverErrors = [];
        var response = JSON.parse(responseText);
        if (response.errors && response.errors.length > 0) {
          response.errors.forEach(function(err) {
            return serverErrors.push(err.message);
          });
          message += " " + serverErrors.join(",");
        }
      } catch (e) {
        this._loggingService.debug("Error parsing response from APM server", e);
      }
    }
    return new Error(message);
  };
  _proto._makeHttpRequest = function _makeHttpRequest(method, url, _temp) {
    var _ref2 = _temp === void 0 ? {} : _temp, _ref2$timeout = _ref2.timeout, timeout = _ref2$timeout === void 0 ? 1e4 : _ref2$timeout, payload = _ref2.payload, headers = _ref2.headers, beforeSend = _ref2.beforeSend;
    return new Promise3(function(resolve2, reject2) {
      var xhr = new window.XMLHttpRequest();
      xhr[XHR_IGNORE] = true;
      xhr.open(method, url, true);
      xhr.timeout = timeout;
      if (headers) {
        for (var header in headers) {
          if (headers.hasOwnProperty(header)) {
            xhr.setRequestHeader(header, headers[header]);
          }
        }
      }
      xhr.onreadystatechange = function() {
        if (xhr.readyState === 4) {
          var status = xhr.status, responseText = xhr.responseText;
          if (status === 0 || status > 399 && status < 600) {
            reject2({
              url,
              status,
              responseText
            });
          } else {
            resolve2(xhr);
          }
        }
      };
      xhr.onerror = function() {
        var status = xhr.status, responseText = xhr.responseText;
        reject2({
          url,
          status,
          responseText
        });
      };
      var canSend = true;
      if (typeof beforeSend === "function") {
        canSend = beforeSend({
          url,
          method,
          headers,
          payload,
          xhr
        });
      }
      if (canSend) {
        xhr.send(payload);
      } else {
        reject2({
          url,
          status: 0,
          responseText: "Request rejected by user configuration."
        });
      }
    });
  };
  _proto.fetchConfig = function fetchConfig(serviceName, environment) {
    var _this3 = this;
    var serverUrl = this._configService.get("serverUrl");
    var configEndpoint = serverUrl + "/config/v1/rum/agents";
    if (!serviceName) {
      return Promise3.reject("serviceName is required for fetching central config.");
    }
    configEndpoint += "?service.name=" + serviceName;
    if (environment) {
      configEndpoint += "&service.environment=" + environment;
    }
    var localConfig = this._configService.getLocalConfig();
    if (localConfig) {
      configEndpoint += "&ifnonematch=" + localConfig.etag;
    }
    var apmRequest = this._configService.get("apmRequest");
    return this._makeHttpRequest("GET", configEndpoint, {
      timeout: 5e3,
      beforeSend: apmRequest
    }).then(function(xhr) {
      var status = xhr.status, responseText = xhr.responseText;
      if (status === 304) {
        return localConfig;
      } else {
        var remoteConfig = JSON.parse(responseText);
        var etag = xhr.getResponseHeader("etag");
        if (etag) {
          remoteConfig.etag = etag.replace(/["]/g, "");
          _this3._configService.setLocalConfig(remoteConfig, true);
        }
        return remoteConfig;
      }
    }).catch(function(reason) {
      var error = _this3._constructError(reason);
      return Promise3.reject(error);
    });
  };
  _proto.createMetaData = function createMetaData() {
    var cfg = this._configService;
    var metadata = {
      service: {
        name: cfg.get("serviceName"),
        version: cfg.get("serviceVersion"),
        agent: {
          name: "rum-js",
          version: cfg.version
        },
        language: {
          name: "javascript"
        },
        environment: cfg.get("environment")
      },
      labels: cfg.get("context.tags")
    };
    return truncateModel(METADATA_MODEL, metadata);
  };
  _proto.addError = function addError(error) {
    var _this$throttleEvents;
    this.throttleEvents((_this$throttleEvents = {}, _this$throttleEvents[ERRORS] = error, _this$throttleEvents));
  };
  _proto.addTransaction = function addTransaction(transaction) {
    var _this$throttleEvents2;
    this.throttleEvents((_this$throttleEvents2 = {}, _this$throttleEvents2[TRANSACTIONS] = transaction, _this$throttleEvents2));
  };
  _proto.ndjsonErrors = function ndjsonErrors(errors, compress) {
    var key = compress ? "e" : "error";
    return errors.map(function(error) {
      var _NDJSON$stringify;
      return ndjson_default.stringify((_NDJSON$stringify = {}, _NDJSON$stringify[key] = compress ? compressError(error) : error, _NDJSON$stringify));
    });
  };
  _proto.ndjsonMetricsets = function ndjsonMetricsets(metricsets) {
    return metricsets.map(function(metricset) {
      return ndjson_default.stringify({
        metricset
      });
    }).join("");
  };
  _proto.ndjsonTransactions = function ndjsonTransactions(transactions, compress) {
    var _this4 = this;
    var key = compress ? "x" : "transaction";
    return transactions.map(function(tr) {
      var _NDJSON$stringify2;
      var spans = "", breakdowns = "";
      if (!compress) {
        if (tr.spans) {
          spans = tr.spans.map(function(span) {
            return ndjson_default.stringify({
              span
            });
          }).join("");
          delete tr.spans;
        }
        if (tr.breakdown) {
          breakdowns = _this4.ndjsonMetricsets(tr.breakdown);
          delete tr.breakdown;
        }
      }
      return ndjson_default.stringify((_NDJSON$stringify2 = {}, _NDJSON$stringify2[key] = compress ? compressTransaction(tr) : tr, _NDJSON$stringify2)) + spans + breakdowns;
    });
  };
  _proto.sendEvents = function sendEvents(events) {
    var _payload, _NDJSON$stringify3;
    if (events.length === 0) {
      return;
    }
    var transactions = [];
    var errors = [];
    for (var i = 0; i < events.length; i++) {
      var event = events[i];
      if (event[TRANSACTIONS]) {
        transactions.push(event[TRANSACTIONS]);
      }
      if (event[ERRORS]) {
        errors.push(event[ERRORS]);
      }
    }
    if (transactions.length === 0 && errors.length === 0) {
      return;
    }
    var cfg = this._configService;
    var payload = (_payload = {}, _payload[TRANSACTIONS] = transactions, _payload[ERRORS] = errors, _payload);
    var filteredPayload = cfg.applyFilters(payload);
    if (!filteredPayload) {
      this._loggingService.warn("Dropped payload due to filtering!");
      return;
    }
    var apiVersion = cfg.get("apiVersion");
    var compress = apiVersion > 2;
    var ndjson = [];
    var metadata = this.createMetaData();
    var metadataKey = compress ? "m" : "metadata";
    ndjson.push(ndjson_default.stringify((_NDJSON$stringify3 = {}, _NDJSON$stringify3[metadataKey] = compress ? compressMetadata(metadata) : metadata, _NDJSON$stringify3)));
    ndjson = ndjson.concat(this.ndjsonErrors(filteredPayload[ERRORS], compress), this.ndjsonTransactions(filteredPayload[TRANSACTIONS], compress));
    var ndjsonPayload = ndjson.join("");
    var endPoint = cfg.get("serverUrl") + ("/intake/v" + apiVersion + "/rum/events");
    return this._postJson(endPoint, ndjsonPayload);
  };
  return ApmServer2;
}();
var apm_server_default = ApmServer;

// ../../node_modules/@elastic/apm-rum-core/dist/es/common/event-handler.js
var EventHandler = function() {
  function EventHandler2() {
    this.observers = {};
  }
  var _proto = EventHandler2.prototype;
  _proto.observe = function observe(name, fn) {
    var _this = this;
    if (typeof fn === "function") {
      if (!this.observers[name]) {
        this.observers[name] = [];
      }
      this.observers[name].push(fn);
      return function() {
        var index = _this.observers[name].indexOf(fn);
        if (index > -1) {
          _this.observers[name].splice(index, 1);
        }
      };
    }
  };
  _proto.sendOnly = function sendOnly(name, args) {
    var obs = this.observers[name];
    if (obs) {
      obs.forEach(function(fn) {
        try {
          fn.apply(void 0, args);
        } catch (error) {
          console.log(error, error.stack);
        }
      });
    }
  };
  _proto.send = function send(name, args) {
    this.sendOnly(name + BEFORE_EVENT, args);
    this.sendOnly(name, args);
    this.sendOnly(name + AFTER_EVENT, args);
  };
  return EventHandler2;
}();
var event_handler_default = EventHandler;

// ../../node_modules/@elastic/apm-rum-core/dist/es/common/config-service.js
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function getConfigFromScript() {
  var script = getCurrentScript();
  var config = getDataAttributesFromNode(script);
  return config;
}
function getDataAttributesFromNode(node) {
  if (!node) {
    return {};
  }
  var dataAttrs = {};
  var dataRegex = /^data-([\w-]+)$/;
  var attrs = node.attributes;
  for (var i = 0; i < attrs.length; i++) {
    var attr = attrs[i];
    if (dataRegex.test(attr.nodeName)) {
      var key = attr.nodeName.match(dataRegex)[1];
      var camelCasedkey = key.split("-").map(function(value, index) {
        return index > 0 ? value.charAt(0).toUpperCase() + value.substring(1) : value;
      }).join("");
      dataAttrs[camelCasedkey] = attr.value || attr.nodeValue;
    }
  }
  return dataAttrs;
}
var Config = function() {
  function Config2() {
    this.config = {
      serviceName: "",
      serviceVersion: "",
      environment: "",
      serverUrl: "http://localhost:8200",
      active: true,
      instrument: true,
      disableInstrumentations: [],
      logLevel: "warn",
      breakdownMetrics: false,
      ignoreTransactions: [],
      eventsLimit: 80,
      queueLimit: -1,
      flushInterval: 500,
      distributedTracing: true,
      distributedTracingOrigins: [],
      distributedTracingHeaderName: "traceparent",
      pageLoadTraceId: "",
      pageLoadSpanId: "",
      pageLoadSampled: false,
      pageLoadTransactionName: "",
      propagateTracestate: false,
      transactionSampleRate: 1,
      centralConfig: false,
      monitorLongtasks: true,
      apiVersion: 2,
      context: {},
      session: false,
      apmRequest: null
    };
    this.events = new event_handler_default();
    this.filters = [];
    this.version = "";
  }
  var _proto = Config2.prototype;
  _proto.init = function init2() {
    var scriptData = getConfigFromScript();
    this.setConfig(scriptData);
  };
  _proto.setVersion = function setVersion(version) {
    this.version = version;
  };
  _proto.addFilter = function addFilter(cb) {
    if (typeof cb !== "function") {
      throw new Error("Argument to must be function");
    }
    this.filters.push(cb);
  };
  _proto.applyFilters = function applyFilters(data) {
    for (var i = 0; i < this.filters.length; i++) {
      data = this.filters[i](data);
      if (!data) {
        return;
      }
    }
    return data;
  };
  _proto.get = function get(key) {
    return key.split(".").reduce(function(obj, objKey) {
      return obj && obj[objKey];
    }, this.config);
  };
  _proto.setUserContext = function setUserContext(userContext) {
    if (userContext === void 0) {
      userContext = {};
    }
    var context = {};
    var _userContext = userContext, id = _userContext.id, username = _userContext.username, email = _userContext.email;
    if (typeof id === "number" || typeof id === "string") {
      context.id = id;
    }
    if (typeof username === "string") {
      context.username = username;
    }
    if (typeof email === "string") {
      context.email = email;
    }
    this.config.context.user = extend(this.config.context.user || {}, context);
  };
  _proto.setCustomContext = function setCustomContext(customContext) {
    if (customContext === void 0) {
      customContext = {};
    }
    this.config.context.custom = extend(this.config.context.custom || {}, customContext);
  };
  _proto.addLabels = function addLabels(tags) {
    var _this = this;
    if (!this.config.context.tags) {
      this.config.context.tags = {};
    }
    var keys = Object.keys(tags);
    keys.forEach(function(k) {
      return setLabel(k, tags[k], _this.config.context.tags);
    });
  };
  _proto.setConfig = function setConfig(properties) {
    if (properties === void 0) {
      properties = {};
    }
    var _properties = properties, transactionSampleRate = _properties.transactionSampleRate, serverUrl = _properties.serverUrl;
    if (serverUrl) {
      properties.serverUrl = serverUrl.replace(/\/+$/, "");
    }
    if (!isUndefined(transactionSampleRate)) {
      if (transactionSampleRate < 1e-4 && transactionSampleRate > 0) {
        transactionSampleRate = 1e-4;
      }
      properties.transactionSampleRate = Math.round(transactionSampleRate * 1e4) / 1e4;
    }
    merge(this.config, properties);
    this.events.send(CONFIG_CHANGE, [this.config]);
  };
  _proto.validate = function validate(properties) {
    if (properties === void 0) {
      properties = {};
    }
    var requiredKeys = ["serviceName", "serverUrl"];
    var errors = {
      missing: [],
      invalid: []
    };
    Object.keys(properties).forEach(function(key) {
      if (requiredKeys.indexOf(key) !== -1 && !properties[key]) {
        errors.missing.push(key);
      }
    });
    if (properties.serviceName && !/^[a-zA-Z0-9 _-]+$/.test(properties.serviceName)) {
      errors.invalid.push({
        key: "serviceName",
        value: properties.serviceName,
        allowed: "a-z, A-Z, 0-9, _, -, <space>"
      });
    }
    var sampleRate = properties.transactionSampleRate;
    if (typeof sampleRate !== "undefined" && (typeof sampleRate !== "number" || isNaN(sampleRate) || sampleRate < 0 || sampleRate > 1)) {
      errors.invalid.push({
        key: "transactionSampleRate",
        value: sampleRate,
        allowed: "Number between 0 and 1"
      });
    }
    return errors;
  };
  _proto.getLocalConfig = function getLocalConfig() {
    var storage = sessionStorage;
    if (this.config.session) {
      storage = localStorage;
    }
    var config = storage.getItem(LOCAL_CONFIG_KEY);
    if (config) {
      return JSON.parse(config);
    }
  };
  _proto.setLocalConfig = function setLocalConfig(config, merge2) {
    if (config) {
      if (merge2) {
        var prevConfig = this.getLocalConfig();
        config = _extends({}, prevConfig, config);
      }
      var storage = sessionStorage;
      if (this.config.session) {
        storage = localStorage;
      }
      storage.setItem(LOCAL_CONFIG_KEY, JSON.stringify(config));
    }
  };
  return Config2;
}();
var config_service_default = Config;

// ../../node_modules/@elastic/apm-rum-core/dist/es/common/logging-service.js
var LoggingService = function() {
  function LoggingService2(spec) {
    if (spec === void 0) {
      spec = {};
    }
    this.levels = ["trace", "debug", "info", "warn", "error"];
    this.level = spec.level || "warn";
    this.prefix = spec.prefix || "";
    this.resetLogMethods();
  }
  var _proto = LoggingService2.prototype;
  _proto.shouldLog = function shouldLog(level) {
    return this.levels.indexOf(level) >= this.levels.indexOf(this.level);
  };
  _proto.setLevel = function setLevel(level) {
    if (level === this.level) {
      return;
    }
    this.level = level;
    this.resetLogMethods();
  };
  _proto.resetLogMethods = function resetLogMethods() {
    var _this = this;
    this.levels.forEach(function(level) {
      _this[level] = _this.shouldLog(level) ? log : noop2;
      function log() {
        var normalizedLevel = level;
        if (level === "trace" || level === "debug") {
          normalizedLevel = "info";
        }
        var args = arguments;
        args[0] = this.prefix + args[0];
        if (console) {
          var realMethod = console[normalizedLevel] || console.log;
          if (typeof realMethod === "function") {
            realMethod.apply(console, args);
          }
        }
      }
    });
  };
  return LoggingService2;
}();
var logging_service_default = LoggingService;

// ../../node_modules/@elastic/apm-rum-core/dist/es/common/service-factory.js
var _serviceCreators;
var serviceCreators = (_serviceCreators = {}, _serviceCreators[CONFIG_SERVICE] = function() {
  return new config_service_default();
}, _serviceCreators[LOGGING_SERVICE] = function() {
  return new logging_service_default({
    prefix: "[Elastic APM] "
  });
}, _serviceCreators[APM_SERVER] = function(factory) {
  var _factory$getService = factory.getService([CONFIG_SERVICE, LOGGING_SERVICE]), configService = _factory$getService[0], loggingService = _factory$getService[1];
  return new apm_server_default(configService, loggingService);
}, _serviceCreators);
var ServiceFactory = function() {
  function ServiceFactory2() {
    this.instances = {};
    this.initialized = false;
  }
  var _proto = ServiceFactory2.prototype;
  _proto.init = function init2() {
    if (this.initialized) {
      return;
    }
    this.initialized = true;
    var configService = this.getService(CONFIG_SERVICE);
    configService.init();
    var _this$getService = this.getService([LOGGING_SERVICE, APM_SERVER]), loggingService = _this$getService[0], apmServer = _this$getService[1];
    configService.events.observe(CONFIG_CHANGE, function() {
      var logLevel = configService.get("logLevel");
      loggingService.setLevel(logLevel);
    });
    apmServer.init();
  };
  _proto.getService = function getService(name) {
    var _this = this;
    if (typeof name === "string") {
      if (!this.instances[name]) {
        if (typeof serviceCreators[name] === "function") {
          this.instances[name] = serviceCreators[name](this);
        } else if (__DEV__) {
          console.log("Cannot get service, No creator for: " + name);
        }
      }
      return this.instances[name];
    } else if (Array.isArray(name)) {
      return name.map(function(n) {
        return _this.getService(n);
      });
    }
  };
  return ServiceFactory2;
}();

// ../../node_modules/@elastic/apm-rum-core/dist/es/error-logging/index.js
function registerServices() {
  serviceCreators["ErrorLogging"] = function(serviceFactory) {
    var _serviceFactory$getSe = serviceFactory.getService([APM_SERVER, CONFIG_SERVICE, "TransactionService"]), apmServer = _serviceFactory$getSe[0], configService = _serviceFactory$getSe[1], transactionService = _serviceFactory$getSe[2];
    return new error_logging_default(apmServer, configService, transactionService);
  };
}

// ../../node_modules/@elastic/apm-rum-core/dist/es/common/patching/xhr-patch.js
function patchXMLHttpRequest(callback) {
  var XMLHttpRequestPrototype = XMLHttpRequest.prototype;
  if (!XMLHttpRequestPrototype || !XMLHttpRequestPrototype[ADD_EVENT_LISTENER_STR]) {
    return;
  }
  var READY_STATE_CHANGE = "readystatechange";
  var LOAD = "load";
  var ERROR2 = "error";
  var TIMEOUT = "timeout";
  var ABORT = "abort";
  function invokeTask(task, status) {
    if (task.state !== INVOKE) {
      task.state = INVOKE;
      task.data.status = status;
      callback(INVOKE, task);
    }
  }
  function scheduleTask(task) {
    if (task.state === SCHEDULE) {
      return;
    }
    task.state = SCHEDULE;
    callback(SCHEDULE, task);
    var target = task.data.target;
    function addListener(name) {
      target[ADD_EVENT_LISTENER_STR](name, function(_ref) {
        var type = _ref.type;
        if (type === READY_STATE_CHANGE) {
          if (target.readyState === 4 && target.status !== 0) {
            invokeTask(task, "success");
          }
        } else {
          var status = type === LOAD ? "success" : type;
          invokeTask(task, status);
        }
      });
    }
    addListener(READY_STATE_CHANGE);
    addListener(LOAD);
    addListener(TIMEOUT);
    addListener(ERROR2);
    addListener(ABORT);
  }
  var openNative = patchMethod(XMLHttpRequestPrototype, "open", function() {
    return function(self2, args) {
      if (!self2[XHR_IGNORE]) {
        self2[XHR_METHOD] = args[0];
        self2[XHR_URL] = args[1];
        self2[XHR_SYNC] = args[2] === false;
      }
      return openNative.apply(self2, args);
    };
  });
  var sendNative = patchMethod(XMLHttpRequestPrototype, "send", function() {
    return function(self2, args) {
      if (self2[XHR_IGNORE]) {
        return sendNative.apply(self2, args);
      }
      var task = {
        source: XMLHTTPREQUEST,
        state: "",
        type: "macroTask",
        data: {
          target: self2,
          method: self2[XHR_METHOD],
          sync: self2[XHR_SYNC],
          url: self2[XHR_URL],
          status: ""
        }
      };
      try {
        scheduleTask(task);
        return sendNative.apply(self2, args);
      } catch (e) {
        invokeTask(task, ERROR2);
        throw e;
      }
    };
  });
}

// ../../node_modules/@elastic/apm-rum-core/dist/es/common/patching/fetch-patch.js
function patchFetch(callback) {
  if (!window.fetch || !window.Request) {
    return;
  }
  function scheduleTask(task) {
    task.state = SCHEDULE;
    callback(SCHEDULE, task);
  }
  function invokeTask(task) {
    task.state = INVOKE;
    callback(INVOKE, task);
  }
  var nativeFetch = window.fetch;
  window.fetch = function(input, init2) {
    var fetchSelf = this;
    var args = arguments;
    var request, url;
    if (typeof input === "string") {
      request = new Request(input, init2);
      url = input;
    } else if (input) {
      request = input;
      url = request.url;
    } else {
      return nativeFetch.apply(fetchSelf, args);
    }
    var task = {
      source: FETCH,
      state: "",
      type: "macroTask",
      data: {
        target: request,
        method: request.method,
        url,
        aborted: false
      }
    };
    return new Promise3(function(resolve2, reject2) {
      globalState.fetchInProgress = true;
      scheduleTask(task);
      var promise;
      try {
        promise = nativeFetch.apply(fetchSelf, [request]);
      } catch (error) {
        reject2(error);
        task.data.error = error;
        invokeTask(task);
        globalState.fetchInProgress = false;
        return;
      }
      promise.then(function(response) {
        resolve2(response);
        scheduleMicroTask(function() {
          task.data.response = response;
          invokeTask(task);
        });
      }, function(error) {
        reject2(error);
        scheduleMicroTask(function() {
          task.data.error = error;
          invokeTask(task);
        });
      });
      globalState.fetchInProgress = false;
    });
  };
}

// ../../node_modules/@elastic/apm-rum-core/dist/es/common/patching/history-patch.js
function patchHistory(callback) {
  if (!window.history) {
    return;
  }
  var nativePushState = history.pushState;
  if (typeof nativePushState === "function") {
    history.pushState = function(state2, title, url) {
      var task = {
        source: HISTORY,
        data: {
          state: state2,
          title,
          url
        }
      };
      callback(INVOKE, task);
      nativePushState.apply(this, arguments);
    };
  }
}

// ../../node_modules/@elastic/apm-rum-core/dist/es/common/patching/event-target-patch.js
var eventTypes = ["click"];
var eventTypeSymbols = {};
for (i = 0; i < eventTypes.length; i++) {
  et = eventTypes[i];
  eventTypeSymbols[et] = apmSymbol(et);
}
var et;
var i;
function shouldInstrumentEvent(target, eventType, listenerFn) {
  return target instanceof Element && eventTypes.indexOf(eventType) >= 0 && typeof listenerFn === "function";
}
function patchEventTarget(callback) {
  if (!window.EventTarget) {
    return;
  }
  var proto = window.EventTarget.prototype;
  var nativeAddEventListener = proto[ADD_EVENT_LISTENER_STR];
  var nativeRemoveEventListener = proto[REMOVE_EVENT_LISTENER_STR];
  function findTaskIndex(existingTasks, eventType, listenerFn, capture) {
    for (var _i = 0; _i < existingTasks.length; _i++) {
      var task = existingTasks[_i];
      if (task.eventType === eventType && task.listenerFn === listenerFn && task.capture === capture) {
        return _i;
      }
    }
    return -1;
  }
  function isCapture(options) {
    var capture;
    if (typeof options === "boolean") {
      capture = options;
    } else {
      capture = options ? !!options.capture : false;
    }
    return capture;
  }
  function createListenerWrapper(target, eventType, listenerFn, options) {
    var eventSymbol = eventTypeSymbols[eventType];
    if (!eventSymbol)
      return listenerFn;
    var existingTasks = target[eventSymbol];
    var capture = isCapture(options);
    if (existingTasks) {
      var taskIndex = findTaskIndex(existingTasks, eventType, listenerFn, capture);
      if (taskIndex !== -1) {
        var _task = existingTasks[taskIndex];
        return _task.wrappingFn;
      }
    } else {
      existingTasks = target[eventSymbol] = [];
    }
    var task = {
      source: EVENT_TARGET,
      target,
      eventType,
      listenerFn,
      capture,
      wrappingFn
    };
    existingTasks.push(task);
    function wrappingFn() {
      callback(SCHEDULE, task);
      var result;
      try {
        result = listenerFn.apply(this, arguments);
      } finally {
        callback(INVOKE, task);
      }
      return result;
    }
    return wrappingFn;
  }
  function getWrappingFn(target, eventType, listenerFn, options) {
    var eventSymbol = eventTypeSymbols[eventType];
    var existingTasks = target[eventSymbol];
    if (existingTasks) {
      var capture = isCapture(options);
      var taskIndex = findTaskIndex(existingTasks, eventType, listenerFn, capture);
      if (taskIndex !== -1) {
        var task = existingTasks[taskIndex];
        existingTasks.splice(taskIndex, 1);
        if (existingTasks.length === 0) {
          target[eventSymbol] = void 0;
        }
        return task.wrappingFn;
      }
    }
    return listenerFn;
  }
  proto[ADD_EVENT_LISTENER_STR] = function(eventType, listenerFn, optionsOrCapture) {
    var target = this;
    if (!shouldInstrumentEvent(target, eventType, listenerFn)) {
      return nativeAddEventListener.apply(target, arguments);
    }
    var wrappingListenerFn = createListenerWrapper(target, eventType, listenerFn, optionsOrCapture);
    var args = Array.prototype.slice.call(arguments);
    args[1] = wrappingListenerFn;
    return nativeAddEventListener.apply(target, args);
  };
  proto[REMOVE_EVENT_LISTENER_STR] = function(eventType, listenerFn, optionsOrCapture) {
    var target = this;
    if (!shouldInstrumentEvent(target, eventType, listenerFn)) {
      return nativeRemoveEventListener.apply(target, arguments);
    }
    var wrappingFn = getWrappingFn(target, eventType, listenerFn, optionsOrCapture);
    var args = Array.prototype.slice.call(arguments);
    args[1] = wrappingFn;
    return nativeRemoveEventListener.apply(target, args);
  };
}

// ../../node_modules/@elastic/apm-rum-core/dist/es/common/patching/index.js
var patchEventHandler = new event_handler_default();
var alreadyPatched = false;
function patchAll() {
  if (!alreadyPatched) {
    alreadyPatched = true;
    patchXMLHttpRequest(function(event, task) {
      patchEventHandler.send(XMLHTTPREQUEST, [event, task]);
    });
    patchFetch(function(event, task) {
      patchEventHandler.send(FETCH, [event, task]);
    });
    patchHistory(function(event, task) {
      patchEventHandler.send(HISTORY, [event, task]);
    });
    patchEventTarget(function(event, task) {
      patchEventHandler.send(EVENT_TARGET, [event, task]);
    });
  }
  return patchEventHandler;
}

// ../../node_modules/@elastic/apm-rum-core/dist/es/performance-monitoring/performance-monitoring.js
var SIMILAR_SPAN_TO_TRANSACTION_RATIO = 0.05;
var TRANSACTION_DURATION_THRESHOLD = 6e4;
function groupSmallContinuouslySimilarSpans(originalSpans, transDuration, threshold) {
  originalSpans.sort(function(spanA, spanB) {
    return spanA._start - spanB._start;
  });
  var spans = [];
  var lastCount = 1;
  originalSpans.forEach(function(span, index) {
    if (spans.length === 0) {
      spans.push(span);
    } else {
      var lastSpan = spans[spans.length - 1];
      var isContinuouslySimilar = lastSpan.type === span.type && lastSpan.subtype === span.subtype && lastSpan.action === span.action && lastSpan.name === span.name && span.duration() / transDuration < threshold && (span._start - lastSpan._end) / transDuration < threshold;
      var isLastSpan = originalSpans.length === index + 1;
      if (isContinuouslySimilar) {
        lastCount++;
        lastSpan._end = span._end;
      }
      if (lastCount > 1 && (!isContinuouslySimilar || isLastSpan)) {
        lastSpan.name = lastCount + "x " + lastSpan.name;
        lastCount = 1;
      }
      if (!isContinuouslySimilar) {
        spans.push(span);
      }
    }
  });
  return spans;
}
function adjustTransaction(transaction) {
  if (transaction.sampled) {
    var filterdSpans = transaction.spans.filter(function(span) {
      return span.duration() > 0 && span._start >= transaction._start && span._end <= transaction._end;
    });
    if (transaction.isManaged()) {
      var duration = transaction.duration();
      var similarSpans = groupSmallContinuouslySimilarSpans(filterdSpans, duration, SIMILAR_SPAN_TO_TRANSACTION_RATIO);
      transaction.spans = similarSpans;
    } else {
      transaction.spans = filterdSpans;
    }
  } else {
    transaction.resetFields();
  }
  return transaction;
}
var PerformanceMonitoring = function() {
  function PerformanceMonitoring2(apmServer, configService, loggingService, transactionService) {
    this._apmServer = apmServer;
    this._configService = configService;
    this._logginService = loggingService;
    this._transactionService = transactionService;
  }
  var _proto = PerformanceMonitoring2.prototype;
  _proto.init = function init2(flags) {
    var _this = this;
    if (flags === void 0) {
      flags = {};
    }
    this._configService.events.observe(TRANSACTION_END + AFTER_EVENT, function(tr) {
      var payload = _this.createTransactionPayload(tr);
      if (payload) {
        _this._apmServer.addTransaction(payload);
      }
    });
    if (flags[HISTORY]) {
      patchEventHandler.observe(HISTORY, this.getHistorySub());
    }
    if (flags[XMLHTTPREQUEST]) {
      patchEventHandler.observe(XMLHTTPREQUEST, this.getXHRSub());
    }
    if (flags[FETCH]) {
      patchEventHandler.observe(FETCH, this.getFetchSub());
    }
    if (flags[EVENT_TARGET]) {
      patchEventHandler.observe(EVENT_TARGET, this.getEventTargetSub());
    }
  };
  _proto.getEventTargetSub = function getEventTargetSub() {
    var transactionService = this._transactionService;
    return function(event, task) {
      if (event === SCHEDULE && task.source === EVENT_TARGET && task.eventType === "click") {
        var target = task.target;
        var name = target.getAttribute("name");
        var additionalInfo = "";
        if (name) {
          additionalInfo = '["' + name + '"]';
        }
        var tagName = target.tagName.toLowerCase();
        var tr = transactionService.startTransaction("Click - " + tagName + additionalInfo, USER_INTERACTION, {
          managed: true,
          canReuse: true,
          reuseThreshold: 300
        });
        if (tr) {
          var classes = target.getAttribute("class");
          if (classes) {
            tr.addContext({
              custom: {
                classes
              }
            });
          }
        }
      }
    };
  };
  _proto.getHistorySub = function getHistorySub() {
    var transactionService = this._transactionService;
    return function(event, task) {
      if (task.source === HISTORY && event === INVOKE) {
        transactionService.startTransaction(task.data.title, "route-change", {
          managed: true,
          canReuse: true
        });
      }
    };
  };
  _proto.getXHRSub = function getXHRSub() {
    var _this2 = this;
    return function(event, task) {
      if (task.source === XMLHTTPREQUEST && !globalState.fetchInProgress) {
        _this2.processAPICalls(event, task);
      }
    };
  };
  _proto.getFetchSub = function getFetchSub() {
    var _this3 = this;
    return function(event, task) {
      if (task.source === FETCH) {
        _this3.processAPICalls(event, task);
      }
    };
  };
  _proto.processAPICalls = function processAPICalls(event, task) {
    var configService = this._configService;
    var transactionService = this._transactionService;
    if (event === SCHEDULE && task.data) {
      var data = task.data;
      var requestUrl = new Url(data.url);
      var spanName = data.method + " " + (requestUrl.relative ? requestUrl.path : stripQueryStringFromUrl(requestUrl.href));
      if (!transactionService.getCurrentTransaction()) {
        transactionService.startTransaction(spanName, HTTP_REQUEST_TYPE, {
          managed: true
        });
      }
      var span = transactionService.startSpan(spanName, "external.http", {
        blocking: true
      });
      if (!span) {
        return;
      }
      var isDtEnabled = configService.get("distributedTracing");
      var dtOrigins = configService.get("distributedTracingOrigins");
      var currentUrl = new Url(window.location.href);
      var isSameOrigin = checkSameOrigin(requestUrl.origin, currentUrl.origin) || checkSameOrigin(requestUrl.origin, dtOrigins);
      var target = data.target;
      if (isDtEnabled && isSameOrigin && target) {
        this.injectDtHeader(span, target);
        var propagateTracestate = configService.get("propagateTracestate");
        if (propagateTracestate) {
          this.injectTSHeader(span, target);
        }
      } else if (__DEV__) {
        this._logginService.debug("Could not inject distributed tracing header to the request origin ('" + requestUrl.origin + "') from the current origin ('" + currentUrl.origin + "')");
      }
      if (data.sync) {
        span.sync = data.sync;
      }
      data.span = span;
    } else if (event === INVOKE) {
      var _data = task.data;
      if (_data && _data.span) {
        var _span = _data.span, response = _data.response, _target = _data.target;
        var status;
        if (response) {
          status = response.status;
        } else {
          status = _target.status;
        }
        var outcome;
        if (_data.status != "abort") {
          if (status >= 400 || status == 0) {
            outcome = OUTCOME_FAILURE;
          } else {
            outcome = OUTCOME_SUCCESS;
          }
        }
        _span.outcome = outcome;
        var tr = transactionService.getCurrentTransaction();
        if (tr && tr.type === HTTP_REQUEST_TYPE) {
          tr.outcome = outcome;
        }
        transactionService.endSpan(_span, _data);
      }
    }
  };
  _proto.injectDtHeader = function injectDtHeader(span, target) {
    var headerName = this._configService.get("distributedTracingHeaderName");
    var headerValue = getDtHeaderValue(span);
    var isHeaderValid = isDtHeaderValid(headerValue);
    if (isHeaderValid && headerValue && headerName) {
      setRequestHeader(target, headerName, headerValue);
    }
  };
  _proto.injectTSHeader = function injectTSHeader(span, target) {
    var headerValue = getTSHeaderValue(span);
    if (headerValue) {
      setRequestHeader(target, "tracestate", headerValue);
    }
  };
  _proto.extractDtHeader = function extractDtHeader(target) {
    var configService = this._configService;
    var headerName = configService.get("distributedTracingHeaderName");
    if (target) {
      return parseDtHeaderValue(target[headerName]);
    }
  };
  _proto.filterTransaction = function filterTransaction(tr) {
    var duration = tr.duration();
    if (!duration) {
      if (__DEV__) {
        var message = "transaction(" + tr.id + ", " + tr.name + ") was discarded! ";
        if (duration === 0) {
          message += "Transaction duration is 0";
        } else {
          message += "Transaction wasn't ended";
        }
        this._logginService.debug(message);
      }
      return false;
    }
    if (tr.isManaged()) {
      if (duration > TRANSACTION_DURATION_THRESHOLD) {
        if (__DEV__) {
          this._logginService.debug("transaction(" + tr.id + ", " + tr.name + ") was discarded! Transaction duration (" + duration + ") is greater than managed transaction threshold (" + TRANSACTION_DURATION_THRESHOLD + ")");
        }
        return false;
      }
      if (tr.sampled && tr.spans.length === 0) {
        if (__DEV__) {
          this._logginService.debug("transaction(" + tr.id + ", " + tr.name + ") was discarded! Transaction does not have any spans");
        }
        return false;
      }
    }
    return true;
  };
  _proto.createTransactionDataModel = function createTransactionDataModel(transaction) {
    var transactionStart = transaction._start;
    var spans = transaction.spans.map(function(span) {
      var spanData = {
        id: span.id,
        transaction_id: transaction.id,
        parent_id: span.parentId || transaction.id,
        trace_id: transaction.traceId,
        name: span.name,
        type: span.type,
        subtype: span.subtype,
        action: span.action,
        sync: span.sync,
        start: parseInt(span._start - transactionStart),
        duration: span.duration(),
        context: span.context,
        outcome: span.outcome,
        sample_rate: span.sampleRate
      };
      return truncateModel(SPAN_MODEL, spanData);
    });
    var transactionData = {
      id: transaction.id,
      trace_id: transaction.traceId,
      session: transaction.session,
      name: transaction.name,
      type: transaction.type,
      duration: transaction.duration(),
      spans,
      context: transaction.context,
      marks: transaction.marks,
      breakdown: transaction.breakdownTimings,
      span_count: {
        started: spans.length
      },
      sampled: transaction.sampled,
      sample_rate: transaction.sampleRate,
      experience: transaction.experience,
      outcome: transaction.outcome
    };
    return truncateModel(TRANSACTION_MODEL, transactionData);
  };
  _proto.createTransactionPayload = function createTransactionPayload(transaction) {
    var adjustedTransaction = adjustTransaction(transaction);
    var filtered = this.filterTransaction(adjustedTransaction);
    if (filtered) {
      return this.createTransactionDataModel(transaction);
    }
  };
  return PerformanceMonitoring2;
}();

// ../../node_modules/@elastic/apm-rum-core/dist/es/performance-monitoring/breakdown.js
var pageLoadBreakdowns = [["domainLookupStart", "domainLookupEnd", "DNS"], ["connectStart", "connectEnd", "TCP"], ["requestStart", "responseStart", "Request"], ["responseStart", "responseEnd", "Response"], ["domLoading", "domComplete", "Processing"], ["loadEventStart", "loadEventEnd", "Load"]];
function getValue(value) {
  return {
    value
  };
}
function calculateSelfTime(transaction) {
  var spans = transaction.spans, _start = transaction._start, _end = transaction._end;
  if (spans.length === 0) {
    return transaction.duration();
  }
  spans.sort(function(span1, span2) {
    return span1._start - span2._start;
  });
  var span = spans[0];
  var spanEnd = span._end;
  var spanStart = span._start;
  var lastContinuousEnd = spanEnd;
  var selfTime = spanStart - _start;
  for (var i = 1; i < spans.length; i++) {
    span = spans[i];
    spanStart = span._start;
    spanEnd = span._end;
    if (spanStart > lastContinuousEnd) {
      selfTime += spanStart - lastContinuousEnd;
      lastContinuousEnd = spanEnd;
    } else if (spanEnd > lastContinuousEnd) {
      lastContinuousEnd = spanEnd;
    }
  }
  if (lastContinuousEnd < _end) {
    selfTime += _end - lastContinuousEnd;
  }
  return selfTime;
}
function groupSpans(transaction) {
  var spanMap = {};
  var transactionSelfTime = calculateSelfTime(transaction);
  spanMap["app"] = {
    count: 1,
    duration: transactionSelfTime
  };
  var spans = transaction.spans;
  for (var i = 0; i < spans.length; i++) {
    var span = spans[i];
    var duration = span.duration();
    if (duration === 0 || duration == null) {
      continue;
    }
    var type = span.type, subtype = span.subtype;
    var key = type.replace(TRUNCATED_TYPE, "");
    if (subtype) {
      key += "." + subtype;
    }
    if (!spanMap[key]) {
      spanMap[key] = {
        duration: 0,
        count: 0
      };
    }
    spanMap[key].count++;
    spanMap[key].duration += duration;
  }
  return spanMap;
}
function getSpanBreakdown(transactionDetails, _ref) {
  var details = _ref.details, _ref$count = _ref.count, count = _ref$count === void 0 ? 1 : _ref$count, duration = _ref.duration;
  return {
    transaction: transactionDetails,
    span: details,
    samples: {
      "span.self_time.count": getValue(count),
      "span.self_time.sum.us": getValue(duration)
    }
  };
}
function captureBreakdown(transaction, timings) {
  if (timings === void 0) {
    timings = PERF.timing;
  }
  var breakdowns = [];
  var trDuration = transaction.duration();
  var name = transaction.name, type = transaction.type, sampled = transaction.sampled;
  var transactionDetails = {
    name,
    type
  };
  breakdowns.push({
    transaction: transactionDetails,
    samples: {
      "transaction.duration.count": getValue(1),
      "transaction.duration.sum.us": getValue(trDuration),
      "transaction.breakdown.count": getValue(sampled ? 1 : 0)
    }
  });
  if (!sampled) {
    return breakdowns;
  }
  if (type === PAGE_LOAD && timings) {
    for (var i = 0; i < pageLoadBreakdowns.length; i++) {
      var current = pageLoadBreakdowns[i];
      var start = timings[current[0]];
      var end = timings[current[1]];
      var duration = getDuration(start, end);
      if (duration === 0 || duration == null) {
        continue;
      }
      breakdowns.push(getSpanBreakdown(transactionDetails, {
        details: {
          type: current[2]
        },
        duration
      }));
    }
  } else {
    var spanMap = groupSpans(transaction);
    Object.keys(spanMap).forEach(function(key) {
      var _key$split = key.split("."), type2 = _key$split[0], subtype = _key$split[1];
      var _spanMap$key = spanMap[key], duration2 = _spanMap$key.duration, count = _spanMap$key.count;
      breakdowns.push(getSpanBreakdown(transactionDetails, {
        details: {
          type: type2,
          subtype
        },
        duration: duration2,
        count
      }));
    });
  }
  return breakdowns;
}

// ../../node_modules/@elastic/apm-rum-core/dist/es/performance-monitoring/transaction.js
function _inheritsLoose2(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf2(subClass, superClass);
}
function _setPrototypeOf2(o, p) {
  _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf5(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf2(o, p);
}
var Transaction = function(_SpanBase) {
  _inheritsLoose2(Transaction2, _SpanBase);
  function Transaction2(name, type, options) {
    var _this;
    _this = _SpanBase.call(this, name, type, options) || this;
    _this.traceId = generateRandomId();
    _this.marks = void 0;
    _this.spans = [];
    _this._activeSpans = {};
    _this._activeTasks = /* @__PURE__ */ new Set();
    _this.blocked = false;
    _this.captureTimings = false;
    _this.breakdownTimings = [];
    _this.sampleRate = _this.options.transactionSampleRate;
    _this.sampled = Math.random() <= _this.sampleRate;
    return _this;
  }
  var _proto = Transaction2.prototype;
  _proto.addMarks = function addMarks(obj) {
    this.marks = merge(this.marks || {}, obj);
  };
  _proto.mark = function mark(key) {
    var skey = removeInvalidChars(key);
    var markTime = now() - this._start;
    var custom = {};
    custom[skey] = markTime;
    this.addMarks({
      custom
    });
  };
  _proto.canReuse = function canReuse() {
    var threshold = this.options.reuseThreshold || REUSABILITY_THRESHOLD;
    return !!this.options.canReuse && !this.ended && now() - this._start < threshold;
  };
  _proto.redefine = function redefine(name, type, options) {
    if (name) {
      this.name = name;
    }
    if (type) {
      this.type = type;
    }
    if (options) {
      extend(this.options, options);
    }
  };
  _proto.startSpan = function startSpan(name, type, options) {
    var _this2 = this;
    if (this.ended) {
      return;
    }
    var opts = extend({}, options);
    opts.onEnd = function(trc) {
      _this2._onSpanEnd(trc);
    };
    opts.traceId = this.traceId;
    opts.sampled = this.sampled;
    opts.sampleRate = this.sampleRate;
    if (!opts.parentId) {
      opts.parentId = this.id;
    }
    var span = new span_default(name, type, opts);
    this._activeSpans[span.id] = span;
    if (opts.blocking) {
      this.addTask(span.id);
    }
    return span;
  };
  _proto.isFinished = function isFinished() {
    return !this.blocked && this._activeTasks.size === 0;
  };
  _proto.detectFinish = function detectFinish() {
    if (this.isFinished())
      this.end();
  };
  _proto.end = function end(endTime) {
    if (this.ended) {
      return;
    }
    this.ended = true;
    this._end = getTime(endTime);
    for (var sid in this._activeSpans) {
      var span = this._activeSpans[sid];
      span.type = span.type + TRUNCATED_TYPE;
      span.end(endTime);
    }
    this.callOnEnd();
  };
  _proto.captureBreakdown = function captureBreakdown2() {
    this.breakdownTimings = captureBreakdown(this);
  };
  _proto.block = function block(flag) {
    this.blocked = flag;
    if (!this.blocked) {
      this.detectFinish();
    }
  };
  _proto.addTask = function addTask(taskId) {
    if (!taskId) {
      taskId = "task-" + generateRandomId(16);
    }
    this._activeTasks.add(taskId);
    return taskId;
  };
  _proto.removeTask = function removeTask(taskId) {
    var deleted = this._activeTasks.delete(taskId);
    deleted && this.detectFinish();
  };
  _proto.resetFields = function resetFields() {
    this.spans = [];
    this.sampleRate = 0;
  };
  _proto._onSpanEnd = function _onSpanEnd(span) {
    this.spans.push(span);
    delete this._activeSpans[span.id];
    this.removeTask(span.id);
  };
  _proto.isManaged = function isManaged() {
    return !!this.options.managed;
  };
  return Transaction2;
}(span_base_default);
var transaction_default = Transaction;

// ../../node_modules/@elastic/apm-rum-core/dist/es/performance-monitoring/metrics.js
var metrics = {
  fid: 0,
  fcp: 0,
  tbt: {
    start: Infinity,
    duration: 0
  },
  cls: 0,
  longtask: {
    count: 0,
    duration: 0,
    max: 0
  }
};
var LONG_TASK_THRESHOLD = 50;
function createLongTaskSpans(longtasks, agg) {
  var spans = [];
  for (var i = 0; i < longtasks.length; i++) {
    var _longtasks$i = longtasks[i], name = _longtasks$i.name, startTime = _longtasks$i.startTime, duration = _longtasks$i.duration, attribution = _longtasks$i.attribution;
    var end = startTime + duration;
    var span = new span_default("Longtask(" + name + ")", LONG_TASK, {
      startTime
    });
    agg.count++;
    agg.duration += duration;
    agg.max = Math.max(duration, agg.max);
    if (attribution.length > 0) {
      var _attribution$ = attribution[0], _name = _attribution$.name, containerType = _attribution$.containerType, containerName = _attribution$.containerName, containerId = _attribution$.containerId;
      var customContext = {
        attribution: _name,
        type: containerType
      };
      if (containerName) {
        customContext.name = containerName;
      }
      if (containerId) {
        customContext.id = containerId;
      }
      span.addContext({
        custom: customContext
      });
    }
    span.end(end);
    spans.push(span);
  }
  return spans;
}
function createFirstInputDelaySpan(fidEntries) {
  var firstInput = fidEntries[0];
  if (firstInput) {
    var startTime = firstInput.startTime, processingStart = firstInput.processingStart;
    var span = new span_default("First Input Delay", FIRST_INPUT, {
      startTime
    });
    span.end(processingStart);
    return span;
  }
}
function createTotalBlockingTimeSpan(tbtObject) {
  var start = tbtObject.start, duration = tbtObject.duration;
  var tbtSpan = new span_default("Total Blocking Time", LONG_TASK, {
    startTime: start
  });
  tbtSpan.end(start + duration);
  return tbtSpan;
}
function calculateTotalBlockingTime(longtaskEntries) {
  longtaskEntries.forEach(function(entry) {
    var name = entry.name, startTime = entry.startTime, duration = entry.duration;
    if (startTime < metrics.fcp) {
      return;
    }
    if (name !== "self" && name.indexOf("same-origin") === -1) {
      return;
    }
    metrics.tbt.start = Math.min(metrics.tbt.start, startTime);
    var blockingTime = duration - LONG_TASK_THRESHOLD;
    if (blockingTime > 0) {
      metrics.tbt.duration += blockingTime;
    }
  });
}
function calculateCumulativeLayoutShift(clsEntries) {
  clsEntries.forEach(function(entry) {
    if (!entry.hadRecentInput && entry.value) {
      metrics.cls += entry.value;
    }
  });
}
function captureObserverEntries(list, _ref) {
  var isHardNavigation = _ref.isHardNavigation, trStart = _ref.trStart;
  var longtaskEntries = list.getEntriesByType(LONG_TASK).filter(function(entry) {
    return entry.startTime >= trStart;
  });
  var longTaskSpans = createLongTaskSpans(longtaskEntries, metrics.longtask);
  var result = {
    spans: longTaskSpans,
    marks: {}
  };
  if (!isHardNavigation) {
    return result;
  }
  var lcpEntries = list.getEntriesByType(LARGEST_CONTENTFUL_PAINT);
  var lastLcpEntry = lcpEntries[lcpEntries.length - 1];
  if (lastLcpEntry) {
    var lcp = parseInt(lastLcpEntry.startTime);
    metrics.lcp = lcp;
    result.marks.largestContentfulPaint = lcp;
  }
  var timing = PERF.timing;
  var unloadDiff = timing.fetchStart - timing.navigationStart;
  var fcpEntry = list.getEntriesByName(FIRST_CONTENTFUL_PAINT)[0];
  if (fcpEntry) {
    var fcp = parseInt(unloadDiff >= 0 ? fcpEntry.startTime - unloadDiff : fcpEntry.startTime);
    metrics.fcp = fcp;
    result.marks.firstContentfulPaint = fcp;
  }
  var fidEntries = list.getEntriesByType(FIRST_INPUT);
  var fidSpan = createFirstInputDelaySpan(fidEntries);
  if (fidSpan) {
    metrics.fid = fidSpan.duration();
    result.spans.push(fidSpan);
  }
  calculateTotalBlockingTime(longtaskEntries);
  var clsEntries = list.getEntriesByType(LAYOUT_SHIFT);
  calculateCumulativeLayoutShift(clsEntries);
  return result;
}
var PerfEntryRecorder = function() {
  function PerfEntryRecorder2(callback) {
    this.po = {
      observe: noop2,
      disconnect: noop2
    };
    if (window.PerformanceObserver) {
      this.po = new PerformanceObserver(callback);
    }
  }
  var _proto = PerfEntryRecorder2.prototype;
  _proto.start = function start(type) {
    try {
      this.po.observe({
        type,
        buffered: true
      });
    } catch (_) {
    }
  };
  _proto.stop = function stop() {
    this.po.disconnect();
  };
  return PerfEntryRecorder2;
}();

// ../../node_modules/@elastic/apm-rum-core/dist/es/performance-monitoring/transaction-service.js
var TransactionService = function() {
  function TransactionService2(logger, config) {
    var _this = this;
    this._config = config;
    this._logger = logger;
    this.currentTransaction = void 0;
    this.respIntervalId = void 0;
    this.recorder = new PerfEntryRecorder(function(list) {
      var tr = _this.getCurrentTransaction();
      if (tr && tr.captureTimings) {
        var _tr$spans;
        var isHardNavigation = tr.type === PAGE_LOAD;
        var _captureObserverEntri = captureObserverEntries(list, {
          isHardNavigation,
          trStart: isHardNavigation ? 0 : tr._start
        }), spans = _captureObserverEntri.spans, marks = _captureObserverEntri.marks;
        (_tr$spans = tr.spans).push.apply(_tr$spans, spans);
        tr.addMarks({
          agent: marks
        });
      }
    });
  }
  var _proto = TransactionService2.prototype;
  _proto.createCurrentTransaction = function createCurrentTransaction(name, type, options) {
    var tr = new transaction_default(name, type, options);
    this.currentTransaction = tr;
    return tr;
  };
  _proto.getCurrentTransaction = function getCurrentTransaction() {
    if (this.currentTransaction && !this.currentTransaction.ended) {
      return this.currentTransaction;
    }
  };
  _proto.createOptions = function createOptions(options) {
    var config = this._config.config;
    var presetOptions = {
      transactionSampleRate: config.transactionSampleRate
    };
    var perfOptions = extend(presetOptions, options);
    if (perfOptions.managed) {
      perfOptions = extend({
        pageLoadTraceId: config.pageLoadTraceId,
        pageLoadSampled: config.pageLoadSampled,
        pageLoadSpanId: config.pageLoadSpanId,
        pageLoadTransactionName: config.pageLoadTransactionName
      }, perfOptions);
    }
    return perfOptions;
  };
  _proto.startManagedTransaction = function startManagedTransaction(name, type, perfOptions) {
    var tr = this.getCurrentTransaction();
    var isRedefined = false;
    if (!tr) {
      tr = this.createCurrentTransaction(name, type, perfOptions);
    } else if (tr.canReuse() && perfOptions.canReuse) {
      var redefineType = tr.type;
      var currentTypeOrder = TRANSACTION_TYPE_ORDER.indexOf(tr.type);
      var redefineTypeOrder = TRANSACTION_TYPE_ORDER.indexOf(type);
      if (currentTypeOrder >= 0 && redefineTypeOrder < currentTypeOrder) {
        redefineType = type;
      }
      if (__DEV__) {
        this._logger.debug("redefining transaction(" + tr.id + ", " + tr.name + ", " + tr.type + ")", "to", "(" + (name || tr.name) + ", " + redefineType + ")", tr);
      }
      tr.redefine(name, redefineType, perfOptions);
      isRedefined = true;
    } else {
      if (__DEV__) {
        this._logger.debug("ending previous transaction(" + tr.id + ", " + tr.name + ")", tr);
      }
      tr.end();
      tr = this.createCurrentTransaction(name, type, perfOptions);
    }
    if (tr.type === PAGE_LOAD) {
      if (!isRedefined) {
        this.recorder.start(LARGEST_CONTENTFUL_PAINT);
        this.recorder.start(PAINT);
        this.recorder.start(FIRST_INPUT);
        this.recorder.start(LAYOUT_SHIFT);
      }
      if (perfOptions.pageLoadTraceId) {
        tr.traceId = perfOptions.pageLoadTraceId;
      }
      if (perfOptions.pageLoadSampled) {
        tr.sampled = perfOptions.pageLoadSampled;
      }
      if (tr.name === NAME_UNKNOWN && perfOptions.pageLoadTransactionName) {
        tr.name = perfOptions.pageLoadTransactionName;
      }
    }
    if (!isRedefined && this._config.get("monitorLongtasks")) {
      this.recorder.start(LONG_TASK);
    }
    if (tr.sampled) {
      tr.captureTimings = true;
    }
    return tr;
  };
  _proto.startTransaction = function startTransaction(name, type, options) {
    var _this2 = this;
    var perfOptions = this.createOptions(options);
    var tr;
    var fireOnstartHook = true;
    if (perfOptions.managed) {
      var current = this.currentTransaction;
      tr = this.startManagedTransaction(name, type, perfOptions);
      if (current === tr) {
        fireOnstartHook = false;
      }
    } else {
      tr = new transaction_default(name, type, perfOptions);
    }
    tr.onEnd = function() {
      return _this2.handleTransactionEnd(tr);
    };
    if (fireOnstartHook) {
      if (__DEV__) {
        this._logger.debug("startTransaction(" + tr.id + ", " + tr.name + ", " + tr.type + ")");
      }
      this._config.events.send(TRANSACTION_START, [tr]);
    }
    return tr;
  };
  _proto.handleTransactionEnd = function handleTransactionEnd(tr) {
    var _this3 = this;
    this.recorder.stop();
    var currentUrl = window.location.href;
    return Promise3.resolve().then(function() {
      var name = tr.name, type = tr.type;
      var lastHiddenStart = state.lastHiddenStart;
      if (lastHiddenStart >= tr._start) {
        if (__DEV__) {
          _this3._logger.debug("transaction(" + tr.id + ", " + name + ", " + type + ") was discarded! The page was hidden during the transaction!");
        }
        return;
      }
      if (_this3.shouldIgnoreTransaction(name) || type === TEMPORARY_TYPE) {
        if (__DEV__) {
          _this3._logger.debug("transaction(" + tr.id + ", " + name + ", " + type + ") is ignored");
        }
        return;
      }
      if (type === PAGE_LOAD) {
        var pageLoadTransactionName = _this3._config.get("pageLoadTransactionName");
        if (name === NAME_UNKNOWN && pageLoadTransactionName) {
          tr.name = pageLoadTransactionName;
        }
        if (tr.captureTimings) {
          var cls = metrics.cls, fid = metrics.fid, tbt = metrics.tbt, longtask = metrics.longtask;
          if (tbt.duration > 0) {
            tr.spans.push(createTotalBlockingTimeSpan(tbt));
          }
          tr.experience = {};
          if (isPerfTypeSupported(LONG_TASK)) {
            tr.experience.tbt = tbt.duration;
          }
          if (isPerfTypeSupported(LAYOUT_SHIFT)) {
            tr.experience.cls = cls;
          }
          if (fid > 0) {
            tr.experience.fid = fid;
          }
          if (longtask.count > 0) {
            tr.experience.longtask = {
              count: longtask.count,
              sum: longtask.duration,
              max: longtask.max
            };
          }
        }
        _this3.setSession(tr);
      }
      if (tr.name === NAME_UNKNOWN) {
        tr.name = slugifyUrl(currentUrl);
      }
      captureNavigation(tr);
      _this3.adjustTransactionTime(tr);
      var breakdownMetrics = _this3._config.get("breakdownMetrics");
      if (breakdownMetrics) {
        tr.captureBreakdown();
      }
      var configContext = _this3._config.get("context");
      addTransactionContext(tr, configContext);
      _this3._config.events.send(TRANSACTION_END, [tr]);
      if (__DEV__) {
        _this3._logger.debug("end transaction(" + tr.id + ", " + tr.name + ", " + tr.type + ")", tr);
      }
    }, function(err) {
      if (__DEV__) {
        _this3._logger.debug("error ending transaction(" + tr.id + ", " + tr.name + ")", err);
      }
    });
  };
  _proto.setSession = function setSession(tr) {
    var session = this._config.get("session");
    if (session) {
      if (typeof session == "boolean") {
        tr.session = {
          id: generateRandomId(16),
          sequence: 1
        };
      } else {
        if (session.timestamp && Date.now() - session.timestamp > SESSION_TIMEOUT) {
          tr.session = {
            id: generateRandomId(16),
            sequence: 1
          };
        } else {
          tr.session = {
            id: session.id,
            sequence: session.sequence ? session.sequence + 1 : 1
          };
        }
      }
      var sessionConfig = {
        session: {
          id: tr.session.id,
          sequence: tr.session.sequence,
          timestamp: Date.now()
        }
      };
      this._config.setConfig(sessionConfig);
      this._config.setLocalConfig(sessionConfig, true);
    }
  };
  _proto.adjustTransactionTime = function adjustTransactionTime(transaction) {
    var spans = transaction.spans;
    var earliestSpan = getEarliestSpan(spans);
    if (earliestSpan && earliestSpan._start < transaction._start) {
      transaction._start = earliestSpan._start;
    }
    var latestSpan = getLatestNonXHRSpan(spans);
    if (latestSpan && latestSpan._end > transaction._end) {
      transaction._end = latestSpan._end;
    }
    var transactionEnd = transaction._end;
    for (var i = 0; i < spans.length; i++) {
      var span = spans[i];
      if (span._end > transactionEnd) {
        span._end = transactionEnd;
        span.type += TRUNCATED_TYPE;
      }
      if (span._start > transactionEnd) {
        span._start = transactionEnd;
      }
    }
  };
  _proto.shouldIgnoreTransaction = function shouldIgnoreTransaction(transactionName) {
    var ignoreList = this._config.get("ignoreTransactions");
    if (ignoreList && ignoreList.length) {
      for (var i = 0; i < ignoreList.length; i++) {
        var element = ignoreList[i];
        if (typeof element.test === "function") {
          if (element.test(transactionName)) {
            return true;
          }
        } else if (element === transactionName) {
          return true;
        }
      }
    }
    return false;
  };
  _proto.startSpan = function startSpan(name, type, options) {
    var tr = this.getCurrentTransaction();
    if (!tr) {
      tr = this.createCurrentTransaction(void 0, TEMPORARY_TYPE, this.createOptions({
        canReuse: true,
        managed: true
      }));
    }
    var span = tr.startSpan(name, type, options);
    if (__DEV__) {
      this._logger.debug("startSpan(" + name + ", " + span.type + ")", "on transaction(" + tr.id + ", " + tr.name + ")");
    }
    return span;
  };
  _proto.endSpan = function endSpan(span, context) {
    if (!span) {
      return;
    }
    if (__DEV__) {
      var tr = this.getCurrentTransaction();
      tr && this._logger.debug("endSpan(" + span.name + ", " + span.type + ")", "on transaction(" + tr.id + ", " + tr.name + ")");
    }
    span.end(null, context);
  };
  return TransactionService2;
}();
var transaction_service_default = TransactionService;

// ../../node_modules/@elastic/apm-rum-core/dist/es/performance-monitoring/index.js
function registerServices2() {
  serviceCreators["TransactionService"] = function(serviceFactory) {
    var _serviceFactory$getSe = serviceFactory.getService([LOGGING_SERVICE, CONFIG_SERVICE]), loggingService = _serviceFactory$getSe[0], configService = _serviceFactory$getSe[1];
    return new transaction_service_default(loggingService, configService);
  };
  serviceCreators["PerformanceMonitoring"] = function(serviceFactory) {
    var _serviceFactory$getSe2 = serviceFactory.getService([APM_SERVER, CONFIG_SERVICE, LOGGING_SERVICE, "TransactionService"]), apmServer = _serviceFactory$getSe2[0], configService = _serviceFactory$getSe2[1], loggingService = _serviceFactory$getSe2[2], transactionService = _serviceFactory$getSe2[3];
    return new PerformanceMonitoring(apmServer, configService, loggingService, transactionService);
  };
}

// ../../node_modules/@elastic/apm-rum-core/dist/es/common/instrument.js
function getInstrumentationFlags(instrument, disabledInstrumentations) {
  var _flags;
  var flags = (_flags = {}, _flags[XMLHTTPREQUEST] = false, _flags[FETCH] = false, _flags[HISTORY] = false, _flags[PAGE_LOAD] = false, _flags[ERROR] = false, _flags[EVENT_TARGET] = false, _flags);
  if (!instrument) {
    return flags;
  }
  Object.keys(flags).forEach(function(key) {
    if (disabledInstrumentations.indexOf(key) === -1) {
      flags[key] = true;
    }
  });
  return flags;
}

// ../../node_modules/@elastic/apm-rum-core/dist/es/common/after-frame.js
var RAF_TIMEOUT = 100;
function afterFrame(callback) {
  var handler = function handler2() {
    clearTimeout(timeout);
    cancelAnimationFrame(raf);
    setTimeout(callback);
  };
  var timeout = setTimeout(handler, RAF_TIMEOUT);
  var raf = requestAnimationFrame(handler);
}

// ../../node_modules/@elastic/apm-rum-core/dist/es/bootstrap.js
var enabled = false;
function bootstrap() {
  if (isPlatformSupported()) {
    patchAll();
    bootstrapPerf();
    state.bootstrapTime = now();
    enabled = true;
  } else if (isBrowser) {
    console.log("[Elastic APM] platform is not supported!");
  }
  return enabled;
}
function bootstrapPerf() {
  if (document.visibilityState === "hidden") {
    state.lastHiddenStart = 0;
  }
  window.addEventListener("visibilitychange", function() {
    if (document.visibilityState === "hidden") {
      state.lastHiddenStart = performance.now();
    }
  }, {
    capture: true
  });
}

// ../../node_modules/@elastic/apm-rum-core/dist/es/opentracing/tracer.js
var import_tracer = __toESM(require_tracer());
var import_constants22 = __toESM(require_constants());
var import_span5 = __toESM(require_span());

// ../../node_modules/@elastic/apm-rum-core/dist/es/opentracing/span.js
var import_span4 = __toESM(require_span());
function _inheritsLoose3(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf3(subClass, superClass);
}
function _setPrototypeOf3(o, p) {
  _setPrototypeOf3 = Object.setPrototypeOf || function _setPrototypeOf5(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf3(o, p);
}
var Span2 = function(_otSpan) {
  _inheritsLoose3(Span3, _otSpan);
  function Span3(tracer, span) {
    var _this;
    _this = _otSpan.call(this) || this;
    _this.__tracer = tracer;
    _this.span = span;
    _this.isTransaction = span instanceof transaction_default;
    _this.spanContext = {
      id: span.id,
      traceId: span.traceId,
      sampled: span.sampled
    };
    return _this;
  }
  var _proto = Span3.prototype;
  _proto._context = function _context() {
    return this.spanContext;
  };
  _proto._tracer = function _tracer() {
    return this.__tracer;
  };
  _proto._setOperationName = function _setOperationName(name) {
    this.span.name = name;
  };
  _proto._addTags = function _addTags(keyValuePairs) {
    var tags = extend({}, keyValuePairs);
    if (tags.type) {
      this.span.type = tags.type;
      delete tags.type;
    }
    if (this.isTransaction) {
      var userId = tags["user.id"];
      var username = tags["user.username"];
      var email = tags["user.email"];
      if (userId || username || email) {
        this.span.addContext({
          user: {
            id: userId,
            username,
            email
          }
        });
        delete tags["user.id"];
        delete tags["user.username"];
        delete tags["user.email"];
      }
    }
    this.span.addLabels(tags);
  };
  _proto._log = function _log(log, timestamp) {
    if (log.event === "error") {
      if (log["error.object"]) {
        this.__tracer.errorLogging.logError(log["error.object"]);
      } else if (log.message) {
        this.__tracer.errorLogging.logError(log.message);
      }
    }
  };
  _proto._finish = function _finish(finishTime) {
    this.span.end();
    if (finishTime) {
      this.span._end = finishTime - getTimeOrigin();
    }
  };
  return Span3;
}(import_span4.Span);
var span_default2 = Span2;

// ../../node_modules/@elastic/apm-rum-core/dist/es/opentracing/tracer.js
function _inheritsLoose4(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf4(subClass, superClass);
}
function _setPrototypeOf4(o, p) {
  _setPrototypeOf4 = Object.setPrototypeOf || function _setPrototypeOf5(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf4(o, p);
}
var Tracer = function(_otTracer) {
  _inheritsLoose4(Tracer2, _otTracer);
  function Tracer2(performanceMonitoring, transactionService, loggingService, errorLogging) {
    var _this;
    _this = _otTracer.call(this) || this;
    _this.performanceMonitoring = performanceMonitoring;
    _this.transactionService = transactionService;
    _this.loggingService = loggingService;
    _this.errorLogging = errorLogging;
    return _this;
  }
  var _proto = Tracer2.prototype;
  _proto._startSpan = function _startSpan(name, options) {
    var spanOptions = {
      managed: true
    };
    if (options) {
      spanOptions.timestamp = options.startTime;
      if (options.childOf) {
        spanOptions.parentId = options.childOf.id;
      } else if (options.references && options.references.length > 0) {
        if (options.references.length > 1) {
          if (__DEV__) {
            this.loggingService.debug("Elastic APM OpenTracing: Unsupported number of references, only the first childOf reference will be recorded.");
          }
        }
        var childRef = find(options.references, function(ref) {
          return ref.type() === import_constants22.REFERENCE_CHILD_OF;
        });
        if (childRef) {
          spanOptions.parentId = childRef.referencedContext().id;
        }
      }
    }
    var span;
    var currentTransaction = this.transactionService.getCurrentTransaction();
    if (currentTransaction) {
      span = this.transactionService.startSpan(name, void 0, spanOptions);
    } else {
      span = this.transactionService.startTransaction(name, void 0, spanOptions);
    }
    if (!span) {
      return new import_span5.Span();
    }
    if (spanOptions.timestamp) {
      span._start = spanOptions.timestamp - getTimeOrigin();
    }
    var otSpan2 = new span_default2(this, span);
    if (options && options.tags) {
      otSpan2.addTags(options.tags);
    }
    return otSpan2;
  };
  _proto._inject = function _inject(spanContext, format, carrier) {
    switch (format) {
      case import_constants22.FORMAT_TEXT_MAP:
      case import_constants22.FORMAT_HTTP_HEADERS:
        this.performanceMonitoring.injectDtHeader(spanContext, carrier);
        break;
      case import_constants22.FORMAT_BINARY:
        if (__DEV__) {
          this.loggingService.debug("Elastic APM OpenTracing: binary carrier format is not supported.");
        }
        break;
    }
  };
  _proto._extract = function _extract(format, carrier) {
    var ctx;
    switch (format) {
      case import_constants22.FORMAT_TEXT_MAP:
      case import_constants22.FORMAT_HTTP_HEADERS:
        ctx = this.performanceMonitoring.extractDtHeader(carrier);
        break;
      case import_constants22.FORMAT_BINARY:
        if (__DEV__) {
          this.loggingService.debug("Elastic APM OpenTracing: binary carrier format is not supported.");
        }
        break;
    }
    if (!ctx) {
      ctx = null;
    }
    return ctx;
  };
  return Tracer2;
}(import_tracer.Tracer);

// ../../node_modules/@elastic/apm-rum-core/dist/es/index.js
function createServiceFactory() {
  registerServices2();
  registerServices();
  var serviceFactory = new ServiceFactory();
  return serviceFactory;
}

// ../../node_modules/@elastic/apm-rum/dist/es/apm-base.js
var ApmBase = function() {
  function ApmBase2(serviceFactory, disable) {
    this._disable = disable;
    this.serviceFactory = serviceFactory;
    this._initialized = false;
  }
  var _proto = ApmBase2.prototype;
  _proto.isEnabled = function isEnabled() {
    return !this._disable;
  };
  _proto.isActive = function isActive() {
    var configService = this.serviceFactory.getService(CONFIG_SERVICE);
    return this.isEnabled() && this._initialized && configService.get("active");
  };
  _proto.init = function init2(config) {
    var _this = this;
    if (this.isEnabled() && !this._initialized) {
      this._initialized = true;
      var _this$serviceFactory$ = this.serviceFactory.getService([CONFIG_SERVICE, LOGGING_SERVICE]), configService = _this$serviceFactory$[0], loggingService = _this$serviceFactory$[1];
      configService.setVersion("5.9.1");
      this.config(config);
      var logLevel = configService.get("logLevel");
      loggingService.setLevel(logLevel);
      var isConfigActive = configService.get("active");
      if (isConfigActive) {
        this.serviceFactory.init();
        var flags = getInstrumentationFlags(configService.get("instrument"), configService.get("disableInstrumentations"));
        var performanceMonitoring = this.serviceFactory.getService("PerformanceMonitoring");
        performanceMonitoring.init(flags);
        if (flags[ERROR]) {
          var errorLogging = this.serviceFactory.getService("ErrorLogging");
          errorLogging.registerListeners();
        }
        if (configService.get("session")) {
          var localConfig = configService.getLocalConfig();
          if (localConfig && localConfig.session) {
            configService.setConfig({
              session: localConfig.session
            });
          }
        }
        var sendPageLoad = function sendPageLoad2() {
          return flags[PAGE_LOAD] && _this._sendPageLoadMetrics();
        };
        if (configService.get("centralConfig")) {
          this.fetchCentralConfig().then(sendPageLoad);
        } else {
          sendPageLoad();
        }
      } else {
        this._disable = true;
        loggingService.warn("RUM agent is inactive");
      }
    }
    return this;
  };
  _proto.fetchCentralConfig = function fetchCentralConfig() {
    var _this$serviceFactory$2 = this.serviceFactory.getService([APM_SERVER, LOGGING_SERVICE, CONFIG_SERVICE]), apmServer = _this$serviceFactory$2[0], loggingService = _this$serviceFactory$2[1], configService = _this$serviceFactory$2[2];
    return apmServer.fetchConfig(configService.get("serviceName"), configService.get("environment")).then(function(config) {
      var transactionSampleRate = config["transaction_sample_rate"];
      if (transactionSampleRate) {
        transactionSampleRate = Number(transactionSampleRate);
        var _config2 = {
          transactionSampleRate
        };
        var _configService$valida = configService.validate(_config2), invalid = _configService$valida.invalid;
        if (invalid.length === 0) {
          configService.setConfig(_config2);
        } else {
          var _invalid$ = invalid[0], key = _invalid$.key, value = _invalid$.value, allowed = _invalid$.allowed;
          loggingService.warn('invalid value "' + value + '" for ' + key + ". Allowed: " + allowed + ".");
        }
      }
      return config;
    }).catch(function(error) {
      loggingService.warn("failed fetching config:", error);
    });
  };
  _proto._sendPageLoadMetrics = function _sendPageLoadMetrics() {
    var tr = this.startTransaction(void 0, PAGE_LOAD, {
      managed: true,
      canReuse: true
    });
    if (!tr) {
      return;
    }
    tr.addTask(PAGE_LOAD);
    var sendPageLoadMetrics = function sendPageLoadMetrics2() {
      setTimeout(function() {
        return tr.removeTask(PAGE_LOAD);
      });
    };
    if (document.readyState === "complete") {
      sendPageLoadMetrics();
    } else {
      window.addEventListener("load", sendPageLoadMetrics);
    }
  };
  _proto.observe = function observe(name, fn) {
    var configService = this.serviceFactory.getService(CONFIG_SERVICE);
    configService.events.observe(name, fn);
  };
  _proto.config = function config(_config) {
    var configService = this.serviceFactory.getService(CONFIG_SERVICE);
    var _configService$valida2 = configService.validate(_config), missing = _configService$valida2.missing, invalid = _configService$valida2.invalid;
    if (missing.length === 0 && invalid.length === 0) {
      configService.setConfig(_config);
    } else {
      var loggingService = this.serviceFactory.getService(LOGGING_SERVICE);
      var separator = ", ";
      var message = "RUM agent isn't correctly configured. ";
      if (missing.length > 0) {
        message += missing.join(separator) + " is missing";
        if (invalid.length > 0) {
          message += separator;
        }
      }
      invalid.forEach(function(_ref, index) {
        var key = _ref.key, value = _ref.value, allowed = _ref.allowed;
        message += key + ' "' + value + '" contains invalid characters! (allowed: ' + allowed + ")" + (index !== invalid.length - 1 ? separator : "");
      });
      loggingService.error(message);
      configService.setConfig({
        active: false
      });
    }
  };
  _proto.setUserContext = function setUserContext(userContext) {
    var configService = this.serviceFactory.getService(CONFIG_SERVICE);
    configService.setUserContext(userContext);
  };
  _proto.setCustomContext = function setCustomContext(customContext) {
    var configService = this.serviceFactory.getService(CONFIG_SERVICE);
    configService.setCustomContext(customContext);
  };
  _proto.addLabels = function addLabels(labels) {
    var configService = this.serviceFactory.getService(CONFIG_SERVICE);
    configService.addLabels(labels);
  };
  _proto.setInitialPageLoadName = function setInitialPageLoadName(name) {
    var configService = this.serviceFactory.getService(CONFIG_SERVICE);
    configService.setConfig({
      pageLoadTransactionName: name
    });
  };
  _proto.startTransaction = function startTransaction(name, type, options) {
    if (this.isEnabled()) {
      var transactionService = this.serviceFactory.getService("TransactionService");
      return transactionService.startTransaction(name, type, options);
    }
  };
  _proto.startSpan = function startSpan(name, type, options) {
    if (this.isEnabled()) {
      var transactionService = this.serviceFactory.getService("TransactionService");
      return transactionService.startSpan(name, type, options);
    }
  };
  _proto.getCurrentTransaction = function getCurrentTransaction() {
    if (this.isEnabled()) {
      var transactionService = this.serviceFactory.getService("TransactionService");
      return transactionService.getCurrentTransaction();
    }
  };
  _proto.captureError = function captureError(error) {
    if (this.isEnabled()) {
      var errorLogging = this.serviceFactory.getService("ErrorLogging");
      return errorLogging.logError(error);
    }
  };
  _proto.addFilter = function addFilter(fn) {
    var configService = this.serviceFactory.getService(CONFIG_SERVICE);
    configService.addFilter(fn);
  };
  return ApmBase2;
}();

// ../../node_modules/@elastic/apm-rum/dist/es/index.js
function getApmBase() {
  if (isBrowser && window.elasticApm) {
    return window.elasticApm;
  }
  var enabled2 = bootstrap();
  var serviceFactory = createServiceFactory();
  var apmBase2 = new ApmBase(serviceFactory, !enabled2);
  if (isBrowser) {
    window.elasticApm = apmBase2;
  }
  return apmBase2;
}
var apmBase = getApmBase();
var init = apmBase.init.bind(apmBase);
var es_default = init;

export {
  afterFrame,
  ApmBase,
  apmBase,
  init,
  es_default
};
//# sourceMappingURL=chunk-K5GMOEOK.js.map
